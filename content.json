{"meta":{"title":"G2.int.BUPT","subtitle":"我爱网管","description":null,"author":"郭源潮","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-10-30T08:49:46.000Z","updated":"2019-10-30T09:16:08.744Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-10-28T13:55:14.000Z","updated":"2019-11-01T08:40:05.262Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"北京邮电大学 网络技术研究院 2019级渣硕95后，没有钱，长得丑；喜欢运动但基本不动。在B站学习，在实验室摸鱼；被大佬虐过，真的心服口服。不相信恋爱，但朋友都很铁，对coding一往情深。同学朋友都很奈斯，偶尔几个戏精也无伤大雅。科研的道路总是要写文档，人生的旅途也是不咋顺畅迷茫过，纠结过，后悔过，也一直焦虑着，跌跌撞撞。意识到自己很菜。但是也不能太菜，还是要争取向上。比心~ Have a nice day !"},{"title":"项目","date":"2019-10-29T06:13:36.000Z","updated":"2019-10-30T09:17:02.650Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":"北京邮电大学"},{"title":"帮黄某欣征友~","date":"2019-10-31T07:48:28.662Z","updated":"2019-10-31T07:48:28.662Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-30T08:55:13.000Z","updated":"2019-10-30T09:13:15.720Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"剑指Offer41. 数据流中的中位数  P214","slug":"剑指offer41","date":"2019-11-01T08:13:28.000Z","updated":"2019-11-01T08:23:59.533Z","comments":true,"path":"2019/11/01/剑指offer41/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer41/","excerpt":"","text":"剑指offer41. 数据流中的中位数 P214题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值 首先，题目说一个数据流，就证明可能不能一次读入内存（我们这里用一个数组模拟输入流） 如果将数组从中间一分为二，中间的一个（len是奇数）或者两个元素（len是偶数）左边都比他们小，右边都比他们大，前后两半部分不用排序，只用划分出来就行。那么最后在中间的就是中位数。左半部分是最大堆，右边是最小堆。 这个想法是使用两个堆（一个最大堆，一个最小堆）保存输入数据。 max_pq是一个大堆，以较小的值保存数据的前半部分，而min_pq是最小堆，以较大的值保存数据的后半个。 每次插入新值时，我们都会先比较它是否小于max_pq的顶部（前一半的最大值），如果是，则将其插入max_pq。 否则，它属于下半部分。 插入后，我们必须平衡前半部分和后半部分，以确保它们具有相同的长度或长度差仅为1,否则最后两个堆顶的元素不在最中间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445priority_queue &lt;int&gt; max_pq; //最大堆，其中最大元素堆顶也小于最小堆中任一元素priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; min_pq; // 最小堆，堆顶最小bool isAnsValid = false;// 返回0.0时有效与否void addHeap(int num) &#123; // 插入节点 if (max_pq.empty() || num &lt; max_pq.top()) &#123; // 先插入最大堆 max_pq.push(num); &#125; else &#123; // 当前值比最大堆顶还大，插入最小堆 min_pq.push(num); &#125; if (min_pq.size() &gt; max_pq.size() + 1) &#123; // 最小堆元素个数比最大的超过1，调整 int temp = min_pq.top(); min_pq.pop(); max_pq.push(temp); &#125; else if (max_pq.size() &gt; min_pq.size() + 1) &#123; // 同理 int temp = max_pq.top(); max_pq.pop(); min_pq.push(temp); &#125;&#125;double findCore() &#123; // 找中位数 if (!max_pq.empty()) &#123; isAnsValid = true; // 返回值有效 if (max_pq.size() == min_pq.size()) &#123; // len偶数，取均值 return (max_pq.top() + min_pq.top()) / 2.0; &#125; else &#123; // len奇数，取堆顶 return (max_pq.size() &gt; min_pq.size()) ? max_pq.top() : min_pq.top(); &#125; &#125; else 0.0; // 失败&#125;double findMidInList(int *nums, int len) &#123; if (nums == NULL || len &lt; 1) return 0.0; while (!max_pq.empty()) max_pq.pop(); // 清空堆 while (!min_pq.empty()) min_pq.pop(); for(int i = 0; i &lt; len; ++i)&#123; // 建堆 addHeap(nums[i]); &#125; return findCore();&#125; 扩展优先队列（堆）头文件：#include&lt; queue &gt;大根堆定义：priority_queue&lt; int &gt;pq小根堆定义：priority_queue&lt; int ,vector&lt; int &gt;,greater&lt; int &gt; &gt;pq（注意最后两个“&gt;”符号不要连在一起，否则很多编译器误认为是‘&gt;&gt;’运算符） 操作：push() 元素入队 pop() 队首元素出队 top() 取队首元素empty() 如果队列为空，则返回true（1），否则返回false（0）size() 返回优先队列中拥有的元素个数","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"堆","slug":"堆","permalink":"http://yoursite.com/tags/%E5%A0%86/"}]},{"title":"剑指Offer40. 最小的K个数 P209","slug":"剑指offer40","date":"2019-11-01T07:26:35.000Z","updated":"2019-11-01T08:11:28.869Z","comments":true,"path":"2019/11/01/剑指offer40/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer40/","excerpt":"","text":"剑指offer40. 最小的k个数 P209题目：输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 方法一：类似于上一题39， 同样基于Partition函数对数组进行划分，基于第k个元素调整，使得第k个索引之前的都比num[k]小, k之后的都比nums[k]大。左边的k个数字就是最小的k个数字，但是这些数字可能无序。 123456789101112131415161718192021Vector&lt;int&gt; findCore(int *nums,int len) &#123; // 主调函数vector&lt;int&gt; v; // 返回list if (!isValid(nums, len)) &#123; // 鲁棒性 return v; &#125; int mid = len &gt;&gt; 1; // 中位数索引 int start = 0; int end = len - 1; int index = Partition(nums, start, end); // 第一次划分 while (index != k - 1) &#123; // 出口 if (index &gt; k - 1) end = index - 1; else start = index + 1; index = Partition(nums, start, end); &#125; for(int i = 0; i &lt; k; ++i) v.push_back(nums[i]);&#125; 时间复杂度是 O(n), 不适合海量数据（快排必须一次性读入内存）而且会污染数组。 方法2： 最大堆 本方法使用于海量数据处理。大致思想是建一个K个数的大堆，每次拿一个数和堆顶元素比较，如果这个数比堆顶元素大，则必然不是最小的K个数，如果这个数比堆顶元素小，则与堆顶元素交换，然后在向下调整一次建成新的大堆，然后遍历所有的数，直到最小的K个数都进堆里。这样既可以保证堆中是存的目前的最小的k个数，还不用一次性把所有数据读入内存，每次只从磁盘取一个和堆顶比较即可。时间复杂度O(nlogk), 但是非常适用海量数据注意：最大的K个数—- 建小堆 最小的K个数—-建大堆 // 下面是自建大顶堆 或者允许的话，更简单的办法是用STL： 优先队列（见下一题） 123456789101112131415161718192021222324252627282930313233void AdjustDown(int* input, int k, int parent) &#123; if (input == NULL || k &lt;= 0) return; int child = 2 * parent + 1; while (child &lt; k) &#123; if ((child + 1 &lt; k) &amp;&amp; (input[child] &lt; input[child + 1])) ++child; if (input[child]&gt;input[parent]) &#123; Swap(&amp;input[child], &amp;input[parent]); parent = child; child = 2 * parent + 1; &#125; else break; &#125;&#125;void MinKNumber_op(int* input, int len, int k) &#123; assert(input); // 鲁棒性 int i = 0; for (i = (2 * k - 2) / 2; i &gt;= 0; i--) //利用前K个数建大堆 AdjustDown(input, k, i); // 遍历后边的数，如果小于堆顶元素则入堆 for (i = k; i &lt; len; i++) &#123; if (input[i] &lt; input[0]) &#123; Swap(&amp;input[i], &amp;input[0]); AdjustDown(input, k, 0); &#125; &#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆","slug":"堆","permalink":"http://yoursite.com/tags/%E5%A0%86/"}]},{"title":"剑指Offer39. 数组中出现次数超过一半的数字 P39","slug":"剑指offer39","date":"2019-11-01T07:26:30.000Z","updated":"2019-11-01T07:58:56.250Z","comments":true,"path":"2019/11/01/剑指offer39/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer39/","excerpt":"","text":"剑指offer39. 数组中出现次数超过一半的数字 P39题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1, 2, 3, 2, 2, 2, 5, 4, 2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。 1. 基于快排 （会污染数组）其实只要涉及顺序的问题，大多数都可以排序。这题可以建立在快排的基础上，每做一次划分之后，把当前划分元素的索引index返回，这个数就是整个数组第index小的数，如果index=len/2, 结束递归。因为出现次数超过数组长度一半的元素最后一定有一个在索引是len/2的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465bool ansIsValid = true; // 全局变量，=true时返回的0代表没有找到bool isValid(int *nums, int len)&#123; // 输入鲁棒性检查 if (nums == NULL || len &lt; 1) return false; return true;&#125;bool isMoreHalf(int *nums, int len, int num)&#123; //看最后找到的元素的个数是否真的超过一半 int count = 0; for (int i = 0; i &lt; len; ++i) &#123; if (nums[i] == num) ++count; &#125; if (count &lt;= len / 2) return false; // 必须 &gt; len / 2 才行！！ return true;&#125;int Partition(int *nums, int start, int end) &#123; //快排的一次划分，返回固定元素后的索引 int flag = nums[start]; int i = start, j = end; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt;= flag) --j; int rightmin = nums[j]; while (i &lt; j &amp;&amp; nums[i] &lt;= flag) ++i; nums[j] = nums[i]; nums[i] = rightmin; &#125; nums[start] = nums[i]; nums[i] = flag; return i; // i的位置不会变了&#125;int findCore(int *nums,int len) &#123; // 主调函数ansIsValid = true; // 默认答案无效，不仅下面鲁棒性要用，最后检验也要用 if (!isValid(nums, len)) &#123; // 鲁棒性 return 0; &#125; int mid = len &gt;&gt; 1; // 中位数索引 int start = 0; int end = len - 1; int index = Partition(nums, start, end); // 第一次划分 /* 为什么比的是索引而不是值，因为index前后一边大一边小是确定的 只有index到中间时，才能保证从头到中间，或者从中间到尾巴都是一个数 这样才能找到超过一半的数 */ while (index != mid) &#123; // 出口 if (index &gt; mid) end = index - 1; else start = index + 1; index = Partition(nums, start, end); // 选择左还是右划分 &#125; if (isMoreHalf(nums, len, nums[index])) &#123; // 检验是不是真的个数超过数组长度一半 ansIsValid = false; // 确实超过 return nums[index]; &#125; else &#123; return 0; &#125; &#125; 方法2： 比较个数差 （没有污染数组） 从个数入手，有一个数字出现次数超过一半，也就是说它比其他所有数字次数和都多。我们把这个数和其他数分成两组 “相对抗” , 用一个变量存数字res，另一个存次数count。遍历数组，当前数字和上一个相等，次数+1；不等，次数-1，如果次数减到0，把res更新为当前数字，count更新为1. 到最后因为我们要找的数次数比其他的和都多，那么它一定时最后一次把count设成1的数。 123456789101112131415161718192021222324252627282930bool isAns = true; // 判断return 0 时是不是有效 int findSBNumber(int nums[], int len) &#123; isAns = true; // 要在鲁棒性检查之前设置 if (nums == NULL || len &lt; 1) return 0; int ans = nums[0]; // 上文中的res int count = 1; for (int i = 0; i &lt; len; ++i) &#123; if (nums[i] != ans) &#123; --count; if (count == 0) &#123; count = 1; ans = nums[i]; &#125; &#125;else &#123; ++count; &#125; &#125; count = 0; for (int i = 0; i &lt; len; ++i) &#123; // 验证是不是真的个数超过一半 if (nums[i] == ans) ++count; &#125; if (count &lt;= len / 2) return 0; isAns = false; return ans;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer38. 字符串全排列、子集 P197","slug":"剑指offer38","date":"2019-11-01T07:26:26.000Z","updated":"2019-11-01T08:38:46.131Z","comments":true,"path":"2019/11/01/剑指offer38/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer38/","excerpt":"","text":"剑指offer38. 字符串全排列、子集 P197题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。 方法一 : 非递归方法（字典序，这种方法被用在STL库中）转载自：转载博客 对给定的字符集中的字符规定了一个先后关系，在此基础上规定两个全排列的先后是从左到右逐个比较对应的字符的先后。 [例]字符集{1,2,3},较小的数字较先,这样按字典序生成的全排列是: 123,132,213,231,312,321 一个全排列可看做一个字符串，字符串可有前缀、后缀。生成给定全排列的下一个排列：所谓一个的下一个就是这一个与下一个之间没有其他的。这就要求这一个与下一个有尽可能长的共同前缀。例如：如何得到346987521的下一个 从尾部往前找第一个P(i-1) &lt; P(i)的位置，最终找到6是第一个，记录下6的位置i-13 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1 从i位置往后找到最后一个大于6的数，最终找到7的位置，记录位置为m3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1 交换位置i-1和m的值 ： 3 4 7 9 8 6 5 2 1 倒序i-1位置后的所有数据： 3 4 7 1 2 5 6 8 9 12345678910111213141516171819bool cmp(char a, char b)&#123; if (a &lt; b) return true; else return false;&#125;void print(char *str, int len) &#123; if (str == NULL) return ; sort(str, str + len, cmp); // 按某种规则排序 while (1) &#123; printf(\"%s \\n\", str); // 一定要先打印，不然排序后的第一个序列打印不了 int first = len - 1; while (first &gt; 0 &amp;&amp; str[first] &lt; str[first - 1]) --first; // 倒序找第一个比后面小的数字 if (first == 0) break; // 如果倒序结束，都没有找到，说明序列完全递减，结束 int minBigger = first; // 从first位置出发，找比first-1大的数字里面的最小的 while (minBigger + 1 &lt; len &amp;&amp; str[minBigger + 1] &gt; str[first - 1]) ++minBigger; swap(str, minBigger, first - 1); // 交换两个值 reverse(str + first, str + len); // 倒置 &#125;&#125; 方法2：递归递归全排列 1 2 3 4 5 1，for循环将每个位置的数据交换到第一位 swap(1,1~5)2，按相同的方式全排列剩余的位 关于循环里面有递归可以这么想：在最外层的需求是要把当前序列的第一个数和后面的每一个都交换，显然递归是做不到的，只能用循环。在交换之后，要对除了当前子序列的第一个元素外的剩余元素做全排列，这显然是递归过程。两者是分层的嵌套关系 12345678910111213141516171819void prem(char *str, int start, int end) &#123; if (start &gt;= end) // 起始位置等于终止位置，自然不往下递归交换了，结束并输出 printf(\"%s \\n\", str); else &#123; for (int i = start; i &lt;= end; ++i) &#123; // 把起始位置和后面的位置依此交换 // sort(str + i, str + end + 1,cmp); 如果要按某种顺序输出，这里排序 swap(str, i, start); prem(str, start + 1, end); // 递归下一个位置 swap(str, i, start); &#125; &#125; &#125;void premation(char *str, int len) &#123; // 主调函数 if (str == NULL) return; prem(str, 0, len - 1); // 全排列的起始位置，终止位置&#125; 扩展: 求组合数（子集） 12345678910111213141516vector&lt; vector&lt;char&gt; &gt; zuhe(char *str) &#123; // 主调函数，返回二维list 存储所有子集 if (str == NULL) return NULL; vector&lt; vector&lt;char&gt; &gt; ans ; vector &lt;char&gt; t; // 存储当前遍历到的一个子集 DFS(str, 0, t, ans); return ans; &#125;void DFS(char* str, int index, vector &lt;char&gt; &amp;t, vector&lt; vector&lt;char&gt; &gt; &amp;ans) &#123; ans.push_back(t); // 第一次调用，存的空集 for (int j = index; j &lt; strlen(str); ++j) &#123; t.push_back(str[j]); // 当前数字加入当前子集中 DFS(str, j + 1, t, ans); // 递归下一个位置的数 t.pop_back(); // 回溯，当前子集舍弃当前数 &#125;&#125; 扩展： 1. 8个数放正方体的8个顶点，要求任意一个面的4个顶点和相等 2. 8皇后问题，8个皇后放在8*8棋盘，不能同行，同列，或者对角线 P200","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"剑指Offer37. 序列化，反序列化二叉树 P194","slug":"剑指offer37","date":"2019-11-01T07:26:23.000Z","updated":"2019-11-01T07:48:32.359Z","comments":true,"path":"2019/11/01/剑指offer37/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer37/","excerpt":"","text":"剑指offer37. 序列化，反序列化二叉树 P194（书上用的流操作）题目：请实现两个函数，分别用来序列化和反序列化二叉树。比如：下面这颗树的先序序列化是： 1 2 $ $ 3 $ $ ($表示空节点) 123 1 / \\2 3 // 序列化二叉树 ，用队列模拟流操作 123456789void serilize(BinaryTreeNode *root, queue &lt;char&gt; &amp;q) &#123; if (root == NULL) &#123; q.push('$'); return; &#125; q.push(root -&gt; m_nValue ); serilize(root -&gt; m_pLeft, ans); serilize(root -&gt; m_pRight, ans);&#125; // 反序列化二叉树 ,根据序列q，还原二叉树 123456789101112131415void reverseSerilize(BinaryTree **root, queue&lt;char&gt; &amp;q) &#123; if (q.empty()) return; if (q.fornt() == '$') &#123;//当前节点是空，无操作，因为下面在创建节点时左右节点默认空 q.pop(); return; &#125; *root = new BinaryTreeNode(); (*root) -&gt; m_nValue = q.front(); q.pop(); (*root) -&gt; m_pLeft = NULL; (*root) -&gt; m_pRight = NULL; reverseSerilize(&amp;((*root) -&gt; m_pLeft), q); reverseSerilize(&amp;((*root) -&gt; m_pRight), q);&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer36. 二叉搜索树BST转换成双向链表 P191","slug":"剑指offer36","date":"2019-11-01T07:26:19.000Z","updated":"2019-11-01T07:45:33.379Z","comments":true,"path":"2019/11/01/剑指offer36/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer36/","excerpt":"","text":"剑指offer36. 二叉搜索树BST转换成双向链表 P191题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 首先，牵扯到排序，就只能对BST中序遍历（这也是下面递归函数的模板）。另外，双向链表有左右两个指针，二叉树刚好左右两指针，通过对比显然可以用二叉树的left指针充当链表前驱指针，right指针充当后继指针。至于为什么要在递归函数中多一个lastnode，是因为一次指针变更操作，（除了涉及空节点的）操作节点一定是两个（一个指针指向另一个节点），所以需要给当前递归的操作节点显式地指明它的前驱或者后继。 // 主调函数 12345678910111213BinaryTreeNode *convert(BinaryTreeNode *proot) &#123; if (proot == NULL) return NULL; BinaryTreeNode *lastNode = NULL; // 前驱节点，最左叶节点前驱是NULL preOrderConvert(proot, &amp;lastNode); // 递归转换// 最后递归结束，lastnode指向的是链表的最右节点，但是应该返回最左的头结点//书上多一个判lastnode空，因为在书上函数开始没有判空 while (lastNode -&gt; m_pLeft != NULL) &#123; lastNode = lastNode -&gt; m_pLeft; &#125; return lastNode; // 返回双向链表左头节点&#125; // 递归转换，传入当前节点和当前节点前驱节点（实际上就是中序遍历模板） 123456789101112131415void preOrderConvert(BinaryTreeNode *root, BinaryTreeNode **lastNode) &#123; if (root == NULL) return; // 递归出口 if (root -&gt; m_pLeft != NULL) // 左递归 preOrderConvert(root -&gt; m_pLeft, lastNode); root -&gt; m_pLeft = *lastNode; // 当前节点前驱指针指向前驱节点 if ((*lastNode) != NULL) &#123; // 前驱节点不是空，前驱的后继节点指向当前节点 (*lastNode) -&gt; m_pRight = root; // 只有root是最左叶节点才不执行，没有前驱 &#125; (*lastNode) = root; // 更新前驱节点 if (root -&gt; m_pRight != NULL) // 右递归 preOrderConvert(root -&gt; m_pRight, lastNode); &#125; // 思考：把双向链表转换成BST ？","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer35. 复杂链表的复制 P187","slug":"剑指offer35","date":"2019-11-01T07:26:16.000Z","updated":"2019-11-01T07:42:28.632Z","comments":true,"path":"2019/11/01/剑指offer35/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer35/","excerpt":"","text":"剑指offer35. 复杂链表的复制P187题目：请实现函数ComplexListNode* Clone(ComplexListNode* pHead)，复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指向下一个结点外，还有一个m_pSibling 指向链表中的任意结点或者nullptr。 方法1： 空间方法是用hash表存（N，N^）的映射方法2： 时间方法分三步： 1 把复制后的节点N^接到N后边 2 设置每个N^的slibing指针 3. 将N和N^分开保存为原始链表和copy后的链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void cloneNodes(ComplexListNode *head) &#123; // 第一步：复制后的节点N^接到N后边 ComplexListNode *p = head; while (p != NULL) &#123; ComplexListNode *temp = new ComplexListNode(); temp -&gt; m_nValue = p -&gt; m_nValue; temp -&gt; m_pNext = p -&gt; m_pNext; p -&gt; m_pNext = temp; p = temp -&gt; m_pNext; &#125;&#125; void connectSiblingNodes(ComplexListNode *head) &#123; // 第二步：设置每个N^的slibing ComplexListNode *p = head; while (p != NULL) &#123; ComplexListNode *temp = p -&gt; m_pNext; if (p -&gt; m_pSibling != NULL) &#123; temp -&gt; m_pSibling = p -&gt; m_pSibling -&gt; m_pNext; &#125; else temp -&gt; m_pSibling = NULL; // 可以不写，m_pSibling默认的是null p = temp -&gt; m_pNext; &#125;&#125;ComplexListNode *reconnectNodes(ComplexListNode *head)&#123; // 第三步，拆分两个链表 ComplexListNode *newHead = head -&gt; m_pNext; // copy链表头 ComplexListNode *p = head, *cp = newHead; while (cp -&gt; m_pNext != NULL) &#123; p -&gt; m_pNext = cp -&gt; m_pNext; cp -&gt; m_pNext = cp -&gt; m_pNext -&gt; m_pNext; p = p -&gt; m_pNext; cp = cp -&gt; m_pNext; &#125; p -&gt; m_pNext = cp -&gt;m_pNext = NULL; return newHead;&#125;ComplexListNode* Clone(ComplexListNode* pHead) // 依次调用三个函数&#123; if (pHead == NULL) return NULL; cloneNodes(pHead); connectSiblingNodes(pHead); return reconnectNodes(pHead);&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer34. 二叉树路径和 P182","slug":"剑指offer34","date":"2019-11-01T07:26:13.000Z","updated":"2019-11-01T07:38:46.785Z","comments":true,"path":"2019/11/01/剑指offer34/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer34/","excerpt":"","text":"剑指offer34. 二叉树路径和 P182题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 // 主递归函数参数: 当前节点 上一步路径和 期待值 路径存储数组 123456789101112131415161718void DFS_FindPath(BinaryTreeNode *root, int sum, int k, vector&lt;int&gt; &amp;path) &#123; if (root == NULL || root -&gt; m_nValue + sum &gt; k) return ; // 当前路径和大于k，返回 path.push_back(root -&gt; m_nValue); // 否则，把节点加入path if (root -&gt; m_nValue + sum &lt; k) &#123; // 小于k，递归往下找， // 递归放在打印前就不用显示判断叶节点 DFS_FindPath(root -&gt; m_pLeft, sum + root -&gt; m_nValue, k, path); DFS_FindPath(root -&gt; m_pRight, sum + root -&gt; m_nValue, k, path); &#125;else &#123; // 等于k，打印路径path for (auto p : path) &#123; printf(\"%d \", p); &#125; printf(\"\\n\"); &#125; path.pop_back(); // 回溯，把当前节点移除，继续找&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer33. 二叉搜索树的后序遍历序列 P179","slug":"剑指offer33","date":"2019-11-01T07:26:09.000Z","updated":"2019-11-01T07:36:08.600Z","comments":true,"path":"2019/11/01/剑指offer33/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer33/","excerpt":"","text":"剑指offer33. 二叉搜索树的后序遍历序列 P179题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。 首先要明确的是：每一个子序列的最后一个数是根结点（end标识） 找到左子树子序列，左子树子序列可以通过从当前子序列开始索引start向后扫描，直到出现比根结点大的元素就停止（因为左子树子序列都是小于根节点的）； 剩下的子序列是右子树子序列（不包含子序列最后节点end也就是根节点），检查右子树子序列中所有元素是否都大于根结点元素，如果存在小于根节点的元素，则不满足二叉搜索树的定义，返回false. 递归地判断左子树和右子树是否是二叉搜索树。 1234567891011121314151617181920bool isBSTPostOrder(int *num, int start, int end) &#123; // 原始输入序列，子序列的首尾索引 if (num == NULL) return false; // 鲁棒性 （如果有主调函数可以放在主调里） if (start &gt;= end) return true; // 没有发现异常，两个成功相遇 int root = num[end]; // 根节点是最后一个节点 int i = start; // 开始索引 for (; i &lt; end; ++i) &#123; // 从开始索引找第一个比根大的节点，注意条件不能=end if (num[i] &gt; root) break; &#125; // 此时i存的是第一个比根大的节点的索引 for (int j = i + 1; j &lt; end ; ++j) &#123; // 从下一个位置出发，看右子树有没有比根小的 if (num[j] &lt; root) return false; &#125; // 递归左右子树看是否满足BST return (isBSTPostOrder(num, start, i - 1) &amp;&amp; isBSTPostOrder(num, i, end - 1)); &#125;// 注意：这个递归函数的end参数是子序列最后一个索引，调用的时候传的length - 1","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer32. 从上到下打印二叉树 P171（三种层次遍历的要求）","slug":"剑指offer32","date":"2019-11-01T07:26:06.000Z","updated":"2019-11-01T07:33:29.687Z","comments":true,"path":"2019/11/01/剑指offer32/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer32/","excerpt":"","text":"剑指offer32. 从上到下打印二叉树 P171（三种层次遍历的要求）1. 不分（换）行，从上到下打印二叉树 原始的层次遍历 123456789101112void PrintFromTopToBottom1(BinaryTreeNode *pRoot) &#123; // 不分行层次打印 if (pRoot == NULL) return; queue&lt;BinaryTreeNode* &gt; q; q.push(pRoot); while (!q.empty()) &#123; // 层次遍历 BinaryTreeNode *p = q.front(); q.pop(); printf(\"%d \", p -&gt; m_nValue); if (p -&gt; m_pLeft) q.push(p -&gt; m_pLeft); if (p -&gt; m_pRight) q.push(p -&gt; m_pRight); &#125;&#125; 2. 分行（层）打印二叉树 两个变量分别存当前行的节点个数，和下一行节点个数 12345678910111213141516171819202122232425void PrintFromTopToBottom2(BinaryTreeNode *pRoot) &#123; // 分行层次打印 if (pRoot == NULL) return; queue&lt;BinaryTreeNode* &gt; q; q.push(pRoot); int currentLayCount = 1, nextLayCount = 1; // 分别存当前行和下一行的节点数 while (!q.empty()) &#123; currentLayCount = nextLayCount; // 每一次打印一行时，更新两个变量 nextLayCount = 0; while (currentLayCount &gt; 0) &#123; // 打印当前行 BinaryTreeNode *p = q.front(); q.pop(); printf(\"%d \", p -&gt; m_nValue); if (p -&gt; m_pLeft) &#123; q.push(p -&gt; m_pLeft); nextLayCount++; &#125; if (p -&gt; m_pRight) &#123; q.push(p -&gt; m_pRight); nextLayCount++; &#125; --currentLayCount; &#125; printf(\"\\n\"); &#125; &#125; 3 .之字形打印二叉树 题目：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印 其他行以此类推。 用两个栈交替存当前行和下一行，偶数行的子节点从左往右入栈（保证下一行从右到左输出），奇数行的与之相反。 12345678910111213141516171819202122232425262728293031323334void PrintFromTopToBottom(BinaryTreeNode *pRoot) &#123; // 之字型打印二叉树 if (pRoot == NULL) return; stack&lt;BinaryTreeNode* &gt; s[2]; //两个辅助栈，0代表偶数行，（省去判奇偶的操作） int current = 0, next = 1; // 当前和下一行要访问的栈是s[0]还是s[1] s[0].push(pRoot); // 默认根节点是偶数行 while (!s[0].empty() || !s[1].empty()) &#123; BinaryTreeNode *node = s[current].top(); // 当前栈出栈 s[current].pop(); printf(\"%d \", node -&gt; m_nValue); if (current == 0) &#123; // 0栈是正向,从左到右入栈 if (node -&gt; m_pLeft) &#123; s[next].push(node -&gt; m_pLeft); &#125; if (node -&gt; m_pRight) &#123; s[next].push(node -&gt; m_pRight); &#125; &#125; else &#123; // 1栈是反向 从右到左入栈 if (node -&gt; m_pRight) &#123; s[next].push(node -&gt; m_pRight); &#125; if (node -&gt; m_pLeft) &#123; s[next].push(node -&gt; m_pLeft); &#125; &#125; if (s[current].empty()) &#123; // 一行打印结束，（写的真好） current = 1 - current; // 奇偶互换 next = 1 - next; printf(\"\\n\"); &#125; &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指offer31.栈的压入弹出序列 P168","slug":"剑指offer31","date":"2019-11-01T07:25:06.000Z","updated":"2019-11-01T07:28:15.096Z","comments":true,"path":"2019/11/01/剑指offer31/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer31/","excerpt":"","text":"剑指offer31. 栈的压入弹出序列 P168题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。 用辅助栈 s，nums是给定的弹出序列，inputs是压栈序列 如果栈不空，而且而且下一个弹出数字num恰好时栈顶数字，直接弹出 如果num和栈顶元素不等，把压栈序列inputs中num及num之前的数字压栈，如果在inputs这一轮的压栈中没有找到num，匹配失败。 最后两个序列都走到末尾，而且辅助栈空，匹配成功 换句话说：在弹出串中找到栈顶值之前，把没有访问过的输入串元素入栈，更新没有访问的元素头索引vis ，如果到最后都没有找到当前栈顶值，匹配失败 12345678910111213141516171819202122232425262728// 寻找并压栈bool findAndPush(stack&lt;int&gt; &amp;s, const int *input, const int *pattern, int &amp;vis, int len, int index) &#123; for (int i = vis + 1; i &lt; len; ++i) &#123; s.push(input[i]); if (input[i] == pattern[index]) &#123; vis = i; return true; &#125; &#125; return false;&#125; bool isPopOrder(const int *input, const int *pattern, int len) &#123; if (input == NULL || pattern == NULL || len &lt; 1) return false; int vis = -1; // 不能从0开始，因为find函数里从vis+1开始压栈 stack&lt;int&gt; s; findAndPush(s,input, pattern, vis, len, 0);//初始 for (int i = 0; i &lt; len;)&#123; int temp = pattern[i]; if (!s.empty() &amp;&amp; s.top() == temp) &#123; // 栈顶和当前值相等，比较下一个元素 s.pop(); ++i; &#125;else if ( !findAndPush(s, input, pattern, vis, len, i) ) &#123; return false; // 找不到匹配失败 &#125; &#125; return true; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"栈&队列","slug":"栈-队列","permalink":"http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"}]},{"title":"剑指Offer30. 包含Min函数的栈 P165","slug":"剑指offer30","date":"2019-11-01T06:34:35.000Z","updated":"2019-11-01T07:19:03.656Z","comments":true,"path":"2019/11/01/剑指offer30/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer30/","excerpt":"","text":"剑指offer30. 包含min函数的栈 P165题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。 构造一共辅助栈min，栈顶是当前数据栈data中的最小元素。 即：每次数据num入数据栈data时，把num和当前min栈顶元素tip比较，存入较小的那个到min栈（只把栈顶做比较，不要弹栈；假如栈顶小，再压入一个栈顶元素，否则，压入num） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869template &lt;typename T&gt; class StackWithMin&#123;public: StackWithMin() &#123;&#125; virtual ~StackWithMin() &#123;&#125; T&amp; top(); const T&amp; top() const; void push(const T&amp; value); void pop(); const T&amp; min() const; bool empty() const; size_t size() const;private: std::stack&lt;T&gt; m_data; // 数据栈，存放栈的所有元素 std::stack&lt;T&gt; m_min; // 辅助栈，存放栈的最小元素&#125;;template &lt;typename T&gt; void StackWithMin&lt;T&gt;::push(const T&amp; value)&#123; // 把新元素添加到辅助栈 m_data.push(value); // 当新元素比之前的最小元素小时，把新元素插入辅助栈里； // 否则把之前的最小元素重复插入辅助栈里 if(m_min.size() == 0 || value &lt; m_min.top()) m_min.push(value); else m_min.push(m_min.top());&#125;template &lt;typename T&gt; void StackWithMin&lt;T&gt;::pop()&#123;//assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行。 assert(m_data.size() &gt; 0 &amp;&amp; m_min.size() &gt; 0); m_data.pop(); m_min.pop();&#125;template &lt;typename T&gt; const T&amp; StackWithMin&lt;T&gt;::min() const&#123; assert(m_data.size() &gt; 0 &amp;&amp; m_min.size() &gt; 0); return m_min.top();&#125;template &lt;typename T&gt; T&amp; StackWithMin&lt;T&gt;::top()&#123; return m_data.top();&#125;template &lt;typename T&gt; const T&amp; StackWithMin&lt;T&gt;::top() const&#123; return m_data.top();&#125;template &lt;typename T&gt; bool StackWithMin&lt;T&gt;::empty() const&#123; return m_data.empty();&#125;template &lt;typename T&gt; size_t StackWithMin&lt;T&gt;::size() const&#123; return m_data.size();&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"栈&队列","slug":"栈-队列","permalink":"http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"}]},{"title":"剑指Offer29. 顺时针打印矩阵 P161","slug":"剑指offer29","date":"2019-11-01T06:34:29.000Z","updated":"2019-11-01T07:16:40.835Z","comments":true,"path":"2019/11/01/剑指offer29/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer29/","excerpt":"","text":"剑指offer29. 顺时针打印矩阵 P161题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。1 2 3 45 6 7 89 10 11 1213 14 15 16 打印： 1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10 当我们顺时针打印该矩阵时，每一圈的起始位置是左上角的元素，并且每一圈左上角元素都有一个共同点：它的行rows和列cols所对应的的下标都是相同的。因此不难想到，该矩阵打印结束的条件就是左上角的元素下标走到了该矩阵行和列的一半时，该矩阵打印结束了。因为矩阵也是用下标来确定某个数字的，所以这里就是：rows &gt; start * 2 &amp;&amp; cols &gt; start * 2 矩阵打印一圈需要四步（从左到右，从上到下，从右到左，从下到上），这个是一般情况，当矩阵是行大于列、列大于行的时候可能不需要四步，就可以打印结束 无论是一个怎样的矩阵，它都会进行第一步从左到右，并且如果打印一个矩阵它进行了第三步，那么一定走了一二步，也就是说后面的每一步是建立在前面步的基础之上的，总结一下打印每一圈：（1）从左往右：肯定有； （2）从上到下：矩阵行数至少为2，即：终止行号必须大于起始行号（这里不可以等于，否则会产生矩阵右上角的元素重复多打印一次）； （3）从右往左：矩阵至少为两行两列，即：终止列号必须大于起始列号，并且终止行号必须大于起始行号（同样，不可以等于，否则矩阵右下角的元素会多打印一次）； （4）从下到上：矩阵至少为三行两列，即：终止行号必须比起始行号大2，并且终止列号必须大于起始列号（同样，不可以等于，否则会出现左下角和右上角元素多打印一次） 1234567891011121314151617181920212223242526272829303132void print(int **number, int rows, int cols) &#123; if (number == NULL || rows &lt; 0 || cols &lt; 0) return ; if (rows == 0 &amp;&amp; cols == 0) return; int start = 0; // 对角线上的行列号 while (rows &gt; start * 2 &amp;&amp; cols &gt; start * 2) &#123; printMatrix(number, rows, cols, start); ++start; &#125;&#125;void printMatrix(int **a, int rows, int cols, int start) &#123; //顺时针打印一圈 int endx = rows - start - 1, endy = cols - start - 1; // 终止行号和列号 for (int i = start; i &lt;= endy; ++i) &#123; // 从左往右，直接打印 cout &lt;&lt; a[start][i] &lt;&lt; \" \"; &#125; if (endx &gt; start) &#123; // 从上到下：终止行号必须大于起始行号 for (int i = start + 1; i &lt;= endx; ++i) &#123; // 从start+1开始，不然重复打 cout &lt;&lt; a[i][endy] &lt;&lt; \" \"; &#125; &#125; if (endx &gt; start &amp;&amp; endy &gt; start) &#123; // 从右往左：终止列号必须大于起始列号，并且终止行号必须大于起始行号 for (int i = endy - 1; i &gt;= start; --i) &#123; cout &lt;&lt; a[endx][i] &lt;&lt; \" \"; &#125; &#125; if (endx - 1 &gt; start &amp;&amp; endy &gt; start) &#123; //从下到上：终止行号必须比起始行号大2，并且终止列号必须大于起始列号 for (int i = endx - 1; i &gt; start; --i) &#123; cout &lt;&lt; a[i][start] &lt;&lt; \" \"; &#125; &#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer28. 对称的二叉树 P159","slug":"剑指offer28","date":"2019-11-01T06:34:26.000Z","updated":"2019-11-01T07:12:39.756Z","comments":true,"path":"2019/11/01/剑指offer28/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer28/","excerpt":"","text":"剑指offer28. 对称的二叉树 P159题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的 12345678bool judge(BinaryTreeNode *proot1, BinaryTreeNode *proot2) &#123; if (proot1 == NULL &amp;&amp; proot2 == NULL) return true; if (proot1 == NULL || proot2 == NULL) return false; if (proot1 -&gt; key != proot2 -&gt; key) return false; // 注意下面，1的左子树和2的右子树比较，不要惯性思维搞错！ return judge(proot1 -&gt; left, proot2 -&gt; right) &amp;&amp; judge(proot1 -&gt; right, proot2 -&gt; left);&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指offer27.二叉树的镜像 P157","slug":"剑指offer27","date":"2019-11-01T06:34:20.000Z","updated":"2019-11-01T07:10:28.531Z","comments":true,"path":"2019/11/01/剑指offer27/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer27/","excerpt":"","text":"剑指offer27.二叉树的镜像 P157题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。 // 其实就是先根遍历的模板，在左右子树递归访问前交换左右子树 123456789101112131415void MirrorRecursively(BinaryTreeNode *pNode) &#123; if (pNode == NULL) return; // 两个递归出口 if (pNode -&gt; left == NULL &amp;&amp; pNode -&gt; right == NULL) return ; BinaryTreeNode *temp = pNode -&gt; left; // 交换左右子树（先根遍历是访问节点） pNode -&gt; left = pNode -&gt; right; pNode -&gt; right = temp; if (pNode -&gt; left) // 左递归 MirrorRecursively(pNode -&gt; left); if (pNode -&gt; right) // 右递归 MirrorRecursively(pNode -&gt; right);&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指offer26.树的子结构（一棵二叉树b是不是被二叉树a包含）P148","slug":"剑指offer26","date":"2019-11-01T06:34:13.000Z","updated":"2019-11-01T07:08:20.931Z","comments":true,"path":"2019/11/01/剑指offer26/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer26/","excerpt":"","text":"剑指offer26. 树的子结构（一棵二叉树b是不是被二叉树a包含）P148题目：输入两棵二叉树A和B，判断B是不是A的子结构。 递归结束条件：如果rootp为空，说明对比的子树已经找完了，此时不管root是不是空，都可以返回true（主调函数提前判断了rootp一开始就为空的情况），如果在rootp不为空的情况下root为空，说明这里肯定不对，因为子树还没有对比完，母树已经没了，返回false; 逻辑判断：如果root.val==rootp.val,那么此时有两种情况: 这个root节点是子结构的一部分，我们要判断roop的左右子树是不是也分别包含在root的左右子树中（这里用的是&amp;&amp;，因为要同时满足）： HasSubtree(root -&gt; m_pLeft, rootp -&gt; m_pLeft)&amp;&amp; HasSubtree(root -&gt; m_pRight, rootp -&gt; m_pRight 如果不包含这个节点（虽然两个根节点一样，但是在后面的递归过程出现两个结构不等的情况），我们就不能取这个root，所以要看root的左右子树是不是存在包含子结构的 （这里用的是||，因为不管左右子树哪个包含，只要出现就行）HasSubtree(root -&gt; m_pLeft, rootp)|| HasSubtree(root -&gt; m_pRight, rootp); 两种情况一种成立就可以，所以中间用||连接 （这里会容易忽略第二种情况） 回到开始，如果root.val != rootp.val,也就是进入那个else判断，这时就和上面的情况2一样了，直接返回左右子树和rootp比较的结果： 12 HasSubtree(root -&gt; m_pLeft, rootp)|| HasSubtree(root -&gt; m_pRight, rootp); 12345678910111213141516171819// ---------------主递归函数---------------------------------bool HasSubtree(BinaryTreeNode *root, BinaryTreeNode *rootp) &#123; if (rootp == NULL) return true; if (root == NULL) return false; if (equal(root -&gt; m_dbValue, rootp -&gt; m_dbValue)) &#123; // 比较浮点数 return (HasSubtree(root -&gt; m_pLeft, rootp -&gt; m_pLeft) // 情况1 &amp;&amp; HasSubtree(root -&gt; m_pRight, rootp -&gt; m_pRight)) || HasSubtree(root -&gt; m_pLeft, rootp) // 情况2 || HasSubtree(root -&gt; m_pRight, rootp); &#125; else &#123; return HasSubtree(root -&gt; m_pLeft, rootp) // 情况2 || HasSubtree(root -&gt; m_pRight, rootp); &#125;&#125;bool has(BinaryTreeNode *root, BinaryTreeNode *rootp) &#123; // 主调函数，root是母树 if (rootp == NULL || root == NULL) return false; //默认两棵树任一个是空，返回false return HasSubtree(root, rootp); // 递归判断 &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指offer25.合并两个排序的链表 P145","slug":"剑指offer25","date":"2019-11-01T06:34:10.000Z","updated":"2019-11-01T06:57:35.852Z","comments":true,"path":"2019/11/01/剑指offer25/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer25/","excerpt":"","text":"剑指offer25. 合并两个排序的链表 P145每次比较两个链表表头，那个小，哪个就是当前节点mergeHead，然后把剩下的链表继续合并，找这个mergeHead的下一个节点。 12345678910111213141516171819ListNode* mergeSortedLinkedList(ListNode *head1, ListNode *head2) &#123; // 任一个链表比较完，把剩下的直接加到当前合并的链表尾if (head1 == NULL) return head2; if (head2 == NULL) return head1; ListNode *mergeHead = NULL; // 每次选出来两个链表头里最小的作为上一个节点的next if (head1 -&gt; key &lt; head2 -&gt; key) &#123; mergeNode = head1; mergeNode -&gt; next = mergeSortedLinkedList(head1 -&gt; next, head2); &#125; else &#123; mergeNode = head2; mergeNode -&gt; next = mergeSortedLinkedList(head1, head2 -&gt; next); &#125; return mergeNode; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer24. 反转链表 P142","slug":"剑指offer24","date":"2019-11-01T06:34:06.000Z","updated":"2019-11-01T06:55:13.329Z","comments":true,"path":"2019/11/01/剑指offer24/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer24/","excerpt":"","text":"剑指offer24. 反转链表 p142题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 1234567891011121314ListNode *ReverseList(ListNode *pHeadList) &#123; if (pHeadList == NULL) return NULL; ListNode *preNode = NULL; // 前驱节点 ListNode *pNode = pHeadList; // 工作节点 while (pNode != NULL) &#123; ListNode *nextNode = pNode -&gt; m_pNext; pNode -&gt; m_pNext = preNode; preNode = pNode; pNode = nextNode; &#125; return preNode; // 前驱就是头结点&#125; 递归解法见p145 页","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指offer23.链表是否有环，找出环的入口 P139","slug":"剑指offer23","date":"2019-11-01T06:34:02.000Z","updated":"2019-11-01T06:53:23.433Z","comments":true,"path":"2019/11/01/剑指offer23/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer23/","excerpt":"","text":"剑指offer23. 链表是否有环，找出环的入口 P139和书上不太一样，这里用的弗洛伊德龟兔算法Fast指针 比 slow 每次多走一步，相遇之后，fast从头开始一次走一步，slow从当前开始每次走一步，两者再相遇点就是入口。 123456789101112131415161718192021ListNode *EntryNodeOfLoop(ListNode *pHeadList) &#123; if (pHeadList == NULL || pHeadList -&gt; m_pNext == NULL) return NULL; ListNode *slow = pHeadList -&gt; m_pNext , *fast = slow -&gt; m_pNext; while (fast != NULL &amp;&amp; slow != NULL) &#123; if (fast == slow) break; // 第一次相遇 if (fast -&gt; m_pNext == NULL) return NULL; // 没有环 else &#123; fast = fast -&gt; m_pNext -&gt; m_pNext; // 前进 slow = slow -&gt; m_pNext; &#125; &#125; if (fast != slow || fast == NULL) return NULL; // 没有环 fast = pHeadList; // fast从头走 while (fast != slow) &#123; // 再一次相遇，相遇点就是入口 fast = fast -&gt; m_pNext; slow = slow -&gt; m_pNext; &#125; return fast;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指offer22.链表中的倒数第k个节点 P134","slug":"剑指offer22","date":"2019-11-01T06:33:59.000Z","updated":"2019-11-01T06:49:29.285Z","comments":true,"path":"2019/11/01/剑指offer22/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer22/","excerpt":"","text":"剑指offer22. 链表中的倒数第k个节点 P134题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。 // 本题主要是鲁棒性检测 两个if条件的内容。第二个if不能用p!=NULL 是因为，p定义指的是最后一共节点，如果最后p是NULL(最后一共节点的下一个节点)了，就失去意义了。 123456789101112131415ListNode *findK(ListNode *head, int k) &#123; if (head == NULL || k &lt; 1) return 0; ListNode *p = head; // 指向倒数第一个节点 for (int i = 0; i &lt; k- 1; ++i) &#123; if (p -&gt; m_pNext != NULL) p = p -&gt; m_pNext; // 节点总数小于k else return NULL; &#125; ListNode *q = head; // 倒数第k个节点 while (p -&gt; m_pNext != NULL) &#123; p = p -&gt; m_pNext; q = q -&gt; m_pNext; &#125; return q; &#125; 扩展：求链表的中间节点：如果链表节点数是奇数，返回中间节点，否则返回中间两个节点任一个。 定义一个快指针一次走两步，一个慢指针一次走一步。快指针走到末尾慢指针指的就是答案 1234567891011ListNode *find_mid(ListNode *head)&#123; if(head == NULL) return NULL; ListNode *slow, *fast; slow = fast = head; /*快慢指针都指向第一个节点*/ while (fast != NULL &amp;&amp; fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) &#123; slow = slow-&gt;next; /*慢指针每次走一步*/ fast = fast-&gt;next-&gt;next; /*快指针每次走两步*/ &#125; return slow;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer21. 调整数组顺序使奇数位于偶数前面 P129","slug":"剑指offer21","date":"2019-11-01T06:33:53.000Z","updated":"2019-11-01T06:42:07.846Z","comments":true,"path":"2019/11/01/剑指offer21/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer21/","excerpt":"","text":"剑指offer21. 调整数组顺序使奇数位于偶数前面 P129题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 两点法，左右同时走指针，交换左边找的偶数和右边找到的奇数 1234567891011121314151617void ReorderOddEven(int *nums, unsigned int length) &#123; if (nums == NULL || length &lt; 1) return ; int even = 0, odd = length - 1; while (even &lt; odd) &#123; // 不能 = while (even &lt; odd &amp;&amp; (nums[even] &amp; 1) != 0) ++even; // 找偶数 while (even &lt; odd &amp;&amp; (nums[odd] &amp; 1) == 0) --odd; // 找奇数 if (even &lt; odd) &#123; // 交换位置 int temp = nums[odd]; nums[odd] = nums[even]; nums[even] = temp; &#125; &#125;&#125; 可扩展的解法：如果把奇数偶数换成正负，能不能被3整除。。。等只需要修改大循环里的两个while的判断条件，那么就可以把判断条件解耦出来，传入独立的函数判断。 函数声明变成：void ReorderOddEven( int *nums, unsigned int length, bool (*func)(int) ) 两个判断条件分别变成： while (even &lt; odd &amp;&amp; !isEven(nums[even])) while (even &lt; odd &amp;&amp; isEven(nums[odd])) 单独定义判断函数：(根据不同要求定义不同的判断条件) bool isEven(int n) { 是不是偶数 return (n&amp;1) == 0; } 顶层调用： reorderOddEven(nums, length, isEven)","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer20. 表示数值的字符串P127","slug":"剑指offer20","date":"2019-10-31T06:55:08.000Z","updated":"2019-11-01T08:49:39.504Z","comments":true,"path":"2019/10/31/剑指offer20/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer20/","excerpt":"","text":"剑指offer20 . 表示数值的字符串P127题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”、“5e2”、“-123”、“3.1416”及“-1E-16”都是，但“12e”、“1a3.14”、“1.2.3、“+-5”及“12e+5.4不是（这个题的描述相当不清楚，很多有悖常理的数字格式也是对的，leetcode上很多人吐槽） 1.用自动机做（很low，但是就这题而言我觉得好理解，） https://blog.csdn.net/qq_43778308/article/details/102838980 上图只是为了说明自动机处理的原理，下面代码不是按照上面这个图写的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859bool isNumber(const char * str) &#123; if (str == NULL) return false; int state=1; // 初始状态 for(int i = 0; i &lt; strlen(str); ++i)&#123; char c = str[i]; switch (state)&#123; case 1: if(c==' ') state=1; else if(c=='+'||c=='-') state=2; else if(isdigit(c)) state=3; else if(c=='.') state=4; else return false; break; case 2: if(isdigit(c)) state=3; else if(c=='.') state=4; else return false; break; case 3: if(isdigit(c)) state=3; else if(c=='e'||c=='E') state=6; else if(c=='.') state=5; else if(c==' ') state=9; else return false; break; case 4: if(isdigit(c)) state=5; else return false; break; case 5: if(isdigit(c)) state=5; else if(c=='e'||c=='E') state=6; else if(c==' ') state=9; else return false; break; case 6: if(c=='+'||c=='-') state=7; else if(isdigit(c)) state=8; else return false; break; case 7: if(isdigit(c)) state=8; else return false; break; case 8: if(isdigit(c)) state=8; else if(c==' ') state=9; else return false; break; case 9: if(c==' ') state=9; else return false; break; &#125; &#125; return state==3||state==5||state==8||state==9; // 一共有4个正确的结束状态 &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"正则匹配","slug":"正则匹配","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"},{"name":"自动机","slug":"自动机","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"剑指Offer19. 正则表达式匹配 P124","slug":"剑指offer19","date":"2019-10-31T06:55:02.000Z","updated":"2019-11-01T08:49:28.433Z","comments":true,"path":"2019/10/31/剑指offer19/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer19/","excerpt":"","text":"剑指offer19. 正则表达式匹配 P124题目：请实现一个函数用来匹配包含’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”及”ab*a”均不匹配。 因为 * 的存在让整个题目复杂，那我们把下一个字符是不是*作为划分依据。 Case 1. 当模式中的第二个字符不是“*”时：1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。2、如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 Case 2 . 当模式中的第二个字符是“*”时：可以有3种匹配方式：1、模式后移2字符，相当于x*被忽略；比如 str : ab , pattern : b*ab2、字符串后移1字符，模式后移2字符，x*相当于只匹配一个字符；ab 和 a*b3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为可以匹配多位；aab 和a\\b 12345678910111213141516171819202122232425bool isMatchedCore(const char *str, const char *pattern) &#123; // 匹配递归函数 if (*str == '\\0' &amp;&amp; *pattern == '\\0') return true; // 两个递归出口 if (*str != '\\0' &amp;&amp; *pattern == '\\0') return false; if (*(pattern + 1) == '*') &#123; // case 2情况 if ((*str == *pattern)|| (*pattern == '.' &amp;&amp; *str != '\\0')) &#123; // 当前字符匹配成功，相当于又重新进入case 2的情况，有三种选择 return isMatchedCore(str + 1, pattern) || isMatchedCore(str + 1, pattern + 2) || isMatchedCore(str, pattern + 2); &#125;else &#123; // 当前匹配失败那么*就没有作用了，跳过下一个*,只能是case 2.1的情况 return isMatchedCore(str, pattern + 2); &#125; &#125;else &#123; // case1情况下一个不是* if ((*str == *pattern)|| (*pattern == '.' &amp;&amp; *str != '\\0')) // case1.1 return isMatchedCore(str + 1, pattern + 1); else // case 1.2 return false; &#125;&#125;bool isMatched(const char *str, const char *pattern) &#123; // 匹配函数if (str == NULL &amp;&amp; pattern == NULL) return true; if (pattern == NULL) return false; return isMatchedCore(str, pattern); &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"正则匹配","slug":"正则匹配","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"}]},{"title":"剑指offer18．在O(1)时间内删除链表节点 P119","slug":"剑指offer18","date":"2019-10-31T06:54:59.000Z","updated":"2019-11-01T08:49:19.192Z","comments":true,"path":"2019/10/31/剑指offer18/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer18/","excerpt":"","text":"剑指offer18． 在O(1)时间内删除链表节点 P119题目：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。 /* 既然要在O（1）时间内删除，就不需要遍历，或者说大多数情况下不需要遍历整个链表，那么在O(1) 时间内我们能得到哪些东西呢？ 1.首先头指针和头指针下一个节点显然没有什么用，再者就是2. 需要删除的节点p和他的下一个节点next， 那么肯定是围绕着p和next操作。如果要删除应该链表节点，通常要找到它的前驱，这一道题能够构成这种前后关系的就是删除next，它的前驱是p，于是我们把next的东西复制给p，再删除next就ok了。以上是普通情况当p是头结点时候，要特判，p是尾节点时候，只能够遍历整个链表了此外，因为o（1）时间的限制，我们不能确保链表中有p，这只能交给函数调用者处理了 1234567891011121314151617181920212223242526272829void deleteNode(ListNode **pHeadList, ListNode *pToDeleteNode) &#123; if (!(*pHeadList) || !pToDeleteNode) return; if (*pHeadList == pToDeleteNode) &#123; // 删头节点 ListNode *temp = *pHeadList; if (temp -&gt; next == NULL) &#123; // 链表只有一个节点 *pHeadList = NULL; delete temp; &#125; else &#123; // 链表有其他节点 *pHeadList = (*pHeadList) -&gt; next;// 不要使用delete (*pHeadList)，在没有被分配之前里面的内容还是完好的。// 而且delete不负责将指针设置为NULL。 delete temp; temp = NULL; &#125; &#125; else if (pToDeleteNode -&gt; next != NULL) &#123; // 在中间删除，把next值给当前节点， // 并且删除next ListNode *temp = pToDeleteNode -&gt; next; pToDeleteNode -&gt; key = pToDeleteNode -&gt; next -&gt;key; pToDeleteNode -&gt; next = pToDeleteNode -&gt; next -&gt; next; delete temp; temp = NULL; &#125; else if (pToDeleteNode -&gt; next == NULL) &#123; // 删除尾节点，必须遍历 ListNode *p = *pHeadList; while (p -&gt; next != pToDeleteNode) p = p -&gt; next; p -&gt; next = NULL; delete pToDeleteNode; pToDeleteNode = NULL; &#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer17. 打印从1到最大的n位数 P114","slug":"剑指offer17","date":"2019-10-31T06:54:53.000Z","updated":"2019-11-01T08:49:08.504Z","comments":true,"path":"2019/10/31/剑指offer17/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer17/","excerpt":"","text":"剑指offer17. 打印从1到最大的n位数 P114题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。 1. 方法一： 用字符数组str倒着存储大数。每次大数自增1，如果溢出，表明打印完 12345678910111213141516171819202122232425262728293031// 此函数完成大数自增1的功能，并返回是否已经“溢出”（长度满足题目要求）bool Increment(char *str, int current_length) &#123; int carry = 0; // 进位 bool overflow = false; // 溢出标志 for (int i = current_length - 1; i &gt;=0; --i) &#123; // 加1后大数从后往前每一位进行更新 int num = str[i] - '0' + carry; //不能再上面直接+1，因为这个for后面都是为了处理第一次的进位的 if (i == current_length - 1) num++; // 只有最低位+1 if (num &gt;= 10) &#123; // 有进位 if (i == 0) &#123; // 有进位，而且是最高位i=0产生的，溢出 overflow = true; // 调用函数也退出循环 break; // 退出 &#125; str[i] = num - 10 + '0'; // 否则，处理进位 carry = 1; &#125; else &#123; str[i] = num + '0'; //这后面不用加carry=0 break; // 因为后面的循环时为了处理进位，没有进位就直接退出了 &#125; &#125; return overflow; //返回溢出标志&#125;void print1ToMaxOfNDigits(int n) &#123; // 调用函数，打印1 -- n位最大数 if (n &lt; 1) return; char *str = new char[n + 1]; memset(str, '0',sizeof(str)); str[n] = '\\0'; while (!Increment(str, n)) // 自增后，判断是否溢出， print(str, n); // 没有溢出，打印&#125; 2. 方法二，递归全排列 如果我们在数字前面补0，就会发现n位所有十进制数其实就是n个从0到9数字的全排列。也就是说，我们把数字的每一位都从0到9遍历一遍，就得到了所有的十进制数。只是在打印的时候，排在前面的0不打印出来罢了。全排列用递归表达，数字的每一位都可能是0~9中的一个数，然后设置下一位。递归结束的条件是我们设置了的数字的最后一位。 12345678910111213141516171819202122232425262728293031323334353637void print1ToMaxOfNDigits2(int len) &#123; if (len &lt; 1) return ; char *nums = new char[len]; // 不用len+1 for (int i = 0; i &lt; len; ++i) nums[i] = '0'; for (int i = 0; i &lt;= 9; ++i)&#123; // 从第0位开始设置，取0-9调用递归 nums[0] = i + '0'; printCore(nums,len,0); &#125; delete[] nums;&#125; void printCore(char *nums, int len, int index) &#123;// 求排列，index是当前设置的第index位 if (index == len - 1 ) &#123; // 递归出口，设置完最后一位 print(nums, len); // 打印 return; &#125; for (int i = 0 ; i &lt;= 9; ++i) &#123; // 递归当前第index后面的若干位 nums[index + 1] = i + '0'; printCore(nums, len, index + 1); &#125; &#125;// 把符合条件的一个数打印出来，注意题干，从1开始打印！void print(char *str, int len) &#123; int i = 0; while (str[i] == '0') ++i; //剔除前导0 if (i != len) &#123; while (i &lt; len) &#123; printf(\"%c\", str[i]); ++i; &#125; printf(\"\\n\"); &#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"剑指Offer16. 数值的整数次方 P110","slug":"剑指offer16","date":"2019-10-31T06:54:49.000Z","updated":"2019-11-01T08:48:57.101Z","comments":true,"path":"2019/10/31/剑指offer16/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer16/","excerpt":"","text":"剑指offer16. 数值的整数次方P110题目：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 1234567891011121314151617181920212223242526272829303132333435const double esp = 1e-6; bool isValid = false; // power函数返回0时，判断合不合法，true时不合法double powerWithUnsignedExponent(double base, int exponent) &#123; // 此输入保证指数非负 if (exponent == 0) return 1; if (exponent == 1) return base; // 指数除以2递归 double ans = powerWithUnsignedExponent(base, exponent &gt;&gt; 1); ans *= ans; // 先在上一步递归里算出来a的（n/2）次方， 再平方 if ((exponent &amp; 1)) &#123; // 如果指数是奇数还要再乘以base （规律见p112） ans *= base; &#125; return ans;&#125;double power(double base, int exponent) &#123; isValid = false; // 这是全局变量，不能省 ，默认合法 if (fabs(base - 0.0) &lt;= esp &amp;&amp; exponent &lt; 0) &#123; isValid = true; // 不合法 的0.0 return 0.0; &#125; if (exponent == 0) return 1.0; if (base == 0) &#123; return 0.0; // 合法的0.0 &#125; //先把指数按正数处理 int temp = exponent &lt; 0 ? -exponent : exponent; double ans = powerWithUnsignedExponent(base, temp); // 如果指数是负数，结果取倒数 if (exponent &lt; 0) ans = 1 / ans; return ans; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"剑指Offer15. 二进制中1的个数 P100","slug":"剑指offer15","date":"2019-10-31T06:54:44.000Z","updated":"2019-11-01T08:48:43.860Z","comments":true,"path":"2019/10/31/剑指offer15/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer15/","excerpt":"","text":"剑指offer15. 二进制中1的个数 P10012345678910111213141516171819int countNumbersOfOne(int a) &#123; int count = 0; unsigned int flag = 1; while (flag) &#123; if ((a &amp; flag)) ++count; flag = flag &lt;&lt; 1; //常规方法 让1从右往左分别与a的每一位与 // 不能右移a，因为 0x80000000时死循环 &#125; return count;&#125;int countNumbersOfOne2(int a) &#123; int count = 0; while (a) &#123; a &amp;= a - 1; // a&amp;a-1之后会刚好相当于a的二进制去掉一个最后一个1， ++count; // 统计它循环次数就知道几个1了 &#125; return count;&#125; 扩展：1 一条语句判断整数是不是2的整数次方2 两个整数m,n 求m要改变多少二进制位才能变成n 1 （二进制中只有一个1） 2 （1）先异或^（2）统计结果中1的个数","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"剑指Offer14. 剪绳子 P96","slug":"剑指offer14","date":"2019-10-31T06:54:39.000Z","updated":"2019-11-01T08:48:30.168Z","comments":true,"path":"2019/10/31/剑指offer14/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer14/","excerpt":"","text":"剑指offer14 . 剪绳子 P96题目：给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1]…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。 动态规划， 令 f(n) 是长度n最后的最大乘积，剪在整数上i上 ，显然f(n) = max( f(i) * f(n-i) ) i 从4到n，前3个要特判，因为当n等于1-3时，得到的乘积最大数和把前3个当作乘数因子（提供给后面4~n时的数当作f(i) 或者f(n-i)）不一样。 123456789101112131415161718192021222324int maxProduct(int length) &#123; if (length &lt; 2) return 0; // 要求length &gt; 1 if (length == 2) return 1; // 只能从i=1处剪 if (length == 3) return 2; // 同上 int *dp = new int[length + 1]; memset(dp, 0, sizeof(dp)); // dp在前三个存的并不是答案，只是为了充当dp[i] 或 dp[n-i]，所以才在上面特判 // 因为n是1到3时，还必须要剪一刀，但是充当乘法因子不一定要在它们中间剪 dp[1] = 1; //前三个代表长度为i的子绳最大能提供的乘法因子是多少 dp[2] = 2; dp[3] = 3; for (int i = 4; i &lt;= length; ++i) &#123; // i是绳长 for (int j = 1; j &lt;= i / 2; ++j) &#123; dp[i] = max(dp[i], dp[j] * dp[i - j]); //括号里的dp[i]存的是前几个j的dp[i]的最大值，跟当前比 &#125; &#125; int ans = dp[length]; delete [ ] dp; return ans; &#125; 贪心那个解法已然放弃。。。我这样的学术辣鸡不配使用贪心。","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指Offer13. 机器人的运动范围 P92","slug":"剑指offer13","date":"2019-10-31T06:54:30.000Z","updated":"2019-11-01T08:48:11.897Z","comments":true,"path":"2019/10/31/剑指offer13/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer13/","excerpt":"","text":"剑指offer13. 机器人的运动范围 P92题目：地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和 大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 12345678910111213141516171819202122232425262728293031323334353637// 判断当前访问的格子是不是有效// 参数：二维数组行，列总数，当前行，列索引，给定k值，访问标志bool isValid(int rows, int cols, int i, int j, int k, bool *visited) &#123; if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || visited[i * cols + j]) return false; // 边界条件不满足，访问访问过 int sum = 0; // i，j的各位和 while (i != 0) &#123; sum += i % 10; i /= 10; &#125; while (j != 0) &#123; sum += j % 10; j /= 10; &#125; if (sum &gt; k) return false; return true;&#125;int countS(int rows, int cols, int i, int j, int k, bool *visited) &#123; // 递归 int count = 0; if (isValid(rows, cols, i, j, k, visited)) &#123; //当前格满足条件 visited[i * cols + j] = true; count = 1 + countS(rows, cols, i - 1, j, k, visited) //不是count += + countS(rows, cols, i, j - 1, k, visited) + countS(rows, cols, i + 1, j, k, visited) + countS(rows, cols, i, j + 1, k, visited); &#125; return count;&#125;int movingCount( int k, int rows, int cols) &#123; if (k &lt; 0 || rows &lt; 1 || cols &lt; 1) return 0; bool *visited = new bool[rows * cols]; memset(visited, 0, rows * cols); int ans = countS(rows, cols, 0, 0, k, visited);//不用再两层for遍历了 delete []visited; return ans; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"剑指Offer12.  矩阵中匹配字符串 P89","slug":"剑指offer12","date":"2019-10-31T06:54:12.000Z","updated":"2019-11-01T08:48:00.597Z","comments":true,"path":"2019/10/31/剑指offer12/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer12/","excerpt":"","text":"剑指offer12. 矩阵中匹配字符串P89题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。A B T GC F C SJ D E H // 参数：原始数组，二维数组行，列，当前访问元素的行，列，// 目标字符串，访问标志，路径索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool isHavePath(const char *matrix, int rows, int cols, int i, int j, const char *str, bool *visited, int&amp; pathlength) &#123; if (str[pathlength] == '\\0') return true; // 匹配结束，返回true bool havepath = false; // 答案 // 当前访问元素的行列没有越界，没有访问过，值和目标字符串对应位置一样 if (i &gt;= 0 &amp;&amp; i &lt; rows &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; cols &amp;&amp; !visited[i * cols + j] &amp;&amp; matrix[i * cols + j] == str[pathlength]) &#123; visited[i * cols + j] = true; // 设置访问过 ++pathlength; // 注意：c++对于引用类型，不能传临时变量 // 也就是说，下面递归调用不能传pathlength+1 havepath = isHavePath(matrix, rows, cols, i - 1, j, str, visited, pathlength ) || isHavePath(matrix, rows, cols, i, j - 1, str, visited, pathlength ) || isHavePath(matrix, rows, cols, i + 1, j, str, visited, pathlength ) || isHavePath(matrix, rows, cols, i, j + 1, str, visited, pathlength ); if (!havepath) &#123; // 没有找到，回溯，把访问标记和路径索引回溯-1 visited[i * cols + j] = false; --pathlength; &#125; &#125; return havepath;&#125;bool hasPath(const char *matrix, int rows, int cols,const char *str) &#123; if (matrix == NULL || rows &lt;= 0 || cols &lt;= 0 || str == NULL) return false; bool *visited = new bool(rows * cols); // 访问标志初始化 memset(visited, 0, rows * cols); int path = 0; for (int i = 0; i &lt; rows; ++i) &#123; // 遍历二维数组每一个元素 for (int j = 0; j &lt; cols; ++j) &#123;**// path = 0; 这个可写可不写，因为如果匹配失败，在上面递归函数里，// path会回溯-1，直到减回0；匹配 成功直接返回了** if (isHavePath(matrix, rows, cols, i, j, str, visited, path)) // 递归 &#123; delete []visited; return true; &#125; &#125; &#125; delete []visited; return false; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"剑指Offer11．旋转数组的最小数字 P82","slug":"剑指offer11","date":"2019-10-31T06:42:37.000Z","updated":"2019-11-01T08:47:44.344Z","comments":true,"path":"2019/10/31/剑指offer11/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer11/","excerpt":"","text":"剑指offer11． 旋转数组的最小数字 P82题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。 看到有序两个字，要条件反射的想到二分。 这题应该注意的二分的划分依据是：中间值mid和子序列首尾大小比较（注意三者相等时的特殊情况），首先，i总是指向前面递增数组的元素，j总是指向后面递增数组的元素。如果i和j相差是1的话，那么索引i指向第一个递增数组的末尾，j指向后一个递增数组的开头。自然j指的就是答案了 123456789101112131415161718192021222324int Min(int *num, int length) &#123; if (num == NULL || length &lt; 1) throw (&quot;Invalid Input&quot;); if (length == 1 || num[0] &lt; num[length - 1]) return num[0]; // 递增 int i = 0, j = length -1, mid = 0; while (i &lt;= j ) &#123; mid = ((j - i) &gt;&gt; 1) + i; //三个指针值一样，不能二分，只有从头遍历 if (num[mid] == num[i] &amp;&amp; num[mid] ==num[j])&#123; for (int i = 1; i &lt; length; ++i) &#123; if (num[i] &lt; num[i - 1]) return num[i]; &#125; &#125;else if (num[mid] &gt;= num[i]) i = mid; //往右二分，不能从mid+1开始， // 因为如果mid此时刚好是答案，刚好错过正确的答案 else if (num[mid] &lt;= num[j]) j = mid; // 往左二分 ，同样必须从mid开始 if (j - i == 1 ) return num[j]; // i指向前一个递增数组结尾，j指向后一个开头 &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer（扩展）快排 P80","slug":"剑指offer扩展","date":"2019-10-31T06:14:48.000Z","updated":"2019-11-01T08:51:14.709Z","comments":true,"path":"2019/10/31/剑指offer扩展/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer%E6%89%A9%E5%B1%95/","excerpt":"","text":"剑指offer（扩展）快排 P801234567891011121314151617181920212223242526272829303132333435363738391. 快速排序 （递归实现）void quickSort(int nums[], int start, int end) &#123; if (nums == NULL || start &gt; end || start &lt; 0) return; int flag = nums[start], i = start, j = end; while (i &lt; j) &#123; while (nums[j] &gt;= flag &amp;&amp; i &lt; j) --j; // 一定是 先 从右往左找 nums[i] = nums[j]; while(nums[i] &lt;= flag &amp;&amp; i &lt; j) ++i; nums[j] = nums[i]; &#125; nums[i] = flag; // 确定当前基准值的位置 i quickSort(nums, start, i - 1); quickSort(nums, i + 1, end);&#125;2. 给公司员工年龄排序 P81void ageSort(int nums[], int len) &#123; if (nums == NULL || len &lt; 1) return; const int range_of_age_up = 100; // 年龄上界 const int range_of_age_down = 0; // 年龄下界 int *hash = new int[range_of_age_up + 1]; // hash表存对应年龄出现次数 memset(hash, 0, sizeof(hash) * (range_of_age_up + 1) ); // 注意长度！ for (int i = 0; i &lt; len; ++i) &#123; if (nums[i] &lt; range_of_age_down || nums[i] &gt; range_of_age_up) &#123; // 异常 throw \"sorry , out of range !\"; &#125; ++hash[nums[i]]; &#125; int index = 0; // 排序后的数组索引 for (int i = 0; i &lt;= range_of_age_up; ++i) // 统计每个年龄 i出现的次数hash[j] for (int j = 0; j &lt; hash[i]; ++j) // 那么连着hash[j]个元素就是年龄i nums[index++] = i; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"剑指Offer10. 高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题P74","slug":"剑指offer10","date":"2019-10-31T06:14:44.000Z","updated":"2019-11-01T08:47:32.404Z","comments":true,"path":"2019/10/31/剑指offer10/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer10/","excerpt":"","text":"剑指offer10 . 高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题p74123456789101112131415//优化后的斐波那契long long fb(int n) &#123; if (n &lt; 0) return -1; int table[2] = &#123;0, 1&#125;; if (n &lt; 2) return table[n]; long long pre1 = 1, pre2 = 0, fbn = 0; for (int i = 2; i &lt;= n; ++i) &#123; fbn = pre1 + pre2; pre2 = pre1; pre1 = fbn; &#125; return fbn;&#125; 青蛙跳台阶（只能跳1，2步） 设f(n)表示青蛙跳上n级台阶的跳法数。当只有一个台阶时，n = 1时， 只有1中跳法； n = 2时，有两种跳法；；当n很大时，青蛙在最后一步跳到第n级台阶时，有两种情况：一种是青蛙在第n-1个台阶跳一个台阶，那么青蛙完成前面n-1个台阶，就有f(n-1)种跳法，这是一个子问题。另一种是青蛙在第n-2个台阶跳两个台阶到第n个台阶，那么青蛙完成前面n-2个台阶，就有f(n-2)种情况，这又是另外一个子问题。两个子问题构成了最终问题的解，所以当n&gt;=3时，青蛙就有f(n)=f(n-1)+f(n-2)种跳法。 扩展 ：如果一次可以跳1，2，3…n 级的话 f(n) = 2的n-1次方证明： f(n) = f(n-1) + f(n-2) + f(n-3) …+f(n-n) 方程1 f(n-1) = f(n-2) + f(n-3) + f(n-4) …+f(n-n) 方程2 方程1-2得 ： f(n) – f(n-1) = f(n-1) f(n) = 2*f(n-1) = 2*2*f(n-2)=…2的n-1次方p79 页的矩阵覆盖也是同样的道理，不再赘述（注意n是初始几个值0，1，2的特判）","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指Offer9. 两个栈实现队列 P68","slug":"剑指offer9","date":"2019-10-31T06:14:40.000Z","updated":"2019-11-01T08:47:20.637Z","comments":true,"path":"2019/10/31/剑指offer9/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer9/","excerpt":"","text":"剑指offer9. 两个栈实现队列 p68题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 /*在stack1 中存入；从stack2里取，如果取得时候2是null，把1的值全压到2再取 */ 12345678910111213141516171819202122232425262728#include&lt;stdexcept&gt; template &lt;typename T&gt; class CQueue &#123; public: CQueue(void)&#123; &#125;; // 不能只写个名字 ~CQueue(void)&#123;&#125;; void appendTail(const T&amp; node) &#123; // node的值不能被改变 stack1.push(node); &#125; T deleteHead() &#123; if (stack2.empty()) &#123; while (!stack1.empty()) &#123; stack2.push(stack1.top()); stack1.pop(); &#125; &#125; if (stack2.empty()) &#123; // 说明没有插入数据 ，抛出，不会往下执行 std::logic_error ex(&quot;queue is null !&quot;); throw std::exception(ex); &#125; T t = stack2.top(); stack2.pop(); return t; &#125; private: std::stack&lt;T&gt; stack1; std::stack&lt;T&gt; stack2; &#125;; 扩展： 用两个队列模拟栈思想： 两个队列交替充当队列。比如 压栈c时：往非空的队列1插入c，1内容变成cba。弹栈时，需要的是c，但是队列1头是a，那么依此把队列1的内容插入队列2中，把最后一个元素c返回。这时队列2变成非空了，那么再压栈就往2里插入了。如此循环","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"栈&队列","slug":"栈-队列","permalink":"http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"}]},{"title":"剑指Offer8. 二叉树的下一个节点 P65","slug":"剑指offer8","date":"2019-10-31T06:14:35.000Z","updated":"2019-11-01T08:47:09.413Z","comments":true,"path":"2019/10/31/剑指offer8/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer8/","excerpt":"","text":"剑指offer8. 二叉树的下一个节点 P65题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。 Case1: p有右子树， 答案next就是右子树最左节点Case2: p 无右子树, 且是父节点的左儿子，next就是父节点Case3: p 无右子树, 且是父节点的右儿子，那么沿着右分支往上一直找父节点，当前节点cur = parent; 当前节点的父节点parent = parent -&gt; m_pParent; 直到父节点parent是null（这时cur是根节点），或者还有父节点但是已经不是沿右分支了（parent -&gt; m_pRight ！= cur），那么这第一个左分支的父节点（parent）就是next。 123456789101112131415161718192021222324BinaryTreeNode *getNextNode(BinaryTreeNode *p) &#123;//不用传根，p带的就是树的信息 if (p == NULL) return NULL; BinaryTreeNode *nextNode = NULL; // 可以覆盖p是最后一个节点情况 if(p -&gt; m_pRight != NULL) &#123; // case1 BinaryTreeNode *right = p -&gt; m_pRight; while (right -&gt; m_pLeft != NULL) right = right -&gt; m_pLeft; nextNode = right; &#125;else if (p -&gt; m_pParent != NULL) &#123; // case2，3 可以一起处理 BinaryTreeNode *parent = p -&gt; m_pParent; BinaryTreeNode *cur = p; // case2 不会进入这个循环，因为不满足第二个条件 while (parent != NULL &amp;&amp; parent -&gt; m_pRight== cur) &#123;//沿右分支找父亲 cur = parent; parent = parent -&gt; m_pParent; &#125; // 循环结束，case3就转换到和case2的情况了 nextNode = parent; // 下一个节点就是父节点 &#125; return nextNode; // 如果p是最后一个节点，上面if else都不会执行&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer7. 重建二叉树 P62","slug":"剑指offer7","date":"2019-10-31T06:14:31.000Z","updated":"2019-11-01T08:46:56.222Z","comments":true,"path":"2019/10/31/剑指offer7/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer7/","excerpt":"","text":"剑指offer7. 重建二叉树 p62题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出 图2.6所示的二叉树并输出它的头结点。 123456789101112131415161718192021222324252627282930313233struct BinaryTreeNode &#123; int key; BinaryTreeNode *left; BinaryTreeNode *right; BinaryTreeNode(int val) &#123; key = val; left = right =NULL;&#125;&#125;; // pre,in 分别是先序和中序列，length是序列长 BinaryTreeNode *constructBinaryTree(std::vector&lt;int&gt; pre, std::vector&lt;int&gt; in, int length) &#123; if (pre.size() == 0 || in.size() == 0 || length == 0) return NULL; BinaryTreeNode *head = new BinaryTreeNode(pre[0]); //初始化根节点 // 下面四个数组分别存储左，右子树的先根，中根序列 std::vector&lt;int&gt; leftpre, leftin, rightpre, rightin; int root; // 根节点索引 for (int i = 0; i &lt; length; ++i) &#123; if (in[i] == pre[0]) &#123; // 在中根序列中找到当前树根节点root的索引 root = i; break; &#125; &#125; for (int i = 0; i &lt; root; ++i) &#123; // 以root为界左边是左子树的先序，中序 leftpre.push_back(pre[i + 1]); leftin.push_back(in[i]); &#125; for (int i = root + 1; i &lt;length; ++i) &#123;//以root为界右边是右子树的先序，中序 rightpre.push_back(pre[i]); rightin.push_back(in[i]); &#125; //在下面完成父子节点的链接 ，并递归构建左右子树 head -&gt; left = constructBinaryTree(leftpre, leftin, leftpre.size()); head -&gt; right = constructBinaryTree(rightpre, rightin, rightpre.size()); return head; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer6. 插入并从尾到头打印链表 P58","slug":"剑指offer6","date":"2019-10-31T06:14:27.000Z","updated":"2019-11-01T08:46:45.799Z","comments":true,"path":"2019/10/31/剑指offer6/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer6/","excerpt":"","text":"剑指offer6 . 插入并从尾到头打印链表P58题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。 1234567891011121314151617181920212223242526272829303132333435struct ListNode &#123; int key; ListNode *next;&#125;;void addToTail(ListNode **pHead, int value) &#123; // 调用时实参指针pHead应该取引用 ListNode *temp = new ListNode; temp -&gt; key = value; temp -&gt; next =NULL; if (*pHead == NULL) &#123; *pHead = temp; return; &#125; ListNode* p = *pHead; while (p -&gt; next != NULL) p = p -&gt; next; p -&gt; next = temp; &#125; void printListReversingly(ListNode *pHead) &#123; //用栈实现 反向便利 std:: stack&lt;ListNode* &gt; nodes; ListNode *p = pHead; while (p != NULL) &#123; nodes.push(p); p = p -&gt; next; &#125; while (!nodes.empty()) &#123; std::cout &lt;&lt; nodes.top() -&gt; key &lt;&lt; std:: endl; nodes.pop(); &#125;&#125;void printListReversingRecursively(ListNode *pHead) &#123; //递归实现 if (pHead == NULL) return; printListReversingRecursively(pHead -&gt; next); std:: cout&lt;&lt; pHead -&gt; key &lt;&lt; std:: endl; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer5. 替换空格   P51","slug":"剑指offer5","date":"2019-10-31T06:14:21.000Z","updated":"2019-11-01T08:46:30.972Z","comments":true,"path":"2019/10/31/剑指offer5/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer5/","excerpt":"","text":"剑指offer 5. 替换空格 P511. 第一种做法可以用sting = “”,遍历原始数组，遇到非空格直接加，遇到空格加上%20，最后string就是答案。 这种做法比较简洁易懂，但是空间复杂度是O(N) 2. 第二种做法就是书上的用两个指针倒着工作。在原地操作，空间开销小 1234567891011121314151617181920212223void replaceBlank(char string[], int length) &#123; if (string == NULL || length &lt;= 0) return; int count = 0, old_tail = 0; // 记录空格数；原数组索引指针 while (string[old_tail] != '\\0') &#123; if (string[old_tail] == ' ') ++count; old_tail++; &#125; // 新数组结尾 int new_tail = old_tail + count * 2; //不是*3，因为原来的空格还可以放一个 if (new_tail &gt; length) return; //不能=， 因为’\\0’ while (old_tail &gt;= 0) &#123; // 两个指针一起倒着走 if (string[old_tail] != ' ') string[new_tail--] = string[old_tail]; else &#123; string[new_tail--] = '0'; string[new_tail--] = '2'; string[new_tail--] = '%'; &#125; old_tail--; //不能在if里面减 &#125; &#125; 扩展： 有两个从小到大排序数组a，b。 a尾部有足够的空间容纳b，试着把b合并到a中，并且保持依然有序。 思想：跟这题很像，可以确定a的新结尾len（a）+len(b) – 1；然后倒着遍历两数组，把较大的放入新结尾，更新工作指针。","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"剑指offer4.二维数组中查找  P44","slug":"剑指offer4","date":"2019-10-31T06:11:24.000Z","updated":"2019-11-01T08:45:59.007Z","comments":true,"path":"2019/10/31/剑指offer4/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer4/","excerpt":"","text":"剑指offer4. 二维数组中查找 P44题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 c++传二维数组，要么像下面这样传一维指针之后计算（此时实参不能new或者malloc出，因为地址可能不连续） 要么必须指明所有维数大小或者省略第一维的，但是不能省略第二维或者更高维的大小，这是由编译器原理限制的。编译器是这样处理数组的： 对于数组 int p[m][n];如果要取p[i][j]的值(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; 0&lt;=j &amp;&amp; j &lt; n)，编译器是这样寻址的，它的地址为： p + i*n + j; （p是数组首地址）所以不指定n的话，没办法计算。 建议用vector数组替代二维数组，使用灵活，且不涉及指针这种乱七八糟的操作。 12345678910111213141516/* 行是增的，列是减的 注意： 本题用不了横纵向的二分查找！！！*/bool findNumbers( const int *martix, int t, int rows, int columns) &#123; if ((martix == NULL) || (rows == 0 &amp;&amp; columns == 0)) return false; int x = 0, y = columns - 1; while (x &lt; rows &amp;&amp; y &gt;= 0) &#123; // 注意两个边界不一样 int temp = martix[x * columns + y]; if (temp == t) return true; else if (t &gt; temp) ++x; else --y; &#125; return false; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer 3. 数组中重复的(所有)数字","slug":"剑指offer3","date":"2019-10-31T04:04:12.000Z","updated":"2019-11-01T08:46:14.728Z","comments":true,"path":"2019/10/31/剑指offer3/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer3/","excerpt":"","text":"3 . 数组中重复的(所有)数字 p39题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。（原题只是找出一个，下面实现比原题多一步，打印所有的） 1. 允许修改数组 因为每个数字都只能对应一个索引，从索引i=0开始一步一步找到所有i对应的数，那么一定会慢慢逼近到有个值是i，但是不在索引i（i已经有一个值=i了）上。尽管有for，while两重循环，但是基本上每一次比较之后要么前进，要么交换（交换后保证一个元素处在自己的索引位置, 遍历到它的时候就跳过，这也相当于前进了），所以时间复杂度还是O（n），空间复杂度是O（1） 12345678910111213141516171819202122232425262728void duplication (int numbers[], int length, set&lt;int &gt; &amp;ans) &#123; if (length &lt; 2 || numbers == NULL) return ; for (int i = 0; i &lt; length; ++i) // 数组中出现值超过索引界限 if (numbers[i] &gt;= length || numbers[i] &lt; 0) return; for (int i = 0; i &lt; length; ++i) &#123; while (numbers[i] != i) &#123; // 一定会满足 if (numbers[i] == numbers[numbers[i]]) &#123; ans.insert(numbers[i]); break; &#125; else &#123; int temp = numbers[i]; numbers[i] = numbers[temp]; numbers[temp] = temp; &#125; &#125; &#125;&#125;int main() &#123; int a[] = &#123;1,2,3,4,1,1,2,3,3,3&#125;; set&lt;int&gt; ans; // 把所有数字存入，用set会过滤掉重复数字 duplication(a, sizeof(a) / sizeof(a[0]), ans); if (ans.size() == 0) cout &lt;&lt; 0 &lt;&lt;endl; // 不存在 set &lt;int&gt; :: iterator it; for (it = ans.begin(); it != ans.end(); ++it) cout &lt;&lt; *it &lt;&lt; endl; return 0;&#125; 2. 不允许修改数组 P41找出数组中重复的数字用O(1)空间，nlogn时间，不能找出来所有重复数字 123456789101112131415161718192021222324252627int countNumbersBetweenStartAndEnd(const int *nums, int length,int start,int end) &#123; if (nums == NULL || length &lt; 1) return 0; int count = 0; for (int i = 0; i &lt; length; ++i) &#123; if (nums[i] &gt;= start &amp;&amp; nums[i] &lt;= end) ++count; &#125; return count;&#125;int findRepeatNumber(const int *nums, int length) &#123; if (nums == NULL || length &lt; 2) return -1; int start = 1; //这是边界范围，不是索引 int end = length - 1; while (start &lt;= end) &#123; int mid = ((end - start) &gt;&gt; 1) + start;//默认先在左边范围统计 int count = countNumbersBetweenStartAndEnd(nums, length, start, mid); if (start == end) &#123; // 循环出口 if (count &gt;= 2) return start; else return -1; // 没有找到 &#125; else &#123; if (count &gt; mid - start + 1) end = mid; // 确实在左边重复 else start = mid + 1; // 左边没有重复右“循环” &#125; &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"README","slug":"README","date":"2019-10-30T08:11:01.000Z","updated":"2019-11-01T08:35:16.513Z","comments":true,"path":"2019/10/30/README/","link":"","permalink":"http://yoursite.com/2019/10/30/README/","excerpt":"","text":"个人博客 Github Page剑指offer题解正在上传中…写前面的题的时候没想到要push到博客，有些就只有代码和部分注释，显得比较直白，但是后面感觉整理一下思路，等复习的时候可能会更快一点，就开始写思路整理，代码也有详细注释啦。希望有时间的话，把前面的思路再补充一下吧。因为最开始题解是在word里记录的，格式在word上看着很清晰，但是粘到markdown之后，有些格式就不好看了。大家见谅吧~Leetcode题解暂时只做了Array的80道左右，但是以前做的很多都忘了，现在在慢慢回顾整理，等有时间会发布出来~ 如果您觉得此份文档对您有些许帮助的话，请您去我的GitHub首页star一下！ [比心~]http://github.com/nobugsinlinux 不患无位，患所以立。 Have a nice day !","categories":[{"name":"README","slug":"README","permalink":"http://yoursite.com/categories/README/"}],"tags":[]}]}