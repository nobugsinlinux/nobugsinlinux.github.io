{"meta":{"title":"G2.int.BUPT","subtitle":"我爱网管","description":null,"author":"郭源潮","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-10-28T13:55:14.000Z","updated":"2019-10-31T08:02:43.344Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"北京邮电大学 网络技术研究院 2019级渣硕95后，不抽烟，不喝酒；没有钱，长得丑；喜欢运动但基本不动。在B站学习，在实验室摸鱼；被大佬虐过，真的心服口服。不相信恋爱，但朋友都很铁，对coding一往情深。同学朋友都很奈斯，偶尔几个戏精也无伤大雅。科研的道路总是要写文档，人生的旅途也是不咋顺畅迷茫过，纠结过，后悔过，也一直焦虑着，跌跌撞撞。意识到自己很菜。但是也不能太菜，还是要争取向上。比心~ Have a nice day !"},{"title":"分类","date":"2019-10-30T08:49:46.000Z","updated":"2019-10-30T09:16:08.744Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"帮黄某欣征友~","date":"2019-10-31T07:48:28.662Z","updated":"2019-10-31T07:48:28.662Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2019-10-29T06:13:36.000Z","updated":"2019-10-30T09:17:02.650Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":"北京邮电大学"},{"title":"标签","date":"2019-10-30T08:55:13.000Z","updated":"2019-10-30T09:13:15.720Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"剑指Offer20. 表示数值的字符串P127","slug":"剑指offer20","date":"2019-10-31T06:55:08.000Z","updated":"2019-10-31T08:06:23.762Z","comments":true,"path":"2019/10/31/剑指offer20/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer20/","excerpt":"","text":"剑指offer20 . 表示数值的字符串P127题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”、“5e2”、“-123”、“3.1416”及“-1E-16”都是，但“12e”、“1a3.14”、“1.2.3、“+-5”及“12e+5.4不是（这个题的描述相当不清楚，很多有悖常理的数字格式也是对的，leetcode上很多人吐槽） 1. 用自动机做 https://blog.csdn.net/qq_43778308/article/details/102838980 上图只是为了说明自动机处理的原理，下面代码不是按照上面这个图写的**。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859bool isNumber(const char * str) &#123; if (str == NULL) return false; int state=1; // 初始状态 for(int i = 0; i &lt; strlen(str); ++i)&#123; char c = str[i]; switch (state)&#123; case 1: if(c==' ') state=1; else if(c=='+'||c=='-') state=2; else if(isdigit(c)) state=3; else if(c=='.') state=4; else return false; break; case 2: if(isdigit(c)) state=3; else if(c=='.') state=4; else return false; break; case 3: if(isdigit(c)) state=3; else if(c=='e'||c=='E') state=6; else if(c=='.') state=5; else if(c==' ') state=9; else return false; break; case 4: if(isdigit(c)) state=5; else return false; break; case 5: if(isdigit(c)) state=5; else if(c=='e'||c=='E') state=6; else if(c==' ') state=9; else return false; break; case 6: if(c=='+'||c=='-') state=7; else if(isdigit(c)) state=8; else return false; break; case 7: if(isdigit(c)) state=8; else return false; break; case 8: if(isdigit(c)) state=8; else if(c==' ') state=9; else return false; break; case 9: if(c==' ') state=9; else return false; break; &#125; &#125; return state==3||state==5||state==8||state==9; // 一共有4个正确的结束状态 &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"自动机","slug":"自动机","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"正则匹配","slug":"正则匹配","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"}]},{"title":"剑指Offer19. 正则表达式匹配 P124","slug":"剑指offer19","date":"2019-10-31T06:55:02.000Z","updated":"2019-10-31T07:31:57.283Z","comments":true,"path":"2019/10/31/剑指offer19/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer19/","excerpt":"","text":"剑指offer19. 正则表达式匹配 P124题目：请实现一个函数用来匹配包含’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”及”ab*a”均不匹配。 因为 * 的存在让整个题目复杂，那我们把下一个字符是不是*作为划分依据。 Case 1. 当模式中的第二个字符不是“*”时：1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。2、如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 Case 2 . 当模式中的第二个字符是“*”时：可以有3种匹配方式：1、模式后移2字符，相当于x*被忽略；比如 str : ab , pattern : b*ab2、字符串后移1字符，模式后移2字符，x*相当于只匹配一个字符；ab 和 a*b3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为可以匹配多位；aab 和a\\b 12345678910111213141516171819202122232425bool isMatchedCore(const char *str, const char *pattern) &#123; // 匹配递归函数 if (*str == '\\0' &amp;&amp; *pattern == '\\0') return true; // 两个递归出口 if (*str != '\\0' &amp;&amp; *pattern == '\\0') return false; if (*(pattern + 1) == '*') &#123; // case 2情况 if ((*str == *pattern)|| (*pattern == '.' &amp;&amp; *str != '\\0')) &#123; // 当前字符匹配成功，相当于又重新进入case 2的情况，有三种选择 return isMatchedCore(str + 1, pattern) || isMatchedCore(str + 1, pattern + 2) || isMatchedCore(str, pattern + 2); &#125;else &#123; // 当前匹配失败那么*就没有作用了，跳过下一个*,只能是case 2.1的情况 return isMatchedCore(str, pattern + 2); &#125; &#125;else &#123; // case1情况下一个不是* if ((*str == *pattern)|| (*pattern == '.' &amp;&amp; *str != '\\0')) // case1.1 return isMatchedCore(str + 1, pattern + 1); else // case 1.2 return false; &#125;&#125;bool isMatched(const char *str, const char *pattern) &#123; // 匹配函数if (str == NULL &amp;&amp; pattern == NULL) return true; if (pattern == NULL) return false; return isMatchedCore(str, pattern); &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"正则匹配","slug":"正则匹配","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"}]},{"title":"剑指offer18．在O(1)时间内删除链表节点 P119","slug":"剑指offer18","date":"2019-10-31T06:54:59.000Z","updated":"2019-10-31T07:24:55.633Z","comments":true,"path":"2019/10/31/剑指offer18/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer18/","excerpt":"","text":"剑指offer18． 在O(1)时间内删除链表节点 P119题目：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。 /* 既然要在O（1）时间内删除，就不需要遍历，或者说大多数情况下不需要遍历整个链表，那么在O(1) 时间内我们能得到哪些东西呢？ 1.首先头指针和头指针下一个节点显然没有什么用，再者就是2. 需要删除的节点p和他的下一个节点next， 那么肯定是围绕着p和next操作。如果要删除应该链表节点，通常要找到它的前驱，这一道题能够构成这种前后关系的就是删除next，它的前驱是p，于是我们把next的东西复制给p，再删除next就ok了。以上是普通情况当p是头结点时候，要特判，p是尾节点时候，只能够遍历整个链表了此外，因为o（1）时间的限制，我们不能确保链表中有p，这只能交给函数调用者处理了 1234567891011121314151617181920212223242526272829void deleteNode(ListNode **pHeadList, ListNode *pToDeleteNode) &#123; if (!(*pHeadList) || !pToDeleteNode) return; if (*pHeadList == pToDeleteNode) &#123; // 删头节点 ListNode *temp = *pHeadList; if (temp -&gt; next == NULL) &#123; // 链表只有一个节点 *pHeadList = NULL; delete temp; &#125; else &#123; // 链表有其他节点 *pHeadList = (*pHeadList) -&gt; next;// 不要使用delete (*pHeadList)，在没有被分配之前里面的内容还是完好的。// 而且delete不负责将指针设置为NULL。 delete temp; temp = NULL; &#125; &#125; else if (pToDeleteNode -&gt; next != NULL) &#123; // 在中间删除，把next值给当前节点， // 并且删除next ListNode *temp = pToDeleteNode -&gt; next; pToDeleteNode -&gt; key = pToDeleteNode -&gt; next -&gt;key; pToDeleteNode -&gt; next = pToDeleteNode -&gt; next -&gt; next; delete temp; temp = NULL; &#125; else if (pToDeleteNode -&gt; next == NULL) &#123; // 删除尾节点，必须遍历 ListNode *p = *pHeadList; while (p -&gt; next != pToDeleteNode) p = p -&gt; next; p -&gt; next = NULL; delete pToDeleteNode; pToDeleteNode = NULL; &#125;&#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer17. 打印从1到最大的n位数 P114","slug":"剑指offer17","date":"2019-10-31T06:54:53.000Z","updated":"2019-10-31T07:42:14.673Z","comments":true,"path":"2019/10/31/剑指offer17/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer17/","excerpt":"","text":"剑指offer17. 打印从1到最大的n位数 P114题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。 1. 方法一： 用字符数组str倒着存储大数。每次大数自增1，如果溢出，表明打印完 12345678910111213141516171819202122232425262728293031// 此函数完成大数自增1的功能，并返回是否已经“溢出”（长度满足题目要求）bool Increment(char *str, int current_length) &#123; int carry = 0; // 进位 bool overflow = false; // 溢出标志 for (int i = current_length - 1; i &gt;=0; --i) &#123; // 加1后大数从后往前每一位进行更新 int num = str[i] - '0' + carry; //不能再上面直接+1，因为这个for后面都是为了处理第一次的进位的 if (i == current_length - 1) num++; // 只有最低位+1 if (num &gt;= 10) &#123; // 有进位 if (i == 0) &#123; // 有进位，而且是最高位i=0产生的，溢出 overflow = true; // 调用函数也退出循环 break; // 退出 &#125; str[i] = num - 10 + '0'; // 否则，处理进位 carry = 1; &#125; else &#123; str[i] = num + '0'; //这后面不用加carry=0 break; // 因为后面的循环时为了处理进位，没有进位就直接退出了 &#125; &#125; return overflow; //返回溢出标志&#125;void print1ToMaxOfNDigits(int n) &#123; // 调用函数，打印1 -- n位最大数 if (n &lt; 1) return; char *str = new char[n + 1]; memset(str, '0',sizeof(str)); str[n] = '\\0'; while (!Increment(str, n)) // 自增后，判断是否溢出， print(str, n); // 没有溢出，打印&#125; 2. 方法二，递归全排列 如果我们在数字前面补0，就会发现n位所有十进制数其实就是n个从0到9数字的全排列。也就是说，我们把数字的每一位都从0到9遍历一遍，就得到了所有的十进制数。只是在打印的时候，排在前面的0不打印出来罢了。全排列用递归表达，数字的每一位都可能是0~9中的一个数，然后设置下一位。递归结束的条件是我们设置了的数字的最后一位。 12345678910111213141516171819202122232425262728293031323334353637void print1ToMaxOfNDigits2(int len) &#123; if (len &lt; 1) return ; char *nums = new char[len]; // 不用len+1 for (int i = 0; i &lt; len; ++i) nums[i] = '0'; for (int i = 0; i &lt;= 9; ++i)&#123; // 从第0位开始设置，取0-9调用递归 nums[0] = i + '0'; printCore(nums,len,0); &#125; delete[] nums;&#125; void printCore(char *nums, int len, int index) &#123;// 求排列，index是当前设置的第index位 if (index == len - 1 ) &#123; // 递归出口，设置完最后一位 print(nums, len); // 打印 return; &#125; for (int i = 0 ; i &lt;= 9; ++i) &#123; // 递归当前第index后面的若干位 nums[index + 1] = i + '0'; printCore(nums, len, index + 1); &#125; &#125;// 把符合条件的一个数打印出来，注意题干，从1开始打印！void print(char *str, int len) &#123; int i = 0; while (str[i] == '0') ++i; //剔除前导0 if (i != len) &#123; while (i &lt; len) &#123; printf(\"%c\", str[i]); ++i; &#125; printf(\"\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"剑指Offer16. 数值的整数次方 P110","slug":"剑指offer16","date":"2019-10-31T06:54:49.000Z","updated":"2019-10-31T07:16:44.778Z","comments":true,"path":"2019/10/31/剑指offer16/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer16/","excerpt":"","text":"剑指offer16. 数值的整数次方P110题目：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 1234567891011121314151617181920212223242526272829303132333435const double esp = 1e-6; bool isValid = false; // power函数返回0时，判断合不合法，true时不合法double powerWithUnsignedExponent(double base, int exponent) &#123; // 此输入保证指数非负 if (exponent == 0) return 1; if (exponent == 1) return base; // 指数除以2递归 double ans = powerWithUnsignedExponent(base, exponent &gt;&gt; 1); ans *= ans; // 先在上一步递归里算出来a的（n/2）次方， 再平方 if ((exponent &amp; 1)) &#123; // 如果指数是奇数还要再乘以base （规律见p112） ans *= base; &#125; return ans;&#125;double power(double base, int exponent) &#123; isValid = false; // 这是全局变量，不能省 ，默认合法 if (fabs(base - 0.0) &lt;= esp &amp;&amp; exponent &lt; 0) &#123; isValid = true; // 不合法 的0.0 return 0.0; &#125; if (exponent == 0) return 1.0; if (base == 0) &#123; return 0.0; // 合法的0.0 &#125; //先把指数按正数处理 int temp = exponent &lt; 0 ? -exponent : exponent; double ans = powerWithUnsignedExponent(base, temp); // 如果指数是负数，结果取倒数 if (exponent &lt; 0) ans = 1 / ans; return ans; &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"剑指Offer15. 二进制中1的个数 P100","slug":"剑指offer15","date":"2019-10-31T06:54:44.000Z","updated":"2019-10-31T07:14:15.195Z","comments":true,"path":"2019/10/31/剑指offer15/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer15/","excerpt":"","text":"剑指offer15. 二进制中1的个数 P10012345678910111213141516171819int countNumbersOfOne(int a) &#123; int count = 0; unsigned int flag = 1; while (flag) &#123; if ((a &amp; flag)) ++count; flag = flag &lt;&lt; 1; //常规方法 让1从右往左分别与a的每一位与 // 不能右移a，因为 0x80000000时死循环 &#125; return count;&#125;int countNumbersOfOne2(int a) &#123; int count = 0; while (a) &#123; a &amp;= a - 1; // a&amp;a-1之后会刚好相当于a的二进制去掉一个最后一个1， ++count; // 统计它循环次数就知道几个1了 &#125; return count;&#125; 扩展：1 一条语句判断整数是不是2的整数次方2 两个整数m,n 求m要改变多少二进制位才能变成n 1 （二进制中只有一个1） 2 （1）先异或^（2）统计结果中1的个数","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"位运算","slug":"位运算","permalink":"http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"剑指Offer14. 剪绳子 P96","slug":"剑指offer14","date":"2019-10-31T06:54:39.000Z","updated":"2019-10-31T07:06:27.274Z","comments":true,"path":"2019/10/31/剑指offer14/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer14/","excerpt":"","text":"剑指offer14 . 剪绳子 P96题目：给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1]…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。 动态规划， 令 f(n) 是长度n最后的最大乘积，剪在整数上i上 ，显然f(n) = max( f(i) * f(n-i) ) i 从4到n，前3个要特判，因为当n等于1-3时，得到的乘积最大数和把前3个当作乘数因子（提供给后面4~n时的数当作f(i) 或者f(n-i)）不一样。 123456789101112131415161718192021222324int maxProduct(int length) &#123; if (length &lt; 2) return 0; // 要求length &gt; 1 if (length == 2) return 1; // 只能从i=1处剪 if (length == 3) return 2; // 同上 int *dp = new int[length + 1]; memset(dp, 0, sizeof(dp)); // dp在前三个存的并不是答案，只是为了充当dp[i] 或 dp[n-i]，所以才在上面特判 // 因为n是1到3时，还必须要剪一刀，但是充当乘法因子不一定要在它们中间剪 dp[1] = 1; //前三个代表长度为i的子绳最大能提供的乘法因子是多少 dp[2] = 2; dp[3] = 3; for (int i = 4; i &lt;= length; ++i) &#123; // i是绳长 for (int j = 1; j &lt;= i / 2; ++j) &#123; dp[i] = max(dp[i], dp[j] * dp[i - j]); //括号里的dp[i]存的是前几个j的dp[i]的最大值，跟当前比 &#125; &#125; int ans = dp[length]; delete [ ] dp; return ans; &#125; 贪心那个解法已然放弃。。。我这样的学术辣鸡不配使用贪心。","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指Offer13. 机器人的运动范围 P92","slug":"剑指offer13","date":"2019-10-31T06:54:30.000Z","updated":"2019-10-31T07:03:14.453Z","comments":true,"path":"2019/10/31/剑指offer13/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer13/","excerpt":"","text":"剑指offer13. 机器人的运动范围 P92题目：地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和 大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 12345678910111213141516171819202122232425262728293031323334353637// 判断当前访问的格子是不是有效// 参数：二维数组行，列总数，当前行，列索引，给定k值，访问标志bool isValid(int rows, int cols, int i, int j, int k, bool *visited) &#123; if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || visited[i * cols + j]) return false; // 边界条件不满足，访问访问过 int sum = 0; // i，j的各位和 while (i != 0) &#123; sum += i % 10; i /= 10; &#125; while (j != 0) &#123; sum += j % 10; j /= 10; &#125; if (sum &gt; k) return false; return true;&#125;int countS(int rows, int cols, int i, int j, int k, bool *visited) &#123; // 递归 int count = 0; if (isValid(rows, cols, i, j, k, visited)) &#123; //当前格满足条件 visited[i * cols + j] = true; count = 1 + countS(rows, cols, i - 1, j, k, visited) //不是count += + countS(rows, cols, i, j - 1, k, visited) + countS(rows, cols, i + 1, j, k, visited) + countS(rows, cols, i, j + 1, k, visited); &#125; return count;&#125;int movingCount( int k, int rows, int cols) &#123; if (k &lt; 0 || rows &lt; 1 || cols &lt; 1) return 0; bool *visited = new bool[rows * cols]; memset(visited, 0, rows * cols); int ans = countS(rows, cols, 0, 0, k, visited);//不用再两层for遍历了 delete []visited; return ans; &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"剑指Offer12.  矩阵中匹配字符串 P89","slug":"剑指offer12","date":"2019-10-31T06:54:12.000Z","updated":"2019-10-31T06:59:36.093Z","comments":true,"path":"2019/10/31/剑指offer12/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer12/","excerpt":"","text":"剑指offer12. 矩阵中匹配字符串P89题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。A B T GC F C SJ D E H // 参数：原始数组，二维数组行，列，当前访问元素的行，列，// 目标字符串，访问标志，路径索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool isHavePath(const char *matrix, int rows, int cols, int i, int j, const char *str, bool *visited, int&amp; pathlength) &#123; if (str[pathlength] == '\\0') return true; // 匹配结束，返回true bool havepath = false; // 答案 // 当前访问元素的行列没有越界，没有访问过，值和目标字符串对应位置一样 if (i &gt;= 0 &amp;&amp; i &lt; rows &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; cols &amp;&amp; !visited[i * cols + j] &amp;&amp; matrix[i * cols + j] == str[pathlength]) &#123; visited[i * cols + j] = true; // 设置访问过 ++pathlength; // 注意：c++对于引用类型，不能传临时变量 // 也就是说，下面递归调用不能传pathlength+1 havepath = isHavePath(matrix, rows, cols, i - 1, j, str, visited, pathlength ) || isHavePath(matrix, rows, cols, i, j - 1, str, visited, pathlength ) || isHavePath(matrix, rows, cols, i + 1, j, str, visited, pathlength ) || isHavePath(matrix, rows, cols, i, j + 1, str, visited, pathlength ); if (!havepath) &#123; // 没有找到，回溯，把访问标记和路径索引回溯-1 visited[i * cols + j] = false; --pathlength; &#125; &#125; return havepath;&#125;bool hasPath(const char *matrix, int rows, int cols,const char *str) &#123; if (matrix == NULL || rows &lt;= 0 || cols &lt;= 0 || str == NULL) return false; bool *visited = new bool(rows * cols); // 访问标志初始化 memset(visited, 0, rows * cols); int path = 0; for (int i = 0; i &lt; rows; ++i) &#123; // 遍历二维数组每一个元素 for (int j = 0; j &lt; cols; ++j) &#123;**// path = 0; 这个可写可不写，因为如果匹配失败，在上面递归函数里，// path会回溯-1，直到减回0；匹配 成功直接返回了** if (isHavePath(matrix, rows, cols, i, j, str, visited, path)) // 递归 &#123; delete []visited; return true; &#125; &#125; &#125; delete []visited; return false; &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"剑指Offer11．旋转数组的最小数字 P82","slug":"剑指offer11","date":"2019-10-31T06:42:37.000Z","updated":"2019-10-31T06:51:30.644Z","comments":true,"path":"2019/10/31/剑指offer11/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer11/","excerpt":"","text":"剑指offer11． 旋转数组的最小数字 P82题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。 看到有序两个字，要条件反射的想到二分。 这题应该注意的二分的划分依据是：中间值mid和子序列首尾大小比较（注意三者相等时的特殊情况），首先，i总是指向前面递增数组的元素，j总是指向后面递增数组的元素。如果i和j相差是1的话，那么索引i指向第一个递增数组的末尾，j指向后一个递增数组的开头。自然j指的就是答案了 123456789101112131415161718192021222324int Min(int *num, int length) &#123; if (num == NULL || length &lt; 1) throw (&quot;Invalid Input&quot;); if (length == 1 || num[0] &lt; num[length - 1]) return num[0]; // 递增 int i = 0, j = length -1, mid = 0; while (i &lt;= j ) &#123; mid = ((j - i) &gt;&gt; 1) + i; //三个指针值一样，不能二分，只有从头遍历 if (num[mid] == num[i] &amp;&amp; num[mid] ==num[j])&#123; for (int i = 1; i &lt; length; ++i) &#123; if (num[i] &lt; num[i - 1]) return num[i]; &#125; &#125;else if (num[mid] &gt;= num[i]) i = mid; //往右二分，不能从mid+1开始， // 因为如果mid此时刚好是答案，刚好错过正确的答案 else if (num[mid] &lt;= num[j]) j = mid; // 往左二分 ，同样必须从mid开始 if (j - i == 1 ) return num[j]; // i指向前一个递增数组结尾，j指向后一个开头 &#125; &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer（扩展）快排 P80","slug":"剑指offer扩展","date":"2019-10-31T06:14:48.000Z","updated":"2019-10-31T06:51:46.956Z","comments":true,"path":"2019/10/31/剑指offer扩展/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer%E6%89%A9%E5%B1%95/","excerpt":"","text":"剑指offer（扩展）快排 P801234567891011121314151617181920212223242526272829303132333435363738391. 快速排序 （递归实现）void quickSort(int nums[], int start, int end) &#123; if (nums == NULL || start &gt; end || start &lt; 0) return; int flag = nums[start], i = start, j = end; while (i &lt; j) &#123; while (nums[j] &gt;= flag &amp;&amp; i &lt; j) --j; // 一定是 先 从右往左找 nums[i] = nums[j]; while(nums[i] &lt;= flag &amp;&amp; i &lt; j) ++i; nums[j] = nums[i]; &#125; nums[i] = flag; // 确定当前基准值的位置 i quickSort(nums, start, i - 1); quickSort(nums, i + 1, end);&#125;2. 给公司员工年龄排序 P81void ageSort(int nums[], int len) &#123; if (nums == NULL || len &lt; 1) return; const int range_of_age_up = 100; // 年龄上界 const int range_of_age_down = 0; // 年龄下界 int *hash = new int[range_of_age_up + 1]; // hash表存对应年龄出现次数 memset(hash, 0, sizeof(hash) * (range_of_age_up + 1) ); // 注意长度！ for (int i = 0; i &lt; len; ++i) &#123; if (nums[i] &lt; range_of_age_down || nums[i] &gt; range_of_age_up) &#123; // 异常 throw \"sorry , out of range !\"; &#125; ++hash[nums[i]]; &#125; int index = 0; // 排序后的数组索引 for (int i = 0; i &lt;= range_of_age_up; ++i) // 统计每个年龄 i出现的次数hash[j] for (int j = 0; j &lt; hash[i]; ++j) // 那么连着hash[j]个元素就是年龄i nums[index++] = i; &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"剑指Offer10. 高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题P74","slug":"剑指offer10","date":"2019-10-31T06:14:44.000Z","updated":"2019-10-31T06:51:18.582Z","comments":true,"path":"2019/10/31/剑指offer10/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer10/","excerpt":"","text":"剑指offer10 . 高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题p74123456789101112131415//优化后的斐波那契long long fb(int n) &#123; if (n &lt; 0) return -1; int table[2] = &#123;0, 1&#125;; if (n &lt; 2) return table[n]; long long pre1 = 1, pre2 = 0, fbn = 0; for (int i = 2; i &lt;= n; ++i) &#123; fbn = pre1 + pre2; pre2 = pre1; pre1 = fbn; &#125; return fbn;&#125; 青蛙跳台阶（只能跳1，2步） 设f(n)表示青蛙跳上n级台阶的跳法数。当只有一个台阶时，n = 1时， 只有1中跳法； n = 2时，有两种跳法；；当n很大时，青蛙在最后一步跳到第n级台阶时，有两种情况：一种是青蛙在第n-1个台阶跳一个台阶，那么青蛙完成前面n-1个台阶，就有f(n-1)种跳法，这是一个子问题。另一种是青蛙在第n-2个台阶跳两个台阶到第n个台阶，那么青蛙完成前面n-2个台阶，就有f(n-2)种情况，这又是另外一个子问题。两个子问题构成了最终问题的解，所以当n&gt;=3时，青蛙就有f(n)=f(n-1)+f(n-2)种跳法。 扩展 ：如果一次可以跳1，2，3…n 级的话 f(n) = 2的n-1次方证明： f(n) = f(n-1) + f(n-2) + f(n-3) …+f(n-n) 方程1 f(n-1) = f(n-2) + f(n-3) + f(n-4) …+f(n-n) 方程2 方程1-2得 ： f(n) – f(n-1) = f(n-1) f(n) = 2*f(n-1) = 2*2*f(n-2)=…2的n-1次方p79 页的矩阵覆盖也是同样的道理，不再赘述（注意n是初始几个值0，1，2的特判）","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指Offer9. 两个栈实现队列 P68","slug":"剑指offer9","date":"2019-10-31T06:14:40.000Z","updated":"2019-10-31T06:51:03.105Z","comments":true,"path":"2019/10/31/剑指offer9/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer9/","excerpt":"","text":"剑指offer9. 两个栈实现队列 p68题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 /*在stack1 中存入；从stack2里取，如果取得时候2是null，把1的值全压到2再取 */ 12345678910111213141516171819202122232425262728#include&lt;stdexcept&gt; template &lt;typename T&gt; class CQueue &#123; public: CQueue(void)&#123; &#125;; // 不能只写个名字 ~CQueue(void)&#123;&#125;; void appendTail(const T&amp; node) &#123; // node的值不能被改变 stack1.push(node); &#125; T deleteHead() &#123; if (stack2.empty()) &#123; while (!stack1.empty()) &#123; stack2.push(stack1.top()); stack1.pop(); &#125; &#125; if (stack2.empty()) &#123; // 说明没有插入数据 ，抛出，不会往下执行 std::logic_error ex(&quot;queue is null !&quot;); throw std::exception(ex); &#125; T t = stack2.top(); stack2.pop(); return t; &#125; private: std::stack&lt;T&gt; stack1; std::stack&lt;T&gt; stack2; &#125;; 扩展： 用两个队列模拟栈思想： 两个队列交替充当队列。比如 压栈c时：往非空的队列1插入c，1内容变成cba。弹栈时，需要的是c，但是队列1头是a，那么依此把队列1的内容插入队列2中，把最后一个元素c返回。这时队列2变成非空了，那么再压栈就往2里插入了。如此循环","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"栈&队列","slug":"栈-队列","permalink":"http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"}]},{"title":"剑指Offer8. 二叉树的下一个节点 P65","slug":"剑指offer8","date":"2019-10-31T06:14:35.000Z","updated":"2019-10-31T06:50:52.419Z","comments":true,"path":"2019/10/31/剑指offer8/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer8/","excerpt":"","text":"剑指offer8. 二叉树的下一个节点 P65题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。 Case1: p有右子树， 答案next就是右子树最左节点Case2: p 无右子树, 且是父节点的左儿子，next就是父节点Case3: p 无右子树, 且是父节点的右儿子，那么沿着右分支往上一直找父节点，当前节点cur = parent; 当前节点的父节点parent = parent -&gt; m_pParent; 直到父节点parent是null（这时cur是根节点），或者还有父节点但是已经不是沿右分支了（parent -&gt; m_pRight ！= cur），那么这第一个左分支的父节点（parent）就是next。 123456789101112131415161718192021222324BinaryTreeNode *getNextNode(BinaryTreeNode *p) &#123;//不用传根，p带的就是树的信息 if (p == NULL) return NULL; BinaryTreeNode *nextNode = NULL; // 可以覆盖p是最后一个节点情况 if(p -&gt; m_pRight != NULL) &#123; // case1 BinaryTreeNode *right = p -&gt; m_pRight; while (right -&gt; m_pLeft != NULL) right = right -&gt; m_pLeft; nextNode = right; &#125;else if (p -&gt; m_pParent != NULL) &#123; // case2，3 可以一起处理 BinaryTreeNode *parent = p -&gt; m_pParent; BinaryTreeNode *cur = p; // case2 不会进入这个循环，因为不满足第二个条件 while (parent != NULL &amp;&amp; parent -&gt; m_pRight== cur) &#123;//沿右分支找父亲 cur = parent; parent = parent -&gt; m_pParent; &#125; // 循环结束，case3就转换到和case2的情况了 nextNode = parent; // 下一个节点就是父节点 &#125; return nextNode; // 如果p是最后一个节点，上面if else都不会执行&#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer7. 重建二叉树 P62","slug":"剑指offer7","date":"2019-10-31T06:14:31.000Z","updated":"2019-10-31T06:50:36.190Z","comments":true,"path":"2019/10/31/剑指offer7/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer7/","excerpt":"","text":"剑指offer7. 重建二叉树 p62题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出 图2.6所示的二叉树并输出它的头结点。 123456789101112131415161718192021222324252627282930313233struct BinaryTreeNode &#123; int key; BinaryTreeNode *left; BinaryTreeNode *right; BinaryTreeNode(int val) &#123; key = val; left = right =NULL;&#125;&#125;; // pre,in 分别是先序和中序列，length是序列长 BinaryTreeNode *constructBinaryTree(std::vector&lt;int&gt; pre, std::vector&lt;int&gt; in, int length) &#123; if (pre.size() == 0 || in.size() == 0 || length == 0) return NULL; BinaryTreeNode *head = new BinaryTreeNode(pre[0]); //初始化根节点 // 下面四个数组分别存储左，右子树的先根，中根序列 std::vector&lt;int&gt; leftpre, leftin, rightpre, rightin; int root; // 根节点索引 for (int i = 0; i &lt; length; ++i) &#123; if (in[i] == pre[0]) &#123; // 在中根序列中找到当前树根节点root的索引 root = i; break; &#125; &#125; for (int i = 0; i &lt; root; ++i) &#123; // 以root为界左边是左子树的先序，中序 leftpre.push_back(pre[i + 1]); leftin.push_back(in[i]); &#125; for (int i = root + 1; i &lt;length; ++i) &#123;//以root为界右边是右子树的先序，中序 rightpre.push_back(pre[i]); rightin.push_back(in[i]); &#125; //在下面完成父子节点的链接 ，并递归构建左右子树 head -&gt; left = constructBinaryTree(leftpre, leftin, leftpre.size()); head -&gt; right = constructBinaryTree(rightpre, rightin, rightpre.size()); return head; &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer6. 插入并从尾到头打印链表 P58","slug":"剑指offer6","date":"2019-10-31T06:14:27.000Z","updated":"2019-10-31T06:50:19.461Z","comments":true,"path":"2019/10/31/剑指offer6/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer6/","excerpt":"","text":"剑指offer6 . 插入并从尾到头打印链表P58题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。 1234567891011121314151617181920212223242526272829303132333435struct ListNode &#123; int key; ListNode *next;&#125;;void addToTail(ListNode **pHead, int value) &#123; // 调用时实参指针pHead应该取引用 ListNode *temp = new ListNode; temp -&gt; key = value; temp -&gt; next =NULL; if (*pHead == NULL) &#123; *pHead = temp; return; &#125; ListNode* p = *pHead; while (p -&gt; next != NULL) p = p -&gt; next; p -&gt; next = temp; &#125; void printListReversingly(ListNode *pHead) &#123; //用栈实现 反向便利 std:: stack&lt;ListNode* &gt; nodes; ListNode *p = pHead; while (p != NULL) &#123; nodes.push(p); p = p -&gt; next; &#125; while (!nodes.empty()) &#123; std::cout &lt;&lt; nodes.top() -&gt; key &lt;&lt; std:: endl; nodes.pop(); &#125;&#125;void printListReversingRecursively(ListNode *pHead) &#123; //递归实现 if (pHead == NULL) return; printListReversingRecursively(pHead -&gt; next); std:: cout&lt;&lt; pHead -&gt; key &lt;&lt; std:: endl; &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer5. 替换空格   P51","slug":"剑指offer5","date":"2019-10-31T06:14:21.000Z","updated":"2019-10-31T06:50:02.063Z","comments":true,"path":"2019/10/31/剑指offer5/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer5/","excerpt":"","text":"剑指offer 5. 替换空格 P511. 第一种做法可以用sting = “”,遍历原始数组，遇到非空格直接加，遇到空格加上%20，最后string就是答案。 这种做法比较简洁易懂，但是空间复杂度是O(N) 2. 第二种做法就是书上的用两个指针倒着工作。在原地操作，空间开销小 1234567891011121314151617181920212223void replaceBlank(char string[], int length) &#123; if (string == NULL || length &lt;= 0) return; int count = 0, old_tail = 0; // 记录空格数；原数组索引指针 while (string[old_tail] != '\\0') &#123; if (string[old_tail] == ' ') ++count; old_tail++; &#125; // 新数组结尾 int new_tail = old_tail + count * 2; //不是*3，因为原来的空格还可以放一个 if (new_tail &gt; length) return; //不能=， 因为’\\0’ while (old_tail &gt;= 0) &#123; // 两个指针一起倒着走 if (string[old_tail] != ' ') string[new_tail--] = string[old_tail]; else &#123; string[new_tail--] = '0'; string[new_tail--] = '2'; string[new_tail--] = '%'; &#125; old_tail--; //不能在if里面减 &#125; &#125; 扩展： 有两个从小到大排序数组a，b。 a尾部有足够的空间容纳b，试着把b合并到a中，并且保持依然有序。 思想：跟这题很像，可以确定a的新结尾len（a）+len(b) – 1；然后倒着遍历两数组，把较大的放入新结尾，更新工作指针。","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"剑指offer4.二维数组中查找  P44","slug":"剑指offer4","date":"2019-10-31T06:11:24.000Z","updated":"2019-10-31T06:49:36.498Z","comments":true,"path":"2019/10/31/剑指offer4/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer4/","excerpt":"","text":"剑指offer4. 二维数组中查找 P44题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 c++传二维数组，要么像下面这样传一维指针之后计算（此时实参不能new或者malloc出，因为地址可能不连续） 要么必须指明所有维数大小或者省略第一维的，但是不能省略第二维或者更高维的大小，这是由编译器原理限制的。编译器是这样处理数组的： 对于数组 int p[m][n];如果要取p[i][j]的值(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; 0&lt;=j &amp;&amp; j &lt; n)，编译器是这样寻址的，它的地址为： p + i*n + j; （p是数组首地址）所以不指定n的话，没办法计算。 建议用vector数组替代二维数组，使用灵活，且不涉及指针这种乱七八糟的操作。 12345678910111213141516/* 行是增的，列是减的 注意： 本题用不了横纵向的二分查找！！！*/bool findNumbers( const int *martix, int t, int rows, int columns) &#123; if ((martix == NULL) || (rows == 0 &amp;&amp; columns == 0)) return false; int x = 0, y = columns - 1; while (x &lt; rows &amp;&amp; y &gt;= 0) &#123; // 注意两个边界不一样 int temp = martix[x * columns + y]; if (temp == t) return true; else if (t &gt; temp) ++x; else --y; &#125; return false; &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer 3. 数组中重复的(所有)数字","slug":"剑指offer3","date":"2019-10-31T04:04:12.000Z","updated":"2019-10-31T06:13:56.094Z","comments":true,"path":"2019/10/31/剑指offer3/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer3/","excerpt":"","text":"3 . 数组中重复的(所有)数字 p39题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。（原题只是找出一个，下面实现比原题多一步，打印所有的） 1. 允许修改数组 因为每个数字都只能对应一个索引，从索引i=0开始一步一步找到所有i对应的数，那么一定会慢慢逼近到有个值是i，但是不在索引i（i已经有一个值=i了）上。尽管有for，while两重循环，但是基本上每一次比较之后要么前进，要么交换（交换后保证一个元素处在自己的索引位置, 遍历到它的时候就跳过，这也相当于前进了），所以时间复杂度还是O（n），空间复杂度是O（1） 12345678910111213141516171819202122232425262728void duplication (int numbers[], int length, set&lt;int &gt; &amp;ans) &#123; if (length &lt; 2 || numbers == NULL) return ; for (int i = 0; i &lt; length; ++i) // 数组中出现值超过索引界限 if (numbers[i] &gt;= length || numbers[i] &lt; 0) return; for (int i = 0; i &lt; length; ++i) &#123; while (numbers[i] != i) &#123; // 一定会满足 if (numbers[i] == numbers[numbers[i]]) &#123; ans.insert(numbers[i]); break; &#125; else &#123; int temp = numbers[i]; numbers[i] = numbers[temp]; numbers[temp] = temp; &#125; &#125; &#125;&#125;int main() &#123; int a[] = &#123;1,2,3,4,1,1,2,3,3,3&#125;; set&lt;int&gt; ans; // 把所有数字存入，用set会过滤掉重复数字 duplication(a, sizeof(a) / sizeof(a[0]), ans); if (ans.size() == 0) cout &lt;&lt; 0 &lt;&lt;endl; // 不存在 set &lt;int&gt; :: iterator it; for (it = ans.begin(); it != ans.end(); ++it) cout &lt;&lt; *it &lt;&lt; endl; return 0;&#125; 2. 不允许修改数组 P41找出数组中重复的数字用O(1)空间，nlogn时间，不能找出来所有重复数字 123456789101112131415161718192021222324252627int countNumbersBetweenStartAndEnd(const int *nums, int length,int start,int end) &#123; if (nums == NULL || length &lt; 1) return 0; int count = 0; for (int i = 0; i &lt; length; ++i) &#123; if (nums[i] &gt;= start &amp;&amp; nums[i] &lt;= end) ++count; &#125; return count;&#125;int findRepeatNumber(const int *nums, int length) &#123; if (nums == NULL || length &lt; 2) return -1; int start = 1; //这是边界范围，不是索引 int end = length - 1; while (start &lt;= end) &#123; int mid = ((end - start) &gt;&gt; 1) + start;//默认先在左边范围统计 int count = countNumbersBetweenStartAndEnd(nums, length, start, mid); if (start == end) &#123; // 循环出口 if (count &gt;= 2) return start; else return -1; // 没有找到 &#125; else &#123; if (count &gt; mid - start + 1) end = mid; // 确实在左边重复 else start = mid + 1; // 左边没有重复右“循环” &#125; &#125; &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"README","slug":"README","date":"2019-10-30T08:11:01.000Z","updated":"2019-10-31T07:41:46.664Z","comments":true,"path":"2019/10/30/README/","link":"","permalink":"http://yoursite.com/2019/10/30/README/","excerpt":"","text":"个人博客 Github Page剑指offer题解正在上传中，大部分都带有思路整理，代码也有详细注释题解格式特别整理了一下，个人觉得很适合阅读Leetcode题解暂时只做了Array的80道左右，但是以前做的很多都忘了，现在在慢慢整理~ 如果您觉得此份文档对您有些许帮助的话，请您去我的GitHub首页star一下！ [比心~]http://github.com/nobugsinlinux 不患无位，患所以立。 Have a nice day !","categories":[{"name":"README","slug":"README","permalink":"http://yoursite.com/categories/README/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"}]}]}