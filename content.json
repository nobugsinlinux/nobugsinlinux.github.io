{"meta":{"title":"G2.int.BUPT","subtitle":"我爱网管","description":null,"author":"郭源潮","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-10-30T08:49:46.000Z","updated":"2019-10-30T09:16:08.744Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2019-10-29T06:13:36.000Z","updated":"2019-10-30T09:17:02.650Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":"北京邮电大学"},{"title":"关于我","date":"2019-10-28T13:55:14.000Z","updated":"2019-11-10T10:23:30.097Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个菜比。 Have a nice day !"},{"title":"广告~","date":"2019-11-06T00:57:01.813Z","updated":"2019-11-06T00:57:01.813Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"黄金铺位，广告招租，求赞助~"},{"title":"标签","date":"2019-10-30T08:55:13.000Z","updated":"2019-10-30T09:13:15.720Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode39 组合数和","slug":"leetcode39","date":"2019-11-06T00:47:42.000Z","updated":"2019-11-06T00:54:35.867Z","comments":true,"path":"2019/11/06/leetcode39/","link":"","permalink":"http://yoursite.com/2019/11/06/leetcode39/","excerpt":"","text":"LeetCode39 组合数和题目：给定一个的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 无重复元素（所以这个题没有在for里判断nums[i]==nums[i-1]，因为每取一个i都生成一个分支，两个数相等，两个分支相等，得到结果重复，下面那个就要考虑了） 123456789101112131415161718192021222324252627282930313233vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt; &gt; ans; if (nums.empty() || target &lt; 0) return ans; sort(nums.begin(), nums.end()); vector&lt;int&gt; path; int index = 0, sum = 0; bool flag = true; DFS(ans, nums, path, flag, target, index); return ans; &#125; void DFS(vector&lt;vector&lt;int&gt; &gt; &amp;ans, vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; path, bool flag, int target, int &amp;index) &#123; if (target &lt; 0) &#123; flag = false; return; &#125; if (target == 0) &#123; flag = false; ans.push_back(path); return; &#125; for (int i = index; i &lt; nums.size(); ++i) &#123; path.push_back(nums[i]); DFS(ans, nums, path, flag, target - nums[i], i); path.pop_back(); if (!flag) break; // 这里如果剪枝的话，nums必须要先排序，这样才能证明i后面的都没有用 &#125; flag = true; // 不加的话，会比加了变慢？？ 不懂，求告知 &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"LeetCode11 盛最多水的容器","slug":"leetcode11","date":"2019-11-06T00:47:26.000Z","updated":"2019-11-06T00:50:48.466Z","comments":true,"path":"2019/11/06/leetcode11/","link":"","permalink":"http://yoursite.com/2019/11/06/leetcode11/","excerpt":"","text":"LeetCode 11 盛最多水的容器题目：给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 我们知道，面积是等于高度乘以宽度，当宽度一定时，高度是由较短的一边来决定的，如果我们想去使面积增加，只有去往里移动较短的板，面积才有可能增加，（不用考虑横坐标减小的问题，因为当前的max是一直在比较中的）因为如果移动较长的板，此时的高度可能还是由较短的一段决定，而移动较短的板，下一个板可能会变长，进而使面积增加。 同时也可以看出这道题与最大值无关，计算公式应该是 Math.min(height[head], height[tail]) * (tail - head),head和tail都出来，双指针不要太明显因为每次接水面积的高是两个指针中指向的值较小的那个，所以为了求最大值，我们每次向中间移动的指针也应该是辣一个 12345678910111213141516171819int maxArea(vector&lt;int&gt;&amp; height) &#123; if(height.empty() || height.size() &lt; 2) return 0; int left = 0, right = height.size() - 1; // 左右指针 int max = 0; // 答案，动态比较 while (left &lt; right) &#123; int temp; if (height[left] &lt; height[right]) &#123; // 左边短当前总面积就是左边高度*底长 temp = height[left] * (right - left); ++left; // 左边指针往后找，看有没有比当前长的 &#125; else &#123; // 同理 temp = height[right] * (right - left); --right; &#125; max = max &lt; temp ? temp : max; // 比较当前面积和历史最大面积 &#125; return max;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer66. 构建乘积数组（不用除法） P312","slug":"剑指offer66","date":"2019-11-03T02:49:38.000Z","updated":"2019-11-03T02:57:37.421Z","comments":true,"path":"2019/11/03/剑指offer66/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer66/","excerpt":"","text":"剑指offer66. 构建乘积数组（不用除法） P312题目：给定一个数组A[0, 1, …, n-1]，请构建一个数组B[0, 1, …, n-1]，其中B中的元素B[i] =A[0]×A[1]×… ×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 其实也是两点法的思想。 123令 i左边乘积，C[i] = a[0] * a[1] *…* a[i-1]; i右边乘积 D[i] = a[i+1] * a[i+2] *…* a[n-2]*a[n-1];从左到右算： C[i] = c[i-1] * a[i-1]; 从右到左 算D[i] = D[i+1]*a[i+1] // 数组copy存最后的结果 12345678910111213141516void BuildProductionArray(const vector&lt;int&gt; nums, vector&lt;int&gt; &amp;copy) &#123; if (nums.size() != copy.size() || nums.size() &lt; 2) return; copy[0] = 1; for (int i = 1; i &lt; nums.size(); ++i) &#123; copy[i] = copy[i - 1] * nums[i - 1]; // 第一次遍历可以省略temp变量 &#125; int temp = 1; // 是右边i之后所有元素的乘积 for (int i = nums.size() - 2; i &gt;= 0; --i) &#123; //copy[i]= copy[i+1]*nums[i+1];不能这样,因为copy[i+1]里包含了num[i] temp *= nums[i + 1]; copy[i] *= temp; // 原来的copy存的是左边的乘积，再乘以右边乘积temp &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指offer65.不用加减乘除做加法 P310.","slug":"剑指offer65","date":"2019-11-03T02:49:34.000Z","updated":"2019-11-03T02:56:00.910Z","comments":true,"path":"2019/11/03/剑指offer65/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer65/","excerpt":"","text":"剑指offer65. 不用加减乘除做加法 P310.题目：写一个函数，求两个整数之和，要求在函数体内不得使用＋、－、×、÷ // 把相加结果分为进位和不计进位两个结果 ，这里用递归感觉容易理解 123456789int addSum(int a, int b) &#123; if (a == 0) return b;// if (b == 0) return a; 最后等来的肯定是进位先为0，因为进位是靠与运算的，非进位是异或 int no_carry_num = 0, carry_num = 0; // 存非进位结果，进位结果 no_carry_num = a ^ b; // 异或运算之后存储非进位 carry_num = (a &amp; b) &lt;&lt; 1;// 用&amp;看此位是否向高位提供进位，最后左移把进位给高位 return addSum(carry_num, no_carry_num); // 递归进位和不计进位的值&#125; 2. 不用新变量，交换两个变量a、b的值 P312 1234基于加减法 基于异或 a = a + b; a = a ^ b;b = a – b; b = a ^ b;a = a – b; a = a ^ b;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"剑指Offer63. 股票最大利润 P304","slug":"剑指offer63","date":"2019-11-03T02:49:31.000Z","updated":"2019-11-03T02:53:30.650Z","comments":true,"path":"2019/11/03/剑指offer63/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer63/","excerpt":"","text":"剑指offer63. 股票最大利润 P304题目：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖交易该股票可能获得的利润是多少？例如一只股票在某些时间节点的价格为{9, 11, 8, 5,7, 12, 16, 14}。如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。 不同条件的股票问题在leetcode 上有大神做了详细的对比总结，参考：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems 在这里只列出来简单的两个情况：1.只能买卖一次 .2. 不限买卖次数。其它股票问题见笔者leetcode题解文档。 1. 买卖一次 12345678910111213int stock(const int *nums, int len) &#123; if (nums == NULL || len &lt; 2) return 0; int ans = INT_MIN; // 头文件 climits int min_buy_value = nums[0]; // 第i之前买入的最低价 // nums[i] - min_buy_value表示第i天股票卖出的利润 // ans 取利润最大值 for (int i = 1; i &lt; len; ++i) &#123; // dp_sail[i] = nums[i] - min_buy_value; =右边没有用到dp，所以不用开dp数组 ans = (nums[i] - min_buy_value) &gt; ans ? (nums[i] - min_buy_value) : ans; min_buy_value = nums[i] &lt; min_buy_value ? nums[i] : min_buy_value; &#125; return ans;&#125; 2. 买卖不限次数（后缀为0表示卖出，为1表示买入） 1234int T_ik0_old = T_ik0; // 这个old是可以累计之前卖出的利润T_ik0 = Math.max(T_ik0, T_ik1 + price);T_ik1 = Math.max(T_ik1, T_ik0_old - price);","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指offer62.圆圈中最后剩下的数字（Josephuse约瑟夫环问题）P300","slug":"剑指offer62","date":"2019-11-03T02:49:27.000Z","updated":"2019-11-03T02:52:15.227Z","comments":true,"path":"2019/11/03/剑指offer62/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer62/","excerpt":"","text":"剑指offer62. 圆圈中最后剩下的数字（Josephuse约瑟夫环问题） P300题目：0, 1, …, n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 方法1. 循环链表 （C++官网说list不是循环链表 ， 但是为啥所有博客都说是循环呢？ ） 12345678910111213141516171819202122232425int LastRemaining_Solution(int n, int k) &#123; if (n &lt; 1 || k &lt; 1) return -1; list &lt;int&gt; list_loop; // 用std::list 模拟循环链表 for (int i = 0; i &lt; n; ++i) &#123; // 初始创建链表 list_loop.push_back(i); &#125; list&lt;int&gt;::iterator p = list_loop.begin(); // 链表头 while (list_loop.size() != 1) &#123; // 没有删到只剩最后一共数 for (int i = 1; i &lt; k; ++i) &#123; // p找到当前要删的元素 ++p; if (p == list_loop.end()) p = list_loop.begin(); // 循环 &#125; list&lt;int&gt;::iterator p_next = ++p; // 用p_next缓存下一个元素，不能p_next = p+1 --p; // list 迭代器没有重载操作符 +，- 只能赋值 list_loop.erase(p); p = p_next; if (p == list_loop.end()) p = list_loop.begin(); // 不要忘了处理// for (list&lt;int&gt;::iterator io = list_loop.begin(); io != list_loop.end();++io) &#123;// printf(\" %d \", (*io));// &#125; &#125; return list_loop.front(); &#125; 方法2. 数学推导递归 n &gt; 1 : f（n）= （f(n-1)+ m ）% n; n = 1: f(n) = 0,//请参考http://www.360doc.com/content/19/0212/18/32116899_814506447.shtml 1234567891011int ysfdg(int n, int m) &#123; if (n == 1) return 0; else return (ysfdg(n - 1, m) + m) % n; // m是固定的，f函数里完全可以不带m，//不要被书上303页带m的式子唬住&#125;int ysf(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; else return ysfdg(n, m); &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer61. 扑克牌中的顺子 P298","slug":"剑指offer61","date":"2019-11-03T02:16:26.000Z","updated":"2019-11-03T02:48:25.857Z","comments":true,"path":"2019/11/03/剑指offer61/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer61/","excerpt":"","text":"剑指offer61. 扑克牌中的顺子 P298题目：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。 统计大小王的数量（0的个数），用来填补顺子里缺失的数。把5张牌排序，从后往前遍历，如果出现不连续的两个数a,b的话，b和a之间差几个数，就拿上一步统计的0来填补这个空缺。如果a，b一样而且不是0（大小王），证明肯定不连续 最后遍历完，如果0的个数非负，证明可以填补缺失。 12345678910111213141516171819bool isContinuous(int *nums, int len) &#123; if (nums == NULL || len &lt; 1 || len &gt; 5) return false; sort(nums, nums + len); // 排序！ int zeroCount = 0; // 大小王个数（0 的个数）（一副牌大小王能有无数个。。。。。） for (int i = 0; i &lt; len; ++i) &#123; if (nums[i] == 0) ++zeroCount; // 统计大小王数量 &#125; for (int i = len - 1; i &gt; 0; --i) &#123; if (nums[i] - nums[i - 1] &gt; 1 &amp;&amp; nums[i - 1] != 0) // 相邻两个数差值比1大, zeroCount -= (nums[i] - nums[i - 1] - 1);//大多少就用0来补救中间的差值 if (nums[i] == nums[i - 1] &amp;&amp; nums[i] != 0) // 出现对子，指定不行 return false; &#125; if (zeroCount &gt;= 0 ) return true; // 0够用 else return false;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer60. N个骰子的点数  P294","slug":"剑指offer60","date":"2019-11-03T02:16:20.000Z","updated":"2019-11-03T02:46:53.763Z","comments":true,"path":"2019/11/03/剑指offer60/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer60/","excerpt":"","text":"剑指offer60. n个骰子的点数 P294题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 实质就是一个动态规划。该问题具备DP的两个特征：最优子结构性质和子问题的重叠性。具体的表现在：(1)n个骰子的点数依赖于n-1个骰子的点数，相当于在n-1个骰子点数的基础上再进行投掷。(2)求父问题的同时，需要多次利用子问题。由此定义状态转移方程为f(n,k)表示n个骰子点数和为k时出现的次数，于是可得 f(n,k) = f(n−1,k−1)+f(n−1,k−2)+f(n−1,k−3)+f(n−1,k−4)+f(n−1,k−5)+f(n−1,k−6) n &gt;= 1且k&lt;=6n （点数和最大是6n，就是所有骰子都是6）右边的6个式子除了表示前n-1个骰子点数和为k-j（j属于1-6）外，还可以理解成最后一个骰子掷出来：1，2，3，4，5，6，分别把6种情况相加 初始状态是： f(1,1)=f(1,2)=f(1,3)=f(1,4)=f(1,5)=f(1,6)=1 123456789101112131415161718192021222324const int max_size = 6; // 骰子的面数，下面循环里max_size * n表示最大的和void FindSum(int n) &#123; if (n &lt; 1) return; int dp[n + 1][max_size * n + 1]; // 最好用new memset(dp, 0, sizeof(dp)); for (int j = 1; j &lt;= max_size; ++j) // 初始状态 dp[1][j] = 1;//下面第二层for里从int sum 到 dp[i][j]+=sum的5行实际上就是dp[i][j] += (dp [i - 1][j - 1] + dp [i - 1][j - 2] +dp [i - 1][j - 3] + dp [i - 1][j - 4] + dp [i - 1][j - 5]+ dp [i - 1][j - 6]);但是因为列索引j-k这些在j&lt;k的时候会失效，所以再搞个循环只累加列索引大于0时候的dp for (int i = 2; i &lt;= n; ++i) &#123; for (int j = i; j &lt;= max_size * n; ++j) &#123; // j 从 i开始因为和最小是全掷出来1 int sum = 0; for (int k = 1; k &lt;= max_size; ++k) &#123; if (j - k &gt;= 0) sum += dp[i - 1][j - k]; &#125; dp[i][j] += sum; &#125; &#125; int sum_n = 1; // n个骰子一共出现多少个数字和 dp[n][i] != 0 表示和是i for (int i = 2; i &lt;= max_size * n; ++i) sum_n += dp[n][i]; // 统计 数字和 一共多少种情况（分母） for (int i = n; i &lt;= max_size * n; ++i) // 数字和范围从n到6n printf(\"%d: %e\\n\", i, 1.0 * dp[n][i] / sum_n); // 算概率 &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指Offer59. 队列中的最大值  P288","slug":"剑指offer59","date":"2019-11-03T02:16:14.000Z","updated":"2019-11-03T02:44:05.730Z","comments":true,"path":"2019/11/03/剑指offer59/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer59/","excerpt":"","text":"剑指offer59. 队列中的最大值 P2881. 滑动窗口的最大值 P288 题目：给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组{2, 3, 4, 2, 6, 2, 5, 1}及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为{4, 4, 6, 6, 6, 5}， 通常，er会这样考虑：记录当前窗口的最大值，然后移动的时候把最大值和下一个进入窗口的元素比较取最大的就好，但是如果最大值划出窗口了，拿什么比较呢？是不是应该拿上一个窗口第二大的元素和这个刚进入窗口的元素比较呢？ 这样就只用一个数据结构同时保存窗口最大，次大值（这两个就是书上所说的：有可能成为下一个窗口最大值的元素）就好了。可以用双端队列。每次读入一个新值，首先看最大值是不是已经划出窗口，如果是，把次大值和新值比较，更新队列，不是，把最大值比较新值，更新队列。因为要比较上一个最大值是不是划出窗口，所以队列存的是索引。用i - dq_index.front() &gt;= k判别当前最大是不是划出窗口了。队头存的是当前窗口的最大值的索引，（不要误认为队列中元素个数保持&lt;=2，不管是否更新队列，都把当前元素入队） 123456789101112131415161718192021222324vector&lt;int&gt; maxInWindows(const vector&lt;int&gt; nums, int k) &#123; // k是窗口大小 vector&lt;int&gt; v; // 返回最大值序列 if (nums.size() &lt; k || k &lt; 1 || nums.size() &lt; 1) return v; deque&lt;int&gt; dq_index; // 双端队列放的是索引，// 用i - dq_index.front() &gt;= k判别当前最大是不是划出窗口了 for (int i = 0; i &lt; k; ++i) &#123; // 处理第一个窗口 while (!dq_index.empty() &amp;&amp; nums[i] &gt; nums[dq_index.back()]) dq_index.pop_back(); dq_index.push_back(i); &#125; v.push_back(nums[dq_index.front()]); for (int i = k ; i &lt; nums.size(); ++i) &#123; // 从第k个值到结尾 while (!dq_index.empty() &amp;&amp; nums[i] &gt; nums[dq_index.back()]) dq_index.pop_back(); // 当前值比队列尾部元素大，弹出尾部 if (!dq_index.empty() &amp;&amp; i - dq_index.front() &gt;= k ) //队头划出窗口 dq_index.pop_front(); dq_index.push_back(i); // 不管是否更新队列，都把当前元素入队 v.push_back(nums[dq_index.front()]); &#125; return v;&#125; 2. 队列的最大值 P292 （实现一个队列，并在O(1)时间找出最大的队列元素） 1234567891011121314151617181920212223242526272829303132333435363738394041template&lt;typename T&gt; class QueueWithMax &#123; private : struct InternalData&#123; int index; // 出队时比较索引大小，以此更新max_dq; T number; // 入队时比较数据大小 &#125;; int index; queue &lt;InternalData&gt; data_dq; deque &lt;InternalData&gt; max_dq; public: QueueWithMax()&#123; index = 0; &#125;; ~QueueWithMax()&#123;&#125;; void push_back(T num) &#123; InternalData data; // 不可以new data.index = index; data.number = num; ++index; data_dq.push(data); // 下面3行和上面滑动窗口一样 ，插入最大的 while (!max_dq.empty() &amp;&amp; max_dq.back().number &lt; num) max_dq.pop_back(); max_dq.push_back(data); &#125; void pop_front() &#123; if (data_dq.empty()) throw \"queue is empty!\"; // 出队的时候，要用索引判断data队头是不是当前最大的，是的话当前max也要出队 if (data_dq.front().index == max_dq.front().index) &#123; max_dq.pop_front(); &#125; data_dq.pop(); &#125; // 因为测试Test函数形参声明模板类是const QueueWithMax&lt;int&gt;&amp; queue // 一个const对象不能调用它的non-const成员函数 // const在成员函数右边表示不能修改成员变量 // 前面两个void函数在测试中是在main中直接调的，queue没有用const修饰 T max() const&#123; if (max_dq.empty()) throw \"queue is empty!\"; return max_dq.front().number; &#125;&#125;;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"栈&队列","slug":"栈-队列","permalink":"http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"}]},{"title":"剑指Offer58. 翻转字符串 P284","slug":"剑指offer58","date":"2019-11-03T02:16:11.000Z","updated":"2019-11-03T02:41:15.595Z","comments":true,"path":"2019/11/03/剑指offer58/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer58/","excerpt":"","text":"剑指offer58. 翻转字符串 P284 题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 123 (1) 可以用string一个从前一个从后+ (2) 用栈存string （3） 书上的方法，先反转整个数组，然后反转每个单词。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748char* ReverseSentence(char *pData)&#123; if(pData == nullptr) return nullptr; char *pBegin = pData; char *pEnd = pData; while(*pEnd != '\\0') // 找输入字符串的结尾 pEnd ++; pEnd--; // 翻转整个句子 Reverse(pBegin, pEnd); // 翻转句子中的每个单词 pBegin = pEnd = pData; while(*pBegin != '\\0') &#123; if(*pBegin == ' ') // 跳过空格 &#123; pBegin ++; pEnd ++; &#125; else if(*pEnd == ' ' || *pEnd == '\\0') // 句子中间遇到空格，或者遍历结束 &#123; Reverse(pBegin, --pEnd); // 反转begin和end之间的单词 pBegin = ++pEnd; &#125; else pEnd ++; // begin和end之间还不是一个单词 &#125; return pData;&#125;void Reverse(char *pBegin, char *pEnd) // 反转数组&#123; if(pBegin == nullptr || pEnd == nullptr) return; while(pBegin &lt; pEnd) &#123; char temp = *pBegin; *pBegin = *pEnd; *pEnd = temp; pBegin ++, pEnd --; &#125;&#125; 面试题58（二）： 左旋转字符串 P286 题目：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”。 方法1：书上方法 1234567891011121314151617181920212223char* LeftRotateString(char* pStr, int n)&#123; if(pStr != nullptr) &#123; int nLength = static_cast&lt;int&gt;(strlen(pStr)); if(nLength &gt; 0 &amp;&amp; n &gt; 0 &amp;&amp; n &lt; nLength) &#123; char* pFirstStart = pStr; char* pFirstEnd = pStr + n - 1; char* pSecondStart = pStr + n; char* pSecondEnd = pStr + nLength - 1; // 翻转字符串的前面n个字符 Reverse(pFirstStart, pFirstEnd); // 翻转字符串的后面len-n个字符 Reverse(pSecondStart, pSecondEnd); // 翻转整个字符串 Reverse(pFirstStart, pSecondEnd); &#125; &#125; return pStr;&#125; 方法2： string 分割之后+ 1234567891011121314151617181920212223char *LeftRotateString(char *in, int k) &#123; if (in == NULL) return NULL; int len = 0; char *p = in; while((*p) != '\\0') &#123; ++p; ++len; &#125; if (k == 0 || k &gt;= len) return in; string strfront = \"\"; string strback = \"\"; for (int i = 0; i &lt; k; ++i) &#123; strfront += in[i]; &#125; for (int i = k; i &lt; len; ++i) &#123; strback += in[i]; &#125; char ans[len]; // 这里不能用char *ans ,, 原因见下面（string和char*转换问题） strcpy(ans, (strback + strfront ).c_str()); return ans;&#125; char* c;string s=”1234”;c = s.c_str(); //c最后指向的内容是垃圾,因为s对象被析构,其内容被处理应该这样用：char c[20];string s=”1234”;strcpy(c,s.c_str());返回 c","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"剑指Offer57. 连续数组中和为S的数字 P280","slug":"剑指offer57","date":"2019-11-03T02:16:08.000Z","updated":"2019-11-03T02:36:48.765Z","comments":true,"path":"2019/11/03/剑指offer57/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer57/","excerpt":"","text":"剑指offer57. 连续数组中和为s的数字 P280 一个递增序列中，找出任意两个数和为s （两点法，前后同时走）P280 输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）P282如： 输入s=15 1+2+3+4+5=4+5+6=7+8= 15 // 还是两点法，small指向最小的，big指向最大的，只不过两个同方向运动 ，sum存两者之间的所有数字和， small前进时sum是减少的，big前进，sum是增加的 123456789101112131415161718192021222324void FindContinuousSequence(int num) &#123; if (num &lt; 2) return; int small = 1, big = 2; // 左右指针初始值 int sum = 3; // small 到 big的和 while (small &lt;= (num + 1) / 2) &#123; // sum=num时前进的是small，所以最好用small比较 if (sum == num) &#123; for (int i = small; i &lt;= big; ++i) &#123; // 打印 printf(\"%d \",i); &#125; printf(\"\\n\"); sum -= small; // small前进sum是减少的 ++small; // 要前进，不然死循环 &#125;else if (sum &lt; num) &#123; // sum小，前进大指针big ++big; sum += big; &#125;else &#123; sum -= small; ++small; // sum 比给定num大，small前进 &#125; &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"查找","slug":"查找","permalink":"http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"剑指Offer56. 数组中数字出现的次数 P275","slug":"剑指offer56","date":"2019-11-03T02:16:05.000Z","updated":"2019-11-03T02:35:23.784Z","comments":true,"path":"2019/11/03/剑指offer56/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer56/","excerpt":"","text":"剑指offer56. 数组中数字出现的次数 P2751. 数组中只出现一次的1个数字，其他数字出现两次， 直接拿0和nums中每个数字异或得到结果。 2. 数组中只出现一次的两个数字 p275 （两个数字只出现一次，其余的出现两次） 在1的基础上，把0和nums异或。得到的数肯定不是0，因为两个数不想等。那么找到这个结果二进制里的1位的索引。这两个数在这位上一定一个是0另一个是1。那么把数组根据这位是0或者1分成两个数组。分别对两个数组异或，得到两个结果就行。 12345678910111213141516171819202122232425262728bool is1(int num, int n) &#123; // 判断倒数第n位是不是1 unsigned int p = 1; p = p &lt;&lt; n; if (p &amp; num) return true; else return false;&#125;void FindNumsAppearOnce(int *nums, int len, int &amp;flag, int &amp;flag2) &#123; if (nums == NULL || len &lt; 2) return; flag = 0; // 和nums元素异或得到两个答案的异或值 for (int i = 0; i &lt; len; ++i) &#123; flag ^= nums[i]; &#125; unsigned int p = 1; int index_1 = 0; // 异或之后的结果在倒数第几位 while (p) &#123; // 从右到左查找上一部结果，倒数第n位是1 if (flag &amp; p) break; ++index_1; p = p &lt;&lt; 1; &#125; flag = 0; //两个结果分别存两个子数组的异或结果（划分条件是倒数第n位是不是1） flag2 = 0; for (int i = 0; i &lt; len; ++i) &#123; if (is1(nums[i], index_1)) flag ^= nums[i]; else flag2 ^= nums[i]; &#125;&#125; 3. 数组中唯一只出现一次的数字，其他数字出现三次 P278 如果一个数字出现三次，那么它的二进制的每一位也出现三次，那么把这些数的二进制对应位的和加起来一定 %3=0。如果在32位中，比如第1位和%3=0，说明ans的这一位是0，如果%3不是0，说明这一位是1. 最后统计32位就能还原出ans 12345678910111213141516171819202122232425bool isAnsValid = false;int FindNumberAppearingOnce(int *nums, int len) &#123; if (nums == NULL || len &lt; 1) return 0; int bits[32]; memset(bits, 0, sizeof(bits)); for (int i = 0; i &lt; len; ++i) &#123; unsigned int p = 1; for (int j = 31; j &gt;= 0; --j) &#123; int bit = p &amp; nums[i]; if (bit != 0) &#123; bits[j] += 1; //不能加上p&amp;nums[i]结果不只是0or1，p的1跑到高位了！ &#125; p = p &lt;&lt; 1; &#125; &#125; int ans = 0; for (int i = 0; i &lt; 32; ++i) &#123; ans = ans &lt;&lt; 1; ans += bits[i] % 3; // 把ans根据bits数组里的和拼接起来 &#125; isAnsValid = true; return ans; // 10进制结果 &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"位运算","slug":"位运算","permalink":"http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"查找","slug":"查找","permalink":"http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"剑指offer55.二叉树的深度，平衡二叉 P271","slug":"剑指offer55","date":"2019-11-03T02:16:01.000Z","updated":"2019-11-16T02:48:12.227Z","comments":true,"path":"2019/11/03/剑指offer55/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer55/","excerpt":"","text":"剑指offer 55. 二叉树的深度，平衡二叉 P271题目：输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 1. 普通二叉树的深度 P271 123456789// 一棵二叉树的深度：是左右子树深度较大的+1int TreeDepth(const BinaryTreeNode *root) &#123; if (root == NULL) return 0; int left = TreeDepth(root -&gt; m_pLeft); int right = TreeDepth(root -&gt; m_pRight); return (left &gt; right ? left : right) + 1; &#125; 2. 判断是不是平衡二叉树 P273 1234567891011121314151617// 实际上是后根遍历模板，比书上的先根少了重复遍历bool IsBalanced_Solution(const BinaryTreeNode *root) &#123; if (root == NULL) return true; if (root -&gt; m_pLeft != NULL) IsBalanced_Solution(root -&gt; m_pLeft); if (root -&gt; m_pRight != NULL) IsBalanced_Solution(root -&gt; m_pRight); int leftdepth = TreeDepth(root -&gt; m_pLeft); int rightdepth = TreeDepth(root -&gt; m_pRight); int sub = leftdepth - rightdepth; // 每个节点左右子树深度差&lt;=1 if ( sub &lt; -1 || sub &gt; 1) return false; return true;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer54. 二叉搜索树的第K大个节点 P269","slug":"剑指offer54","date":"2019-11-03T02:15:58.000Z","updated":"2019-11-03T02:29:38.491Z","comments":true,"path":"2019/11/03/剑指offer54/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer54/","excerpt":"","text":"剑指offer54. 二叉搜索树的第k大个节点 P269题目：给定一棵二叉搜索树，请找出其中的第k大的结点。 中序遍历BST就是有序数列 1234567891011121314151617181920212223const BinaryTreeNode* KthNode(const BinaryTreeNode* pRoot, unsigned int k) // 主调函数&#123; if(pRoot == nullptr || k == 0) return nullptr; return inorder(pRoot, k);&#125;// 中序模板const BinaryTreeNode* inorder (const BinaryTreeNode* root, unsigned int&amp; k)&#123; if (root == NULL) return NULL; BinaryTreeNode* resu = NULL; resu = inorder(root-&gt;left, k); if (k == 1) resu = root; //真正赋值的地方只有这 k--; if(k &gt; 0) resu = inorder(root-&gt;right, k); return resu;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"查找","slug":"查找","permalink":"http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"剑指Offer53. 在排序数组中查找满足条件的数字 P263","slug":"剑指offer53","date":"2019-11-03T02:15:55.000Z","updated":"2019-11-03T02:27:47.534Z","comments":true,"path":"2019/11/03/剑指offer53/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer53/","excerpt":"","text":"剑指offer53. 在排序数组中查找满足条件的数字 P263题目：统计一个数字在排序数组中出现的次数。例如输入排序数组{1, 2, 3, 3, 3, 3, 4, 5}和数字3，由于3在这个数组中出现了4次，因此输出4。 在排序的数组里找第1个XX，都是在二分查找的模板下，在if（==）那里为真时，比较mid前一个数是不是满足某种条件，再递归。 二分查找，start&gt;end时，查找失败 1. 统计一个数字在排序数组中出现的次数P263 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//找数组中第一个k的索引 （看两个**注释哪里，其实就是在二分查找成功模板） findFirstK(int *nums, int k, int start, int end) &#123; if (start &gt; end) return -1; // 数组中没有k int mid = ((end - start) &gt;&gt; 1) + start; if (nums[mid] == k) &#123; // ****** 相等条件 if (mid == 0) return mid; // 索引是0肯定是第一个k else if (nums[mid - 1] == k) &#123; // mid上一个也是k，说明第一个k在左半边 end = mid - 1; &#125;else&#123; // mid上一个不是k，说明第一个k是mid return mid; &#125; &#125; else if (nums[mid] &gt; k) &#123; // ******左右递归条件 end = mid - 1; &#125; else &#123; start = mid + 1; &#125; return findFirstK(nums, k, start, end);&#125; // 找数组中最后一个k的索引 int findLastK(int *nums,int len, int k, int start, int end) &#123; if (start &gt; end) return -1; int mid = ((end - start) &gt;&gt; 1) + start; if (nums[mid] == k) &#123; if (mid == len - 1) return mid; // 肯定是最后一个 else if (nums[mid + 1] == k) &#123; // 右边还有k start = mid + 1; else return mid; &#125; else if (nums[mid] &gt; k) &#123; // 递归条件 end = mid - 1; &#125; else start = mid + 1; return findLastK(nums, k, start, end);&#125; int findK(int *nums,int len, int k) &#123; // 主调函数 if (nums == NULL) return 0; int first_index_of_k = findFirstK(nums, k, 0, len - 1); // 第一个k出现的位置 int last_index_of_k = findLastK (nums, k, 0, len - 1); // 最后一个k出现的位置//数组只有一个k时，两个递归返回索引值一样 if (first_index_of_k &gt; -1 &amp;&amp; last_index_of_k &gt; -1) return last_index_of_k - first_index_of_k + 1; else return 0; // 数组没有k&#125; 2. 0 n缺失的数字 P266（n是长度数值在0n之间取，一个数字只出现一次，且有序） 12345678910111213141516// 转换成在排序数组中找到第一个nums[i] != i的数。int findCore(const int *nums, int len, int start, int end)&#123; if (start &gt; end) return -1; int mid = ((end - start) &gt;&gt; 1) + start; if (nums[mid] != mid ) &#123; if (mid == 0 || nums[mid - 1] == mid - 1) return mid; // 这里有特判0 if (nums[mid - 1] != mid - 1) &#123; end = mid - 1; &#125; &#125; else&#123; start = mid + 1; if(start == len) return len; //到最后发现所有i都等于nums[i],缺失的数就是n &#125; return findCore(nums, len, start, end);&#125; 用等差数列和减去sum，时间复杂度是O(n)，二分是logN； 3. 排序数组中数组和下标相等的元素 P267 1234567891011// nums[i] = i，那么索引小于i的j都满足 nums[j] &lt; j;大于i的相反 int findCore(const int *nums, int start, int end)&#123; if (start &gt; end) return -1; // 没有找到符合条件 int mid = ((end - start) &gt;&gt; 1) + start; if (nums[mid] == mid) return mid; else if (nums[mid] &lt; mid) // 索引和对应的数比较，作为递归条件 start = mid + 1; else end = mid - 1; return findCore(nums, start, end);&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"查找","slug":"查找","permalink":"http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"剑指Offer52. 两个链表第一个公共节点 P253","slug":"剑指offer52","date":"2019-11-03T02:15:51.000Z","updated":"2019-11-03T03:13:10.013Z","comments":true,"path":"2019/11/03/剑指offer52/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer52/","excerpt":"","text":"剑指offer52. 两个链表第一个公共节点 P253题目：输入两个链表，找出它们的第一个公共结点。 统计两个链表的长度差sub，长的先走sub步，第二次遍历看两个工作指针是不是相等 1234567891011121314151617181920212223242526272829303132int getLength(ListNode *head) &#123; // 统计链表长度 if (head == NULL) return 0; int count = 0; ListNode *p = head; while (p != NULL) &#123; p = p -&gt; m_pNext; ++count; &#125; return count;&#125;// 找两个链表长度差值sub，长的先走sub步，然后一起出发看指针是否相同即可ListNode* FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2)&#123; int len1 = getLength(pHead1); int len2 = getLength(pHead2); if (len1 == 0 || len2 == 0) return NULL; ListNode *p, *q; int sub = len1 &gt; len2 ? (len1 - len2) : (len2 - len1); if (len1 &gt; len2) &#123; p = pHead1; q = pHead2; &#125; else &#123; p = pHead2; q = pHead1; &#125; while (sub--) p = p -&gt;m_pNext; while (p != q &amp;&amp; p != NULL &amp;&amp; q != NULL) &#123; p = p -&gt; m_pNext; q = q -&gt; m_pNext; &#125; if (p == NULL || q == NULL) return NULL; // 没有公共节点 else return p;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer51. 逆序对 P249","slug":"剑指offer51","date":"2019-11-01T08:13:57.000Z","updated":"2019-11-03T02:10:56.956Z","comments":true,"path":"2019/11/01/剑指offer51/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer51/","excerpt":"","text":"剑指offer51. 逆序对 P249题目：在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 12345678910111213141516171819202122232425262728293031323334353637383940归并的思想const int MAX = 100000000; // 模值 如果答案比较大，可以根据题意返回取模结果int mergeArray(int *nums, int *copy, int start, int end)&#123; if (start &gt;= end) return 0; int mid = ((end - start) &gt;&gt; 1) + start; int left = mergeArray(nums, copy, start, mid); //先递归才能保证下面左右子数组有序 int right = mergeArray(nums, copy, mid + 1, end); int count = 0; // 此次归并的逆序数 int i = mid, j = end, index_copy = end; // 从右到左遍历、对比 while (i &gt;= start &amp;&amp; j &gt; mid ) &#123; // 两段子数组都没有到头// 因为两段都排续了，第一段最右边nums[i]的比第二段最右num[j]的大，// 证明nums[i]比第二段剩下的所有（mid+1到j）都大，对于对应的逆序数就是第二段剩余的数字个数 if (nums[i] &gt; nums[j]) &#123; count += j - mid; // 第二段剩余个数 for (int k = mid + 1; k &lt;= j; ++k) // 在这里可以输出所有逆序对 printf(\"%d - %d, \", nums[i], nums[k]); copy[index_copy--] = nums[i--]; &#125; else &#123; copy[index_copy--] = nums[j--]; &#125; if (count &gt; MAX) count %= MAX; // 可选项，太大了的话就取给定的max模 &#125; while (i &gt;= start) copy[index_copy--] = nums[i--]; //有一段没有遍历完，加到copy while (j &gt; mid) copy[index_copy--] = nums[j--]; for (int i = start; i &lt;= end; ++i) nums[i] = copy[i]; // 在递归里上一次操作的是copy，但是下次比较的是nums，所以要把更新的数组重给nums return count + left + right;&#125;int InversePairs(int *nums, int len) &#123; if (nums == NULL || len &lt; 2) return 0; int *copy = new int[len]; for (int i = 0;i &lt; len; ++i) copy[i] = nums[i]; // 复制辅助数组 int ans = mergeArray(nums, copy, 0, len - 1); delete[] copy; return ans; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"剑指offer49.丑数 P240 Leetcode 264","slug":"剑指offer49","date":"2019-11-01T08:13:51.000Z","updated":"2019-11-03T02:14:39.644Z","comments":true,"path":"2019/11/01/剑指offer49/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer49/","excerpt":"","text":"剑指offer49.丑数 P240 leetcode 264题目：我们把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做第一个丑数。 丑数应该是另一个丑数乘以2，3，5得到的结果所以创建应该丑数表，里面是从小到大的丑数，每个丑数都是前面某个丑数乘以2，3或5得到的。 丑数初始打表，三个指针分别指向 乘以2，3，5的指针 把丑数表头和2，3，5分别相乘，最小的一定是下一个丑数，然后更新三个指针 1234567891011121314151617181920212223242526int min(int a, int b, int c) &#123; // 求三个数最小 return (a &lt; b ? a : b) &lt; c ? (a &lt; b ? a : b) : c ;&#125;int GetUglyNumber_Solution(int n) &#123; // 找到第n个丑数 if (n &lt; 1) return 0; int *uglytable = new int[n]; uglytable[0] = 1; int index2 = 0, index3 = 0, index5 = 0; // 分别指向当前235因子指向的table索引 for (int i = 1; i &lt; n; ++i) &#123; // 往后打丑数表，丑数值递增 // 3个索引分别跟三个因子相乘，一定是丑数，而且最小的一定是下一个丑数 int minof235 = min(uglytable[index2] * 2, uglytable[index3] * 3, uglytable[index5] * 5); uglytable[i] = minof235;//更新三个索引，小于当前丑数的时候，索引肯定是小的，所以用while一直找，if效率低 While (minof235 &gt;= uglytable[index2] * 2) ++index2; While (minof235 &gt;= uglytable[index3] * 3) ++index3; While (minof235 &gt;= uglytable[index5] * 5) ++index5; &#125; int ans = uglytable[n - 1]; delete[] uglytable; return ans;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"剑指offer48.最长不含重复字符的子串 P236 Leetcode 3","slug":"剑指offer48","date":"2019-11-01T08:13:48.000Z","updated":"2019-11-03T02:05:44.516Z","comments":true,"path":"2019/11/01/剑指offer48/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer48/","excerpt":"","text":"剑指offer48. 最长不含重复字符的子串 P236 leetcode 3题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。 用压缩优化后的dp，（只用ans_cur一个变量存，不用数组） 12345678910111213141516171819202122232425262728293031323334int longestSubstringWithoutDuplication(const string str) &#123;if (str == \"\") return 0; int ans = 0, ans_cur = 0; // ans存当前最大的长度，ans_last存dp[i]长度 int hash[27]; // 存上一次这个字母出现的位置 fill(hash, hash + 27, -1); for (int i = 0; i &lt; str.length(); ++i)&#123; int temp = str[i] - 'a'; // 当前字符第一次出现，或者在这两个重复字符之间已经有别的重复字符出现， // 已经更新过当前的ans_cur了。 if (hash[temp] == -1 || i - hash[temp] &gt; ans_cur) &#123; // 后一个条件容易忽略！！！ ++ ans_cur; &#125; else &#123; ans_cur = i - hash[temp]; // 更新当前的dp[i]长度 &#125; ans = ans &gt; ans_cur ? ans : ans_cur; // 看历史最大长度和当前长度谁大 hash[temp] = i; // 更新这个字符最近一次出现的索引i &#125; return ans;&#125;解法2：用trick ：start变量来代替hash表 int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); // 用来记录字符上次出现的位置 int maxlen=0, start = -1; for (int i = 0; i != s.length(); i++)&#123; // s[i]字符上次出现的下标是否在start之后，若是，则重复了，则修改start为上一次s[i]的位置，从它后一位开始搜索 if (dict[s[i]] &gt; start) start = dict[s[i]]; dict[s[i]] = i; maxlen = max(maxlen, i - start); &#125; return maxlen; &#125;&#125;;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指offer47.礼物最大值（矩阵路径和最大最小）P233","slug":"剑指offer47","date":"2019-11-01T08:13:45.000Z","updated":"2019-11-03T02:03:52.693Z","comments":true,"path":"2019/11/01/剑指offer47/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer47/","excerpt":"","text":"剑指offer47 .礼物最大值（矩阵路径和最大最小）P233题目：在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格直到到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？ 此解法原为dp二维矩阵，此方法为优化dp矩阵为cols长的一维数组，解析见235页（手画的图，没办法贴上。。。） 状态转移方程： dp[j] = max(dp[j], dp[j-1]) + num;当前的上一行j对应路径和dp[j]，当前左边的路径和dp[j-1] 取最大的， 加上当前权重 1234567891011121314151617181920212223int findBiggestPathSum(const int *matrix, int rows, int cols) &#123; if (matrix == NULL || rows &lt; 1 || cols &lt; 1) return -1; int dp_cols[cols]; memset(dp_cols, 0, sizeof(dp_cols)); for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; cols; ++j) &#123; int up = 0; // 这两行是处理i，j有0的时候（下面方程有dp[j-1]） int left = 0; if (i &gt;= 1) &#123; // 两个if如果i，j不是0，就把上一列和上一行dp搬下来 up = dp_cols[j]; &#125; if (j &gt;= 1) &#123; left = dp_cols[j - 1]; &#125; dp_cols[j] = (left &gt; up ? left : up) + matrix[i * cols + j]; // 上面比较大小不加括号的话，返回不是up是up+martix！ &#125; &#125; return dp_cols[cols - 1]; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指offer46.把数字翻译成字符串 P231","slug":"剑指offer46","date":"2019-11-01T08:13:42.000Z","updated":"2019-11-03T02:00:07.932Z","comments":true,"path":"2019/11/01/剑指offer46/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer46/","excerpt":"","text":"剑指offer46 . 把数字翻译成字符串 P231题目：给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。 其实还是斐波那契问题，只不过要多加一个判断，看当前数字和前一个能不能组合成字母。因为要遍历数字的每个位数，所以可以转换成字符串处理。 状态转移方程: 如果当前元素和上一个元素可以组合成字母： dp[i] = dp[i - 1] + dp[i - 2]; 否则，当前数字只有一个选择，那当前种类就和i-1时种类一样 dp[i] = dp[i - 1];12345678910111213141516171819202122232425262728int transferNumberToString(int num)&#123; if (num &lt; 0) return 0; if (num &lt; 10) return 1; string str = to_string(num); // 转换成字符串 int len = str.length(); int *dp = new int[len]; // dp初始化 dp[0]= 1; dp[1] = 1; int temp = (str[0] - '0') * 10 + str[1] - '0'; if (temp &gt;= 10 &amp;&amp; temp &lt;= 25) dp[1] = 2; for (int i = 2; i &lt; len; ++i) &#123; int last = str[i - 1] - '0'; int cur = str[i] - '0' + last * 10; if (cur &gt;= 10 &amp;&amp; cur &lt;= 25) &#123; // 可以组成 dp[i] = dp[i - 1] + dp[i - 2]; &#125; else &#123; // 上一个字和自己组不成一个字母 dp[i] = dp[i - 1]; &#125; &#125; int ans = dp[len - 1]; delete[] dp; return ans;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指offer45.把数组排成最小(大)数 P227","slug":"剑指offer45","date":"2019-11-01T08:13:38.000Z","updated":"2019-11-03T01:56:24.633Z","comments":true,"path":"2019/11/01/剑指offer45/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer45/","excerpt":"","text":"剑指offer45 把数组排成最小(大)数 P227题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3, 32, 321}，则打印出这3个数字能排成的最小数字321323。 这道题是隐藏的大数问题，应该想到用字符串操作，难点在于找到一个新的比较规则来排序数组，其实整数不好比的话，字符串字典序比较很容易想到，按字典序排, 321 ，32，3 拼接起来刚好满足要求。（和书上做法不太一样，这里用string + 可能存在效率问题） 12345678910111213141516bool cmp(string a, string b) &#123; // 不是a &lt; b return a + b &lt; b + a; // 看两个字符串相加怎么样字典序最小&#125;string minNumber(vector&lt;int&gt; nums) &#123; // 原数组 vector&lt;string&gt; v_str; // 用来把整数转换成string存储 for (auto i : nums) &#123; v_str.push_back(to_string(i)); &#125; sort(v_str.begin(), v_str.end(), cmp); // 按字典序排, 321, 32，3 string ans = \"\"; // 直接加就行 for (auto i : v_str) &#123; // str =str+ \"a\"加的运算产生的是一个新的对象，再把结果返回， ans += i; // str += \"a\"涉及的是对象的引用，操作后返回引用，避免产生新对象。 &#125; return ans;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"剑指offer44.数字序列中某一位的数字 P225","slug":"剑指offer44","date":"2019-11-01T08:13:35.000Z","updated":"2019-11-03T01:52:46.316Z","comments":true,"path":"2019/11/01/剑指offer44/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer44/","excerpt":"","text":"剑指offer44. 数字序列中某一位的数字 P225题目：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数find求任意位对应的数字。 12345678910111213141516171819202122232425262728293031323334353637// 跳过前边的无用位，只在有用的位数上操作int powDigital(int bits)&#123; // 统计bits位的数一共有几个（bits=2，ans不是100，是90！） if (bits == 1) return 10; else return (int)pow(10, bits - 1) * 9; // 不要用pow，精度可能损失，自己累乘 &#125;// 统计第bits位开始的第一个数，1是0，2是10，3是100，4是1000……int beginOfNumbersOnBits(int bits) &#123; // 不要用pow，精度可能损失，自己累乘 if(bits == 1) return 0; int sum = 1; for(int i = 1; i &lt; bits; ++i) sum *= 10; return sum;&#125;int findCore(int index, int bits) &#123; // 811= 270*3（bits）+1 int number = beginOfNumbersOnBits(bits) + index / bits; // 370，（第369个数） int mod = index % bits; // 370这个数的第1位 for (int i = 1; i &lt; bits - mod; ++i) // 把370后面的几位消掉 number /= 10; return number % 10; // 最后得到37，取个位mod&#125;int find(int index) &#123; // 主调函数，输入1001 if (index &lt; 0) return -1; if (index &lt; 10) return index; int bits = 1; // 此时到达的位数 while (1) &#123; if (index &lt; bits * powDigital(bits)) &#123; // 811 &lt; 3* 900 (900个3位数，一共2700位) return findCore(index, bits); &#125; else &#123; index -= bits * powDigital(bits); // 把前边不必要的减掉 1001-10-180=811 ++bits; // 同时位数递增 &#125; &#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"剑指offer42.连续子数组的最大和 P220","slug":"剑指offer42","date":"2019-11-01T08:13:32.000Z","updated":"2019-11-03T01:47:58.552Z","comments":true,"path":"2019/11/01/剑指offer42/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer42/","excerpt":"","text":"剑指offer42 . 连续子数组的最大和 P220题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。 简单的动态规划 ，动态转移方程 ： i &gt; 0 : dp[i] = max(dp[i - 1] + nums[i], nums[i]); i = 0 : dp[0] = nums[0]123456789101112131415161718192021bool isAns = false; // 答案有效与否int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int dpSubSum(int nums[], int len) &#123;bool isAns = false; if (nums == NULL || len &lt; 1) &#123; return 0; &#125; int dp[len + 1]; dp[0] = nums[0]; int ans = dp[0]; for (int i = 1; i &lt; len; ++i)&#123; dp[i] = max(dp[i - 1] + nums[i], nums[i]); if (ans &lt; dp[i]) ans = dp[i]; &#125; isAns = true; return ans;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指Offer41. 数据流中的中位数  P214","slug":"剑指offer41","date":"2019-11-01T08:13:28.000Z","updated":"2019-11-01T08:23:59.533Z","comments":true,"path":"2019/11/01/剑指offer41/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer41/","excerpt":"","text":"剑指offer41. 数据流中的中位数 P214题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值 首先，题目说一个数据流，就证明可能不能一次读入内存（我们这里用一个数组模拟输入流） 如果将数组从中间一分为二，中间的一个（len是奇数）或者两个元素（len是偶数）左边都比他们小，右边都比他们大，前后两半部分不用排序，只用划分出来就行。那么最后在中间的就是中位数。左半部分是最大堆，右边是最小堆。 这个想法是使用两个堆（一个最大堆，一个最小堆）保存输入数据。 max_pq是一个大堆，以较小的值保存数据的前半部分，而min_pq是最小堆，以较大的值保存数据的后半个。 每次插入新值时，我们都会先比较它是否小于max_pq的顶部（前一半的最大值），如果是，则将其插入max_pq。 否则，它属于下半部分。 插入后，我们必须平衡前半部分和后半部分，以确保它们具有相同的长度或长度差仅为1,否则最后两个堆顶的元素不在最中间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445priority_queue &lt;int&gt; max_pq; //最大堆，其中最大元素堆顶也小于最小堆中任一元素priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; min_pq; // 最小堆，堆顶最小bool isAnsValid = false;// 返回0.0时有效与否void addHeap(int num) &#123; // 插入节点 if (max_pq.empty() || num &lt; max_pq.top()) &#123; // 先插入最大堆 max_pq.push(num); &#125; else &#123; // 当前值比最大堆顶还大，插入最小堆 min_pq.push(num); &#125; if (min_pq.size() &gt; max_pq.size() + 1) &#123; // 最小堆元素个数比最大的超过1，调整 int temp = min_pq.top(); min_pq.pop(); max_pq.push(temp); &#125; else if (max_pq.size() &gt; min_pq.size() + 1) &#123; // 同理 int temp = max_pq.top(); max_pq.pop(); min_pq.push(temp); &#125;&#125;double findCore() &#123; // 找中位数 if (!max_pq.empty()) &#123; isAnsValid = true; // 返回值有效 if (max_pq.size() == min_pq.size()) &#123; // len偶数，取均值 return (max_pq.top() + min_pq.top()) / 2.0; &#125; else &#123; // len奇数，取堆顶 return (max_pq.size() &gt; min_pq.size()) ? max_pq.top() : min_pq.top(); &#125; &#125; else 0.0; // 失败&#125;double findMidInList(int *nums, int len) &#123; if (nums == NULL || len &lt; 1) return 0.0; while (!max_pq.empty()) max_pq.pop(); // 清空堆 while (!min_pq.empty()) min_pq.pop(); for(int i = 0; i &lt; len; ++i)&#123; // 建堆 addHeap(nums[i]); &#125; return findCore();&#125; 扩展优先队列（堆）头文件：#include&lt; queue &gt;大根堆定义：priority_queue&lt; int &gt;pq小根堆定义：priority_queue&lt; int ,vector&lt; int &gt;,greater&lt; int &gt; &gt;pq（注意最后两个“&gt;”符号不要连在一起，否则很多编译器误认为是‘&gt;&gt;’运算符） 操作：push() 元素入队 pop() 队首元素出队 top() 取队首元素empty() 如果队列为空，则返回true（1），否则返回false（0）size() 返回优先队列中拥有的元素个数","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"堆","slug":"堆","permalink":"http://yoursite.com/tags/%E5%A0%86/"}]},{"title":"剑指Offer40. 最小的K个数 P209","slug":"剑指offer40","date":"2019-11-01T07:26:35.000Z","updated":"2019-11-01T08:11:28.869Z","comments":true,"path":"2019/11/01/剑指offer40/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer40/","excerpt":"","text":"剑指offer40. 最小的k个数 P209题目：输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 方法一：类似于上一题39， 同样基于Partition函数对数组进行划分，基于第k个元素调整，使得第k个索引之前的都比num[k]小, k之后的都比nums[k]大。左边的k个数字就是最小的k个数字，但是这些数字可能无序。 123456789101112131415161718192021Vector&lt;int&gt; findCore(int *nums,int len) &#123; // 主调函数vector&lt;int&gt; v; // 返回list if (!isValid(nums, len)) &#123; // 鲁棒性 return v; &#125; int mid = len &gt;&gt; 1; // 中位数索引 int start = 0; int end = len - 1; int index = Partition(nums, start, end); // 第一次划分 while (index != k - 1) &#123; // 出口 if (index &gt; k - 1) end = index - 1; else start = index + 1; index = Partition(nums, start, end); &#125; for(int i = 0; i &lt; k; ++i) v.push_back(nums[i]);&#125; 时间复杂度是 O(n), 不适合海量数据（快排必须一次性读入内存）而且会污染数组。 方法2： 最大堆 本方法使用于海量数据处理。大致思想是建一个K个数的大堆，每次拿一个数和堆顶元素比较，如果这个数比堆顶元素大，则必然不是最小的K个数，如果这个数比堆顶元素小，则与堆顶元素交换，然后在向下调整一次建成新的大堆，然后遍历所有的数，直到最小的K个数都进堆里。这样既可以保证堆中是存的目前的最小的k个数，还不用一次性把所有数据读入内存，每次只从磁盘取一个和堆顶比较即可。时间复杂度O(nlogk), 但是非常适用海量数据注意：最大的K个数—- 建小堆 最小的K个数—-建大堆 // 下面是自建大顶堆 或者允许的话，更简单的办法是用STL： 优先队列（见下一题） 123456789101112131415161718192021222324252627282930313233void AdjustDown(int* input, int k, int parent) &#123; if (input == NULL || k &lt;= 0) return; int child = 2 * parent + 1; while (child &lt; k) &#123; if ((child + 1 &lt; k) &amp;&amp; (input[child] &lt; input[child + 1])) ++child; if (input[child]&gt;input[parent]) &#123; Swap(&amp;input[child], &amp;input[parent]); parent = child; child = 2 * parent + 1; &#125; else break; &#125;&#125;void MinKNumber_op(int* input, int len, int k) &#123; assert(input); // 鲁棒性 int i = 0; for (i = (2 * k - 2) / 2; i &gt;= 0; i--) //利用前K个数建大堆 AdjustDown(input, k, i); // 遍历后边的数，如果小于堆顶元素则入堆 for (i = k; i &lt; len; i++) &#123; if (input[i] &lt; input[0]) &#123; Swap(&amp;input[i], &amp;input[0]); AdjustDown(input, k, 0); &#125; &#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆","slug":"堆","permalink":"http://yoursite.com/tags/%E5%A0%86/"}]},{"title":"剑指Offer39. 数组中出现次数超过一半的数字 P39","slug":"剑指offer39","date":"2019-11-01T07:26:30.000Z","updated":"2019-11-01T07:58:56.250Z","comments":true,"path":"2019/11/01/剑指offer39/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer39/","excerpt":"","text":"剑指offer39. 数组中出现次数超过一半的数字 P39题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1, 2, 3, 2, 2, 2, 5, 4, 2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。 1. 基于快排 （会污染数组）其实只要涉及顺序的问题，大多数都可以排序。这题可以建立在快排的基础上，每做一次划分之后，把当前划分元素的索引index返回，这个数就是整个数组第index小的数，如果index=len/2, 结束递归。因为出现次数超过数组长度一半的元素最后一定有一个在索引是len/2的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465bool ansIsValid = true; // 全局变量，=true时返回的0代表没有找到bool isValid(int *nums, int len)&#123; // 输入鲁棒性检查 if (nums == NULL || len &lt; 1) return false; return true;&#125;bool isMoreHalf(int *nums, int len, int num)&#123; //看最后找到的元素的个数是否真的超过一半 int count = 0; for (int i = 0; i &lt; len; ++i) &#123; if (nums[i] == num) ++count; &#125; if (count &lt;= len / 2) return false; // 必须 &gt; len / 2 才行！！ return true;&#125;int Partition(int *nums, int start, int end) &#123; //快排的一次划分，返回固定元素后的索引 int flag = nums[start]; int i = start, j = end; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt;= flag) --j; int rightmin = nums[j]; while (i &lt; j &amp;&amp; nums[i] &lt;= flag) ++i; nums[j] = nums[i]; nums[i] = rightmin; &#125; nums[start] = nums[i]; nums[i] = flag; return i; // i的位置不会变了&#125;int findCore(int *nums,int len) &#123; // 主调函数ansIsValid = true; // 默认答案无效，不仅下面鲁棒性要用，最后检验也要用 if (!isValid(nums, len)) &#123; // 鲁棒性 return 0; &#125; int mid = len &gt;&gt; 1; // 中位数索引 int start = 0; int end = len - 1; int index = Partition(nums, start, end); // 第一次划分 /* 为什么比的是索引而不是值，因为index前后一边大一边小是确定的 只有index到中间时，才能保证从头到中间，或者从中间到尾巴都是一个数 这样才能找到超过一半的数 */ while (index != mid) &#123; // 出口 if (index &gt; mid) end = index - 1; else start = index + 1; index = Partition(nums, start, end); // 选择左还是右划分 &#125; if (isMoreHalf(nums, len, nums[index])) &#123; // 检验是不是真的个数超过数组长度一半 ansIsValid = false; // 确实超过 return nums[index]; &#125; else &#123; return 0; &#125; &#125; 方法2： 比较个数差 （没有污染数组） 从个数入手，有一个数字出现次数超过一半，也就是说它比其他所有数字次数和都多。我们把这个数和其他数分成两组 “相对抗” , 用一个变量存数字res，另一个存次数count。遍历数组，当前数字和上一个相等，次数+1；不等，次数-1，如果次数减到0，把res更新为当前数字，count更新为1. 到最后因为我们要找的数次数比其他的和都多，那么它一定时最后一次把count设成1的数。 123456789101112131415161718192021222324252627282930bool isAns = true; // 判断return 0 时是不是有效 int findSBNumber(int nums[], int len) &#123; isAns = true; // 要在鲁棒性检查之前设置 if (nums == NULL || len &lt; 1) return 0; int ans = nums[0]; // 上文中的res int count = 1; for (int i = 0; i &lt; len; ++i) &#123; if (nums[i] != ans) &#123; --count; if (count == 0) &#123; count = 1; ans = nums[i]; &#125; &#125;else &#123; ++count; &#125; &#125; count = 0; for (int i = 0; i &lt; len; ++i) &#123; // 验证是不是真的个数超过一半 if (nums[i] == ans) ++count; &#125; if (count &lt;= len / 2) return 0; isAns = false; return ans;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer38. 字符串全排列、子集 P197","slug":"剑指offer38","date":"2019-11-01T07:26:26.000Z","updated":"2019-11-01T08:38:46.131Z","comments":true,"path":"2019/11/01/剑指offer38/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer38/","excerpt":"","text":"剑指offer38. 字符串全排列、子集 P197题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。 方法一 : 非递归方法（字典序，这种方法被用在STL库中）转载自：转载博客 对给定的字符集中的字符规定了一个先后关系，在此基础上规定两个全排列的先后是从左到右逐个比较对应的字符的先后。 [例]字符集{1,2,3},较小的数字较先,这样按字典序生成的全排列是: 123,132,213,231,312,321 一个全排列可看做一个字符串，字符串可有前缀、后缀。生成给定全排列的下一个排列：所谓一个的下一个就是这一个与下一个之间没有其他的。这就要求这一个与下一个有尽可能长的共同前缀。例如：如何得到346987521的下一个 从尾部往前找第一个P(i-1) &lt; P(i)的位置，最终找到6是第一个，记录下6的位置i-13 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1 从i位置往后找到最后一个大于6的数，最终找到7的位置，记录位置为m3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1 交换位置i-1和m的值 ： 3 4 7 9 8 6 5 2 1 倒序i-1位置后的所有数据： 3 4 7 1 2 5 6 8 9 12345678910111213141516171819bool cmp(char a, char b)&#123; if (a &lt; b) return true; else return false;&#125;void print(char *str, int len) &#123; if (str == NULL) return ; sort(str, str + len, cmp); // 按某种规则排序 while (1) &#123; printf(\"%s \\n\", str); // 一定要先打印，不然排序后的第一个序列打印不了 int first = len - 1; while (first &gt; 0 &amp;&amp; str[first] &lt; str[first - 1]) --first; // 倒序找第一个比后面小的数字 if (first == 0) break; // 如果倒序结束，都没有找到，说明序列完全递减，结束 int minBigger = first; // 从first位置出发，找比first-1大的数字里面的最小的 while (minBigger + 1 &lt; len &amp;&amp; str[minBigger + 1] &gt; str[first - 1]) ++minBigger; swap(str, minBigger, first - 1); // 交换两个值 reverse(str + first, str + len); // 倒置 &#125;&#125; 方法2：递归递归全排列 1 2 3 4 5 1，for循环将每个位置的数据交换到第一位 swap(1,1~5)2，按相同的方式全排列剩余的位 关于循环里面有递归可以这么想：在最外层的需求是要把当前序列的第一个数和后面的每一个都交换，显然递归是做不到的，只能用循环。在交换之后，要对除了当前子序列的第一个元素外的剩余元素做全排列，这显然是递归过程。两者是分层的嵌套关系 12345678910111213141516171819void prem(char *str, int start, int end) &#123; if (start &gt;= end) // 起始位置等于终止位置，自然不往下递归交换了，结束并输出 printf(\"%s \\n\", str); else &#123; for (int i = start; i &lt;= end; ++i) &#123; // 把起始位置和后面的位置依此交换 // sort(str + i, str + end + 1,cmp); 如果要按某种顺序输出，这里排序 swap(str, i, start); prem(str, start + 1, end); // 递归下一个位置 swap(str, i, start); &#125; &#125; &#125;void premation(char *str, int len) &#123; // 主调函数 if (str == NULL) return; prem(str, 0, len - 1); // 全排列的起始位置，终止位置&#125; 扩展: 求组合数（子集） 12345678910111213141516vector&lt; vector&lt;char&gt; &gt; zuhe(char *str) &#123; // 主调函数，返回二维list 存储所有子集 if (str == NULL) return NULL; vector&lt; vector&lt;char&gt; &gt; ans ; vector &lt;char&gt; t; // 存储当前遍历到的一个子集 DFS(str, 0, t, ans); return ans; &#125;void DFS(char* str, int index, vector &lt;char&gt; &amp;t, vector&lt; vector&lt;char&gt; &gt; &amp;ans) &#123; ans.push_back(t); // 第一次调用，存的空集 for (int j = index; j &lt; strlen(str); ++j) &#123; t.push_back(str[j]); // 当前数字加入当前子集中 DFS(str, j + 1, t, ans); // 递归下一个位置的数 t.pop_back(); // 回溯，当前子集舍弃当前数 &#125;&#125; 扩展： 1. 8个数放正方体的8个顶点，要求任意一个面的4个顶点和相等 2. 8皇后问题，8个皇后放在8*8棋盘，不能同行，同列，或者对角线 P200","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"剑指Offer37. 序列化，反序列化二叉树 P194","slug":"剑指offer37","date":"2019-11-01T07:26:23.000Z","updated":"2019-11-01T07:48:32.359Z","comments":true,"path":"2019/11/01/剑指offer37/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer37/","excerpt":"","text":"剑指offer37. 序列化，反序列化二叉树 P194（书上用的流操作）题目：请实现两个函数，分别用来序列化和反序列化二叉树。比如：下面这颗树的先序序列化是： 1 2 $ $ 3 $ $ ($表示空节点) 123 1 / \\2 3 // 序列化二叉树 ，用队列模拟流操作 123456789void serilize(BinaryTreeNode *root, queue &lt;char&gt; &amp;q) &#123; if (root == NULL) &#123; q.push('$'); return; &#125; q.push(root -&gt; m_nValue ); serilize(root -&gt; m_pLeft, ans); serilize(root -&gt; m_pRight, ans);&#125; // 反序列化二叉树 ,根据序列q，还原二叉树 123456789101112131415void reverseSerilize(BinaryTree **root, queue&lt;char&gt; &amp;q) &#123; if (q.empty()) return; if (q.fornt() == '$') &#123;//当前节点是空，无操作，因为下面在创建节点时左右节点默认空 q.pop(); return; &#125; *root = new BinaryTreeNode(); (*root) -&gt; m_nValue = q.front(); q.pop(); (*root) -&gt; m_pLeft = NULL; (*root) -&gt; m_pRight = NULL; reverseSerilize(&amp;((*root) -&gt; m_pLeft), q); reverseSerilize(&amp;((*root) -&gt; m_pRight), q);&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer36. 二叉搜索树BST转换成双向链表 P191","slug":"剑指offer36","date":"2019-11-01T07:26:19.000Z","updated":"2019-11-03T03:15:01.236Z","comments":true,"path":"2019/11/01/剑指offer36/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer36/","excerpt":"","text":"剑指offer36. 二叉搜索树BST转换成双向链表 P191题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 首先，牵扯到排序，就只能对BST中序遍历（这也是下面递归函数的模板）。另外，双向链表有左右两个指针，二叉树刚好左右两指针，通过对比显然可以用二叉树的left指针充当链表前驱指针，right指针充当后继指针。至于为什么要在递归函数中多一个lastnode，是因为一次指针变更操作，（除了涉及空节点的）操作节点一定是两个（一个指针指向另一个节点），所以需要给当前递归的操作节点显式地指明它的前驱或者后继。 // 主调函数 12345678910111213BinaryTreeNode *convert(BinaryTreeNode *proot) &#123; if (proot == NULL) return NULL; BinaryTreeNode *lastNode = NULL; // 前驱节点，最左叶节点前驱是NULL preOrderConvert(proot, &amp;lastNode); // 递归转换// 最后递归结束，lastnode指向的是链表的最右节点，但是应该返回最左的头结点//书上多一个判lastnode空，因为在书上函数开始没有判空 while (lastNode -&gt; m_pLeft != NULL) &#123; lastNode = lastNode -&gt; m_pLeft; &#125; return lastNode; // 返回双向链表左头节点&#125; // 递归转换，传入当前节点和当前节点前驱节点（实际上就是中序遍历模板） 123456789101112131415void preOrderConvert(BinaryTreeNode *root, BinaryTreeNode **lastNode) &#123; if (root == NULL) return; // 递归出口 if (root -&gt; m_pLeft != NULL) // 左递归 preOrderConvert(root -&gt; m_pLeft, lastNode); root -&gt; m_pLeft = *lastNode; // 当前节点前驱指针指向前驱节点 if ((*lastNode) != NULL) &#123; // 前驱节点不是空，前驱的后继节点指向当前节点 (*lastNode) -&gt; m_pRight = root; // 只有root是最左叶节点才不执行，没有前驱 &#125; (*lastNode) = root; // 更新前驱节点 if (root -&gt; m_pRight != NULL) // 右递归 preOrderConvert(root -&gt; m_pRight, lastNode); &#125; // 思考：把双向链表转换成BST ？","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer35. 复杂链表的复制 P187","slug":"剑指offer35","date":"2019-11-01T07:26:16.000Z","updated":"2019-11-01T07:42:28.632Z","comments":true,"path":"2019/11/01/剑指offer35/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer35/","excerpt":"","text":"剑指offer35. 复杂链表的复制P187题目：请实现函数ComplexListNode* Clone(ComplexListNode* pHead)，复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指向下一个结点外，还有一个m_pSibling 指向链表中的任意结点或者nullptr。 方法1： 空间方法是用hash表存（N，N^）的映射方法2： 时间方法分三步： 1 把复制后的节点N^接到N后边 2 设置每个N^的slibing指针 3. 将N和N^分开保存为原始链表和copy后的链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void cloneNodes(ComplexListNode *head) &#123; // 第一步：复制后的节点N^接到N后边 ComplexListNode *p = head; while (p != NULL) &#123; ComplexListNode *temp = new ComplexListNode(); temp -&gt; m_nValue = p -&gt; m_nValue; temp -&gt; m_pNext = p -&gt; m_pNext; p -&gt; m_pNext = temp; p = temp -&gt; m_pNext; &#125;&#125; void connectSiblingNodes(ComplexListNode *head) &#123; // 第二步：设置每个N^的slibing ComplexListNode *p = head; while (p != NULL) &#123; ComplexListNode *temp = p -&gt; m_pNext; if (p -&gt; m_pSibling != NULL) &#123; temp -&gt; m_pSibling = p -&gt; m_pSibling -&gt; m_pNext; &#125; else temp -&gt; m_pSibling = NULL; // 可以不写，m_pSibling默认的是null p = temp -&gt; m_pNext; &#125;&#125;ComplexListNode *reconnectNodes(ComplexListNode *head)&#123; // 第三步，拆分两个链表 ComplexListNode *newHead = head -&gt; m_pNext; // copy链表头 ComplexListNode *p = head, *cp = newHead; while (cp -&gt; m_pNext != NULL) &#123; p -&gt; m_pNext = cp -&gt; m_pNext; cp -&gt; m_pNext = cp -&gt; m_pNext -&gt; m_pNext; p = p -&gt; m_pNext; cp = cp -&gt; m_pNext; &#125; p -&gt; m_pNext = cp -&gt;m_pNext = NULL; return newHead;&#125;ComplexListNode* Clone(ComplexListNode* pHead) // 依次调用三个函数&#123; if (pHead == NULL) return NULL; cloneNodes(pHead); connectSiblingNodes(pHead); return reconnectNodes(pHead);&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer34. 二叉树路径和 P182","slug":"剑指offer34","date":"2019-11-01T07:26:13.000Z","updated":"2019-11-01T07:38:46.785Z","comments":true,"path":"2019/11/01/剑指offer34/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer34/","excerpt":"","text":"剑指offer34. 二叉树路径和 P182题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 // 主递归函数参数: 当前节点 上一步路径和 期待值 路径存储数组 123456789101112131415161718void DFS_FindPath(BinaryTreeNode *root, int sum, int k, vector&lt;int&gt; &amp;path) &#123; if (root == NULL || root -&gt; m_nValue + sum &gt; k) return ; // 当前路径和大于k，返回 path.push_back(root -&gt; m_nValue); // 否则，把节点加入path if (root -&gt; m_nValue + sum &lt; k) &#123; // 小于k，递归往下找， // 递归放在打印前就不用显示判断叶节点 DFS_FindPath(root -&gt; m_pLeft, sum + root -&gt; m_nValue, k, path); DFS_FindPath(root -&gt; m_pRight, sum + root -&gt; m_nValue, k, path); &#125;else &#123; // 等于k，打印路径path for (auto p : path) &#123; printf(\"%d \", p); &#125; printf(\"\\n\"); &#125; path.pop_back(); // 回溯，把当前节点移除，继续找&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer33. 二叉搜索树的后序遍历序列 P179","slug":"剑指offer33","date":"2019-11-01T07:26:09.000Z","updated":"2019-11-01T07:36:08.600Z","comments":true,"path":"2019/11/01/剑指offer33/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer33/","excerpt":"","text":"剑指offer33. 二叉搜索树的后序遍历序列 P179题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。 首先要明确的是：每一个子序列的最后一个数是根结点（end标识） 找到左子树子序列，左子树子序列可以通过从当前子序列开始索引start向后扫描，直到出现比根结点大的元素就停止（因为左子树子序列都是小于根节点的）； 剩下的子序列是右子树子序列（不包含子序列最后节点end也就是根节点），检查右子树子序列中所有元素是否都大于根结点元素，如果存在小于根节点的元素，则不满足二叉搜索树的定义，返回false. 递归地判断左子树和右子树是否是二叉搜索树。 1234567891011121314151617181920bool isBSTPostOrder(int *num, int start, int end) &#123; // 原始输入序列，子序列的首尾索引 if (num == NULL) return false; // 鲁棒性 （如果有主调函数可以放在主调里） if (start &gt;= end) return true; // 没有发现异常，两个成功相遇 int root = num[end]; // 根节点是最后一个节点 int i = start; // 开始索引 for (; i &lt; end; ++i) &#123; // 从开始索引找第一个比根大的节点，注意条件不能=end if (num[i] &gt; root) break; &#125; // 此时i存的是第一个比根大的节点的索引 for (int j = i + 1; j &lt; end ; ++j) &#123; // 从下一个位置出发，看右子树有没有比根小的 if (num[j] &lt; root) return false; &#125; // 递归左右子树看是否满足BST return (isBSTPostOrder(num, start, i - 1) &amp;&amp; isBSTPostOrder(num, i, end - 1)); &#125;// 注意：这个递归函数的end参数是子序列最后一个索引，调用的时候传的length - 1","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer32. 从上到下打印二叉树 P171（三种层次遍历的要求）","slug":"剑指offer32","date":"2019-11-01T07:26:06.000Z","updated":"2019-11-01T07:33:29.687Z","comments":true,"path":"2019/11/01/剑指offer32/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer32/","excerpt":"","text":"剑指offer32. 从上到下打印二叉树 P171（三种层次遍历的要求）1. 不分（换）行，从上到下打印二叉树 原始的层次遍历 123456789101112void PrintFromTopToBottom1(BinaryTreeNode *pRoot) &#123; // 不分行层次打印 if (pRoot == NULL) return; queue&lt;BinaryTreeNode* &gt; q; q.push(pRoot); while (!q.empty()) &#123; // 层次遍历 BinaryTreeNode *p = q.front(); q.pop(); printf(\"%d \", p -&gt; m_nValue); if (p -&gt; m_pLeft) q.push(p -&gt; m_pLeft); if (p -&gt; m_pRight) q.push(p -&gt; m_pRight); &#125;&#125; 2. 分行（层）打印二叉树 两个变量分别存当前行的节点个数，和下一行节点个数 12345678910111213141516171819202122232425void PrintFromTopToBottom2(BinaryTreeNode *pRoot) &#123; // 分行层次打印 if (pRoot == NULL) return; queue&lt;BinaryTreeNode* &gt; q; q.push(pRoot); int currentLayCount = 1, nextLayCount = 1; // 分别存当前行和下一行的节点数 while (!q.empty()) &#123; currentLayCount = nextLayCount; // 每一次打印一行时，更新两个变量 nextLayCount = 0; while (currentLayCount &gt; 0) &#123; // 打印当前行 BinaryTreeNode *p = q.front(); q.pop(); printf(\"%d \", p -&gt; m_nValue); if (p -&gt; m_pLeft) &#123; q.push(p -&gt; m_pLeft); nextLayCount++; &#125; if (p -&gt; m_pRight) &#123; q.push(p -&gt; m_pRight); nextLayCount++; &#125; --currentLayCount; &#125; printf(\"\\n\"); &#125; &#125; 3 .之字形打印二叉树 题目：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印 其他行以此类推。 用两个栈交替存当前行和下一行，偶数行的子节点从左往右入栈（保证下一行从右到左输出），奇数行的与之相反。 12345678910111213141516171819202122232425262728293031323334void PrintFromTopToBottom(BinaryTreeNode *pRoot) &#123; // 之字型打印二叉树 if (pRoot == NULL) return; stack&lt;BinaryTreeNode* &gt; s[2]; //两个辅助栈，0代表偶数行，（省去判奇偶的操作） int current = 0, next = 1; // 当前和下一行要访问的栈是s[0]还是s[1] s[0].push(pRoot); // 默认根节点是偶数行 while (!s[0].empty() || !s[1].empty()) &#123; BinaryTreeNode *node = s[current].top(); // 当前栈出栈 s[current].pop(); printf(\"%d \", node -&gt; m_nValue); if (current == 0) &#123; // 0栈是正向,从左到右入栈 if (node -&gt; m_pLeft) &#123; s[next].push(node -&gt; m_pLeft); &#125; if (node -&gt; m_pRight) &#123; s[next].push(node -&gt; m_pRight); &#125; &#125; else &#123; // 1栈是反向 从右到左入栈 if (node -&gt; m_pRight) &#123; s[next].push(node -&gt; m_pRight); &#125; if (node -&gt; m_pLeft) &#123; s[next].push(node -&gt; m_pLeft); &#125; &#125; if (s[current].empty()) &#123; // 一行打印结束，（写的真好） current = 1 - current; // 奇偶互换 next = 1 - next; printf(\"\\n\"); &#125; &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指offer31.栈的压入弹出序列 P168","slug":"剑指offer31","date":"2019-11-01T07:25:06.000Z","updated":"2019-11-01T07:28:15.096Z","comments":true,"path":"2019/11/01/剑指offer31/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer31/","excerpt":"","text":"剑指offer31. 栈的压入弹出序列 P168题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。 用辅助栈 s，nums是给定的弹出序列，inputs是压栈序列 如果栈不空，而且而且下一个弹出数字num恰好时栈顶数字，直接弹出 如果num和栈顶元素不等，把压栈序列inputs中num及num之前的数字压栈，如果在inputs这一轮的压栈中没有找到num，匹配失败。 最后两个序列都走到末尾，而且辅助栈空，匹配成功 换句话说：在弹出串中找到栈顶值之前，把没有访问过的输入串元素入栈，更新没有访问的元素头索引vis ，如果到最后都没有找到当前栈顶值，匹配失败 12345678910111213141516171819202122232425262728// 寻找并压栈bool findAndPush(stack&lt;int&gt; &amp;s, const int *input, const int *pattern, int &amp;vis, int len, int index) &#123; for (int i = vis + 1; i &lt; len; ++i) &#123; s.push(input[i]); if (input[i] == pattern[index]) &#123; vis = i; return true; &#125; &#125; return false;&#125; bool isPopOrder(const int *input, const int *pattern, int len) &#123; if (input == NULL || pattern == NULL || len &lt; 1) return false; int vis = -1; // 不能从0开始，因为find函数里从vis+1开始压栈 stack&lt;int&gt; s; findAndPush(s,input, pattern, vis, len, 0);//初始 for (int i = 0; i &lt; len;)&#123; int temp = pattern[i]; if (!s.empty() &amp;&amp; s.top() == temp) &#123; // 栈顶和当前值相等，比较下一个元素 s.pop(); ++i; &#125;else if ( !findAndPush(s, input, pattern, vis, len, i) ) &#123; return false; // 找不到匹配失败 &#125; &#125; return true; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"栈&队列","slug":"栈-队列","permalink":"http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"}]},{"title":"剑指Offer30. 包含Min函数的栈 P165","slug":"剑指offer30","date":"2019-11-01T06:34:35.000Z","updated":"2019-11-01T07:19:03.656Z","comments":true,"path":"2019/11/01/剑指offer30/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer30/","excerpt":"","text":"剑指offer30. 包含min函数的栈 P165题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。 构造一共辅助栈min，栈顶是当前数据栈data中的最小元素。 即：每次数据num入数据栈data时，把num和当前min栈顶元素tip比较，存入较小的那个到min栈（只把栈顶做比较，不要弹栈；假如栈顶小，再压入一个栈顶元素，否则，压入num） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869template &lt;typename T&gt; class StackWithMin&#123;public: StackWithMin() &#123;&#125; virtual ~StackWithMin() &#123;&#125; T&amp; top(); const T&amp; top() const; void push(const T&amp; value); void pop(); const T&amp; min() const; bool empty() const; size_t size() const;private: std::stack&lt;T&gt; m_data; // 数据栈，存放栈的所有元素 std::stack&lt;T&gt; m_min; // 辅助栈，存放栈的最小元素&#125;;template &lt;typename T&gt; void StackWithMin&lt;T&gt;::push(const T&amp; value)&#123; // 把新元素添加到辅助栈 m_data.push(value); // 当新元素比之前的最小元素小时，把新元素插入辅助栈里； // 否则把之前的最小元素重复插入辅助栈里 if(m_min.size() == 0 || value &lt; m_min.top()) m_min.push(value); else m_min.push(m_min.top());&#125;template &lt;typename T&gt; void StackWithMin&lt;T&gt;::pop()&#123;//assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行。 assert(m_data.size() &gt; 0 &amp;&amp; m_min.size() &gt; 0); m_data.pop(); m_min.pop();&#125;template &lt;typename T&gt; const T&amp; StackWithMin&lt;T&gt;::min() const&#123; assert(m_data.size() &gt; 0 &amp;&amp; m_min.size() &gt; 0); return m_min.top();&#125;template &lt;typename T&gt; T&amp; StackWithMin&lt;T&gt;::top()&#123; return m_data.top();&#125;template &lt;typename T&gt; const T&amp; StackWithMin&lt;T&gt;::top() const&#123; return m_data.top();&#125;template &lt;typename T&gt; bool StackWithMin&lt;T&gt;::empty() const&#123; return m_data.empty();&#125;template &lt;typename T&gt; size_t StackWithMin&lt;T&gt;::size() const&#123; return m_data.size();&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"栈&队列","slug":"栈-队列","permalink":"http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"}]},{"title":"剑指Offer29. 顺时针打印矩阵 P161","slug":"剑指offer29","date":"2019-11-01T06:34:29.000Z","updated":"2019-11-01T07:16:40.835Z","comments":true,"path":"2019/11/01/剑指offer29/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer29/","excerpt":"","text":"剑指offer29. 顺时针打印矩阵 P161题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。1 2 3 45 6 7 89 10 11 1213 14 15 16 打印： 1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10 当我们顺时针打印该矩阵时，每一圈的起始位置是左上角的元素，并且每一圈左上角元素都有一个共同点：它的行rows和列cols所对应的的下标都是相同的。因此不难想到，该矩阵打印结束的条件就是左上角的元素下标走到了该矩阵行和列的一半时，该矩阵打印结束了。因为矩阵也是用下标来确定某个数字的，所以这里就是：rows &gt; start * 2 &amp;&amp; cols &gt; start * 2 矩阵打印一圈需要四步（从左到右，从上到下，从右到左，从下到上），这个是一般情况，当矩阵是行大于列、列大于行的时候可能不需要四步，就可以打印结束 无论是一个怎样的矩阵，它都会进行第一步从左到右，并且如果打印一个矩阵它进行了第三步，那么一定走了一二步，也就是说后面的每一步是建立在前面步的基础之上的，总结一下打印每一圈：（1）从左往右：肯定有； （2）从上到下：矩阵行数至少为2，即：终止行号必须大于起始行号（这里不可以等于，否则会产生矩阵右上角的元素重复多打印一次）； （3）从右往左：矩阵至少为两行两列，即：终止列号必须大于起始列号，并且终止行号必须大于起始行号（同样，不可以等于，否则矩阵右下角的元素会多打印一次）； （4）从下到上：矩阵至少为三行两列，即：终止行号必须比起始行号大2，并且终止列号必须大于起始列号（同样，不可以等于，否则会出现左下角和右上角元素多打印一次） 1234567891011121314151617181920212223242526272829303132void print(int **number, int rows, int cols) &#123; if (number == NULL || rows &lt; 0 || cols &lt; 0) return ; if (rows == 0 &amp;&amp; cols == 0) return; int start = 0; // 对角线上的行列号 while (rows &gt; start * 2 &amp;&amp; cols &gt; start * 2) &#123; printMatrix(number, rows, cols, start); ++start; &#125;&#125;void printMatrix(int **a, int rows, int cols, int start) &#123; //顺时针打印一圈 int endx = rows - start - 1, endy = cols - start - 1; // 终止行号和列号 for (int i = start; i &lt;= endy; ++i) &#123; // 从左往右，直接打印 cout &lt;&lt; a[start][i] &lt;&lt; \" \"; &#125; if (endx &gt; start) &#123; // 从上到下：终止行号必须大于起始行号 for (int i = start + 1; i &lt;= endx; ++i) &#123; // 从start+1开始，不然重复打 cout &lt;&lt; a[i][endy] &lt;&lt; \" \"; &#125; &#125; if (endx &gt; start &amp;&amp; endy &gt; start) &#123; // 从右往左：终止列号必须大于起始列号，并且终止行号必须大于起始行号 for (int i = endy - 1; i &gt;= start; --i) &#123; cout &lt;&lt; a[endx][i] &lt;&lt; \" \"; &#125; &#125; if (endx - 1 &gt; start &amp;&amp; endy &gt; start) &#123; //从下到上：终止行号必须比起始行号大2，并且终止列号必须大于起始列号 for (int i = endx - 1; i &gt; start; --i) &#123; cout &lt;&lt; a[i][start] &lt;&lt; \" \"; &#125; &#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer28. 对称的二叉树 P159","slug":"剑指offer28","date":"2019-11-01T06:34:26.000Z","updated":"2019-11-01T07:12:39.756Z","comments":true,"path":"2019/11/01/剑指offer28/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer28/","excerpt":"","text":"剑指offer28. 对称的二叉树 P159题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的 12345678bool judge(BinaryTreeNode *proot1, BinaryTreeNode *proot2) &#123; if (proot1 == NULL &amp;&amp; proot2 == NULL) return true; if (proot1 == NULL || proot2 == NULL) return false; if (proot1 -&gt; key != proot2 -&gt; key) return false; // 注意下面，1的左子树和2的右子树比较，不要惯性思维搞错！ return judge(proot1 -&gt; left, proot2 -&gt; right) &amp;&amp; judge(proot1 -&gt; right, proot2 -&gt; left);&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指offer27.二叉树的镜像 P157","slug":"剑指offer27","date":"2019-11-01T06:34:20.000Z","updated":"2019-11-01T07:10:28.531Z","comments":true,"path":"2019/11/01/剑指offer27/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer27/","excerpt":"","text":"剑指offer27.二叉树的镜像 P157题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。 // 其实就是先根遍历的模板，在左右子树递归访问前交换左右子树 123456789101112131415void MirrorRecursively(BinaryTreeNode *pNode) &#123; if (pNode == NULL) return; // 两个递归出口 if (pNode -&gt; left == NULL &amp;&amp; pNode -&gt; right == NULL) return ; BinaryTreeNode *temp = pNode -&gt; left; // 交换左右子树（先根遍历是访问节点） pNode -&gt; left = pNode -&gt; right; pNode -&gt; right = temp; if (pNode -&gt; left) // 左递归 MirrorRecursively(pNode -&gt; left); if (pNode -&gt; right) // 右递归 MirrorRecursively(pNode -&gt; right);&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指offer26.树的子结构（一棵二叉树b是不是被二叉树a包含）P148","slug":"剑指offer26","date":"2019-11-01T06:34:13.000Z","updated":"2019-11-01T07:08:20.931Z","comments":true,"path":"2019/11/01/剑指offer26/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer26/","excerpt":"","text":"剑指offer26. 树的子结构（一棵二叉树b是不是被二叉树a包含）P148题目：输入两棵二叉树A和B，判断B是不是A的子结构。 递归结束条件：如果rootp为空，说明对比的子树已经找完了，此时不管root是不是空，都可以返回true（主调函数提前判断了rootp一开始就为空的情况），如果在rootp不为空的情况下root为空，说明这里肯定不对，因为子树还没有对比完，母树已经没了，返回false; 逻辑判断：如果root.val==rootp.val,那么此时有两种情况: 这个root节点是子结构的一部分，我们要判断roop的左右子树是不是也分别包含在root的左右子树中（这里用的是&amp;&amp;，因为要同时满足）： HasSubtree(root -&gt; m_pLeft, rootp -&gt; m_pLeft)&amp;&amp; HasSubtree(root -&gt; m_pRight, rootp -&gt; m_pRight 如果不包含这个节点（虽然两个根节点一样，但是在后面的递归过程出现两个结构不等的情况），我们就不能取这个root，所以要看root的左右子树是不是存在包含子结构的 （这里用的是||，因为不管左右子树哪个包含，只要出现就行）HasSubtree(root -&gt; m_pLeft, rootp)|| HasSubtree(root -&gt; m_pRight, rootp); 两种情况一种成立就可以，所以中间用||连接 （这里会容易忽略第二种情况） 回到开始，如果root.val != rootp.val,也就是进入那个else判断，这时就和上面的情况2一样了，直接返回左右子树和rootp比较的结果： 12 HasSubtree(root -&gt; m_pLeft, rootp)|| HasSubtree(root -&gt; m_pRight, rootp); 12345678910111213141516171819// ---------------主递归函数---------------------------------bool HasSubtree(BinaryTreeNode *root, BinaryTreeNode *rootp) &#123; if (rootp == NULL) return true; if (root == NULL) return false; if (equal(root -&gt; m_dbValue, rootp -&gt; m_dbValue)) &#123; // 比较浮点数 return (HasSubtree(root -&gt; m_pLeft, rootp -&gt; m_pLeft) // 情况1 &amp;&amp; HasSubtree(root -&gt; m_pRight, rootp -&gt; m_pRight)) || HasSubtree(root -&gt; m_pLeft, rootp) // 情况2 || HasSubtree(root -&gt; m_pRight, rootp); &#125; else &#123; return HasSubtree(root -&gt; m_pLeft, rootp) // 情况2 || HasSubtree(root -&gt; m_pRight, rootp); &#125;&#125;bool has(BinaryTreeNode *root, BinaryTreeNode *rootp) &#123; // 主调函数，root是母树 if (rootp == NULL || root == NULL) return false; //默认两棵树任一个是空，返回false return HasSubtree(root, rootp); // 递归判断 &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指offer25.合并两个排序的链表 P145","slug":"剑指offer25","date":"2019-11-01T06:34:10.000Z","updated":"2019-11-01T06:57:35.852Z","comments":true,"path":"2019/11/01/剑指offer25/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer25/","excerpt":"","text":"剑指offer25. 合并两个排序的链表 P145每次比较两个链表表头，那个小，哪个就是当前节点mergeHead，然后把剩下的链表继续合并，找这个mergeHead的下一个节点。 12345678910111213141516171819ListNode* mergeSortedLinkedList(ListNode *head1, ListNode *head2) &#123; // 任一个链表比较完，把剩下的直接加到当前合并的链表尾if (head1 == NULL) return head2; if (head2 == NULL) return head1; ListNode *mergeHead = NULL; // 每次选出来两个链表头里最小的作为上一个节点的next if (head1 -&gt; key &lt; head2 -&gt; key) &#123; mergeNode = head1; mergeNode -&gt; next = mergeSortedLinkedList(head1 -&gt; next, head2); &#125; else &#123; mergeNode = head2; mergeNode -&gt; next = mergeSortedLinkedList(head1, head2 -&gt; next); &#125; return mergeNode; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer24. 反转链表 P142","slug":"剑指offer24","date":"2019-11-01T06:34:06.000Z","updated":"2019-11-01T06:55:13.329Z","comments":true,"path":"2019/11/01/剑指offer24/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer24/","excerpt":"","text":"剑指offer24. 反转链表 p142题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 1234567891011121314ListNode *ReverseList(ListNode *pHeadList) &#123; if (pHeadList == NULL) return NULL; ListNode *preNode = NULL; // 前驱节点 ListNode *pNode = pHeadList; // 工作节点 while (pNode != NULL) &#123; ListNode *nextNode = pNode -&gt; m_pNext; pNode -&gt; m_pNext = preNode; preNode = pNode; pNode = nextNode; &#125; return preNode; // 前驱就是头结点&#125; 递归解法见p145 页","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指offer23.链表是否有环，找出环的入口 P139","slug":"剑指offer23","date":"2019-11-01T06:34:02.000Z","updated":"2019-11-01T06:53:23.433Z","comments":true,"path":"2019/11/01/剑指offer23/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer23/","excerpt":"","text":"剑指offer23. 链表是否有环，找出环的入口 P139和书上不太一样，这里用的弗洛伊德龟兔算法Fast指针 比 slow 每次多走一步，相遇之后，fast从头开始一次走一步，slow从当前开始每次走一步，两者再相遇点就是入口。 123456789101112131415161718192021ListNode *EntryNodeOfLoop(ListNode *pHeadList) &#123; if (pHeadList == NULL || pHeadList -&gt; m_pNext == NULL) return NULL; ListNode *slow = pHeadList -&gt; m_pNext , *fast = slow -&gt; m_pNext; while (fast != NULL &amp;&amp; slow != NULL) &#123; if (fast == slow) break; // 第一次相遇 if (fast -&gt; m_pNext == NULL) return NULL; // 没有环 else &#123; fast = fast -&gt; m_pNext -&gt; m_pNext; // 前进 slow = slow -&gt; m_pNext; &#125; &#125; if (fast != slow || fast == NULL) return NULL; // 没有环 fast = pHeadList; // fast从头走 while (fast != slow) &#123; // 再一次相遇，相遇点就是入口 fast = fast -&gt; m_pNext; slow = slow -&gt; m_pNext; &#125; return fast;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指offer22.链表中的倒数第k个节点 P134","slug":"剑指offer22","date":"2019-11-01T06:33:59.000Z","updated":"2019-11-01T06:49:29.285Z","comments":true,"path":"2019/11/01/剑指offer22/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer22/","excerpt":"","text":"剑指offer22. 链表中的倒数第k个节点 P134题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。 // 本题主要是鲁棒性检测 两个if条件的内容。第二个if不能用p!=NULL 是因为，p定义指的是最后一共节点，如果最后p是NULL(最后一共节点的下一个节点)了，就失去意义了。 123456789101112131415ListNode *findK(ListNode *head, int k) &#123; if (head == NULL || k &lt; 1) return 0; ListNode *p = head; // 指向倒数第一个节点 for (int i = 0; i &lt; k- 1; ++i) &#123; if (p -&gt; m_pNext != NULL) p = p -&gt; m_pNext; // 节点总数小于k else return NULL; &#125; ListNode *q = head; // 倒数第k个节点 while (p -&gt; m_pNext != NULL) &#123; p = p -&gt; m_pNext; q = q -&gt; m_pNext; &#125; return q; &#125; 扩展：求链表的中间节点：如果链表节点数是奇数，返回中间节点，否则返回中间两个节点任一个。 定义一个快指针一次走两步，一个慢指针一次走一步。快指针走到末尾慢指针指的就是答案 1234567891011ListNode *find_mid(ListNode *head)&#123; if(head == NULL) return NULL; ListNode *slow, *fast; slow = fast = head; /*快慢指针都指向第一个节点*/ while (fast != NULL &amp;&amp; fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) &#123; slow = slow-&gt;next; /*慢指针每次走一步*/ fast = fast-&gt;next-&gt;next; /*快指针每次走两步*/ &#125; return slow;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer21. 调整数组顺序使奇数位于偶数前面 P129","slug":"剑指offer21","date":"2019-11-01T06:33:53.000Z","updated":"2019-11-01T06:42:07.846Z","comments":true,"path":"2019/11/01/剑指offer21/","link":"","permalink":"http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer21/","excerpt":"","text":"剑指offer21. 调整数组顺序使奇数位于偶数前面 P129题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 两点法，左右同时走指针，交换左边找的偶数和右边找到的奇数 1234567891011121314151617void ReorderOddEven(int *nums, unsigned int length) &#123; if (nums == NULL || length &lt; 1) return ; int even = 0, odd = length - 1; while (even &lt; odd) &#123; // 不能 = while (even &lt; odd &amp;&amp; (nums[even] &amp; 1) != 0) ++even; // 找偶数 while (even &lt; odd &amp;&amp; (nums[odd] &amp; 1) == 0) --odd; // 找奇数 if (even &lt; odd) &#123; // 交换位置 int temp = nums[odd]; nums[odd] = nums[even]; nums[even] = temp; &#125; &#125;&#125; 可扩展的解法：如果把奇数偶数换成正负，能不能被3整除。。。等只需要修改大循环里的两个while的判断条件，那么就可以把判断条件解耦出来，传入独立的函数判断。 函数声明变成：void ReorderOddEven( int *nums, unsigned int length, bool (*func)(int) ) 两个判断条件分别变成： while (even &lt; odd &amp;&amp; !isEven(nums[even])) while (even &lt; odd &amp;&amp; isEven(nums[odd])) 单独定义判断函数：(根据不同要求定义不同的判断条件) bool isEven(int n) { 是不是偶数 return (n&amp;1) == 0; } 顶层调用： reorderOddEven(nums, length, isEven)","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer20. 表示数值的字符串P127","slug":"剑指offer20","date":"2019-10-31T06:55:08.000Z","updated":"2019-11-01T08:49:39.504Z","comments":true,"path":"2019/10/31/剑指offer20/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer20/","excerpt":"","text":"剑指offer20 . 表示数值的字符串P127题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”、“5e2”、“-123”、“3.1416”及“-1E-16”都是，但“12e”、“1a3.14”、“1.2.3、“+-5”及“12e+5.4不是（这个题的描述相当不清楚，很多有悖常理的数字格式也是对的，leetcode上很多人吐槽） 1.用自动机做（很low，但是就这题而言我觉得好理解，） https://blog.csdn.net/qq_43778308/article/details/102838980 上图只是为了说明自动机处理的原理，下面代码不是按照上面这个图写的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859bool isNumber(const char * str) &#123; if (str == NULL) return false; int state=1; // 初始状态 for(int i = 0; i &lt; strlen(str); ++i)&#123; char c = str[i]; switch (state)&#123; case 1: if(c==' ') state=1; else if(c=='+'||c=='-') state=2; else if(isdigit(c)) state=3; else if(c=='.') state=4; else return false; break; case 2: if(isdigit(c)) state=3; else if(c=='.') state=4; else return false; break; case 3: if(isdigit(c)) state=3; else if(c=='e'||c=='E') state=6; else if(c=='.') state=5; else if(c==' ') state=9; else return false; break; case 4: if(isdigit(c)) state=5; else return false; break; case 5: if(isdigit(c)) state=5; else if(c=='e'||c=='E') state=6; else if(c==' ') state=9; else return false; break; case 6: if(c=='+'||c=='-') state=7; else if(isdigit(c)) state=8; else return false; break; case 7: if(isdigit(c)) state=8; else return false; break; case 8: if(isdigit(c)) state=8; else if(c==' ') state=9; else return false; break; case 9: if(c==' ') state=9; else return false; break; &#125; &#125; return state==3||state==5||state==8||state==9; // 一共有4个正确的结束状态 &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"正则匹配","slug":"正则匹配","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"},{"name":"自动机","slug":"自动机","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"剑指Offer19. 正则表达式匹配 P124","slug":"剑指offer19","date":"2019-10-31T06:55:02.000Z","updated":"2019-11-01T08:49:28.433Z","comments":true,"path":"2019/10/31/剑指offer19/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer19/","excerpt":"","text":"剑指offer19. 正则表达式匹配 P124题目：请实现一个函数用来匹配包含’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”及”ab*a”均不匹配。 因为 * 的存在让整个题目复杂，那我们把下一个字符是不是*作为划分依据。 Case 1. 当模式中的第二个字符不是“*”时：1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。2、如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 Case 2 . 当模式中的第二个字符是“*”时：可以有3种匹配方式：1、模式后移2字符，相当于x*被忽略；比如 str : ab , pattern : b*ab2、字符串后移1字符，模式后移2字符，x*相当于只匹配一个字符；ab 和 a*b3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为可以匹配多位；aab 和a\\b 12345678910111213141516171819202122232425bool isMatchedCore(const char *str, const char *pattern) &#123; // 匹配递归函数 if (*str == '\\0' &amp;&amp; *pattern == '\\0') return true; // 两个递归出口 if (*str != '\\0' &amp;&amp; *pattern == '\\0') return false; if (*(pattern + 1) == '*') &#123; // case 2情况 if ((*str == *pattern)|| (*pattern == '.' &amp;&amp; *str != '\\0')) &#123; // 当前字符匹配成功，相当于又重新进入case 2的情况，有三种选择 return isMatchedCore(str + 1, pattern) || isMatchedCore(str + 1, pattern + 2) || isMatchedCore(str, pattern + 2); &#125;else &#123; // 当前匹配失败那么*就没有作用了，跳过下一个*,只能是case 2.1的情况 return isMatchedCore(str, pattern + 2); &#125; &#125;else &#123; // case1情况下一个不是* if ((*str == *pattern)|| (*pattern == '.' &amp;&amp; *str != '\\0')) // case1.1 return isMatchedCore(str + 1, pattern + 1); else // case 1.2 return false; &#125;&#125;bool isMatched(const char *str, const char *pattern) &#123; // 匹配函数if (str == NULL &amp;&amp; pattern == NULL) return true; if (pattern == NULL) return false; return isMatchedCore(str, pattern); &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"正则匹配","slug":"正则匹配","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"}]},{"title":"剑指offer18．在O(1)时间内删除链表节点 P119","slug":"剑指offer18","date":"2019-10-31T06:54:59.000Z","updated":"2019-11-01T08:49:19.192Z","comments":true,"path":"2019/10/31/剑指offer18/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer18/","excerpt":"","text":"剑指offer18． 在O(1)时间内删除链表节点 P119题目：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。 /* 既然要在O（1）时间内删除，就不需要遍历，或者说大多数情况下不需要遍历整个链表，那么在O(1) 时间内我们能得到哪些东西呢？ 1.首先头指针和头指针下一个节点显然没有什么用，再者就是2. 需要删除的节点p和他的下一个节点next， 那么肯定是围绕着p和next操作。如果要删除应该链表节点，通常要找到它的前驱，这一道题能够构成这种前后关系的就是删除next，它的前驱是p，于是我们把next的东西复制给p，再删除next就ok了。以上是普通情况当p是头结点时候，要特判，p是尾节点时候，只能够遍历整个链表了此外，因为o（1）时间的限制，我们不能确保链表中有p，这只能交给函数调用者处理了 1234567891011121314151617181920212223242526272829void deleteNode(ListNode **pHeadList, ListNode *pToDeleteNode) &#123; if (!(*pHeadList) || !pToDeleteNode) return; if (*pHeadList == pToDeleteNode) &#123; // 删头节点 ListNode *temp = *pHeadList; if (temp -&gt; next == NULL) &#123; // 链表只有一个节点 *pHeadList = NULL; delete temp; &#125; else &#123; // 链表有其他节点 *pHeadList = (*pHeadList) -&gt; next;// 不要使用delete (*pHeadList)，在没有被分配之前里面的内容还是完好的。// 而且delete不负责将指针设置为NULL。 delete temp; temp = NULL; &#125; &#125; else if (pToDeleteNode -&gt; next != NULL) &#123; // 在中间删除，把next值给当前节点， // 并且删除next ListNode *temp = pToDeleteNode -&gt; next; pToDeleteNode -&gt; key = pToDeleteNode -&gt; next -&gt;key; pToDeleteNode -&gt; next = pToDeleteNode -&gt; next -&gt; next; delete temp; temp = NULL; &#125; else if (pToDeleteNode -&gt; next == NULL) &#123; // 删除尾节点，必须遍历 ListNode *p = *pHeadList; while (p -&gt; next != pToDeleteNode) p = p -&gt; next; p -&gt; next = NULL; delete pToDeleteNode; pToDeleteNode = NULL; &#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer17. 打印从1到最大的n位数 P114","slug":"剑指offer17","date":"2019-10-31T06:54:53.000Z","updated":"2019-11-01T08:49:08.504Z","comments":true,"path":"2019/10/31/剑指offer17/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer17/","excerpt":"","text":"剑指offer17. 打印从1到最大的n位数 P114题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。 1. 方法一： 用字符数组str倒着存储大数。每次大数自增1，如果溢出，表明打印完 12345678910111213141516171819202122232425262728293031// 此函数完成大数自增1的功能，并返回是否已经“溢出”（长度满足题目要求）bool Increment(char *str, int current_length) &#123; int carry = 0; // 进位 bool overflow = false; // 溢出标志 for (int i = current_length - 1; i &gt;=0; --i) &#123; // 加1后大数从后往前每一位进行更新 int num = str[i] - '0' + carry; //不能再上面直接+1，因为这个for后面都是为了处理第一次的进位的 if (i == current_length - 1) num++; // 只有最低位+1 if (num &gt;= 10) &#123; // 有进位 if (i == 0) &#123; // 有进位，而且是最高位i=0产生的，溢出 overflow = true; // 调用函数也退出循环 break; // 退出 &#125; str[i] = num - 10 + '0'; // 否则，处理进位 carry = 1; &#125; else &#123; str[i] = num + '0'; //这后面不用加carry=0 break; // 因为后面的循环时为了处理进位，没有进位就直接退出了 &#125; &#125; return overflow; //返回溢出标志&#125;void print1ToMaxOfNDigits(int n) &#123; // 调用函数，打印1 -- n位最大数 if (n &lt; 1) return; char *str = new char[n + 1]; memset(str, '0',sizeof(str)); str[n] = '\\0'; while (!Increment(str, n)) // 自增后，判断是否溢出， print(str, n); // 没有溢出，打印&#125; 2. 方法二，递归全排列 如果我们在数字前面补0，就会发现n位所有十进制数其实就是n个从0到9数字的全排列。也就是说，我们把数字的每一位都从0到9遍历一遍，就得到了所有的十进制数。只是在打印的时候，排在前面的0不打印出来罢了。全排列用递归表达，数字的每一位都可能是0~9中的一个数，然后设置下一位。递归结束的条件是我们设置了的数字的最后一位。 12345678910111213141516171819202122232425262728293031323334353637void print1ToMaxOfNDigits2(int len) &#123; if (len &lt; 1) return ; char *nums = new char[len]; // 不用len+1 for (int i = 0; i &lt; len; ++i) nums[i] = '0'; for (int i = 0; i &lt;= 9; ++i)&#123; // 从第0位开始设置，取0-9调用递归 nums[0] = i + '0'; printCore(nums,len,0); &#125; delete[] nums;&#125; void printCore(char *nums, int len, int index) &#123;// 求排列，index是当前设置的第index位 if (index == len - 1 ) &#123; // 递归出口，设置完最后一位 print(nums, len); // 打印 return; &#125; for (int i = 0 ; i &lt;= 9; ++i) &#123; // 递归当前第index后面的若干位 nums[index + 1] = i + '0'; printCore(nums, len, index + 1); &#125; &#125;// 把符合条件的一个数打印出来，注意题干，从1开始打印！void print(char *str, int len) &#123; int i = 0; while (str[i] == '0') ++i; //剔除前导0 if (i != len) &#123; while (i &lt; len) &#123; printf(\"%c\", str[i]); ++i; &#125; printf(\"\\n\"); &#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"剑指Offer16. 数值的整数次方 P110","slug":"剑指offer16","date":"2019-10-31T06:54:49.000Z","updated":"2019-11-01T08:48:57.101Z","comments":true,"path":"2019/10/31/剑指offer16/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer16/","excerpt":"","text":"剑指offer16. 数值的整数次方P110题目：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 1234567891011121314151617181920212223242526272829303132333435const double esp = 1e-6; bool isValid = false; // power函数返回0时，判断合不合法，true时不合法double powerWithUnsignedExponent(double base, int exponent) &#123; // 此输入保证指数非负 if (exponent == 0) return 1; if (exponent == 1) return base; // 指数除以2递归 double ans = powerWithUnsignedExponent(base, exponent &gt;&gt; 1); ans *= ans; // 先在上一步递归里算出来a的（n/2）次方， 再平方 if ((exponent &amp; 1)) &#123; // 如果指数是奇数还要再乘以base （规律见p112） ans *= base; &#125; return ans;&#125;double power(double base, int exponent) &#123; isValid = false; // 这是全局变量，不能省 ，默认合法 if (fabs(base - 0.0) &lt;= esp &amp;&amp; exponent &lt; 0) &#123; isValid = true; // 不合法 的0.0 return 0.0; &#125; if (exponent == 0) return 1.0; if (base == 0) &#123; return 0.0; // 合法的0.0 &#125; //先把指数按正数处理 int temp = exponent &lt; 0 ? -exponent : exponent; double ans = powerWithUnsignedExponent(base, temp); // 如果指数是负数，结果取倒数 if (exponent &lt; 0) ans = 1 / ans; return ans; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"剑指Offer15. 二进制中1的个数 P100","slug":"剑指offer15","date":"2019-10-31T06:54:44.000Z","updated":"2019-11-01T08:48:43.860Z","comments":true,"path":"2019/10/31/剑指offer15/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer15/","excerpt":"","text":"剑指offer15. 二进制中1的个数 P10012345678910111213141516171819int countNumbersOfOne(int a) &#123; int count = 0; unsigned int flag = 1; while (flag) &#123; if ((a &amp; flag)) ++count; flag = flag &lt;&lt; 1; //常规方法 让1从右往左分别与a的每一位与 // 不能右移a，因为 0x80000000时死循环 &#125; return count;&#125;int countNumbersOfOne2(int a) &#123; int count = 0; while (a) &#123; a &amp;= a - 1; // a&amp;a-1之后会刚好相当于a的二进制去掉一个最后一个1， ++count; // 统计它循环次数就知道几个1了 &#125; return count;&#125; 扩展：1 一条语句判断整数是不是2的整数次方2 两个整数m,n 求m要改变多少二进制位才能变成n 1 （二进制中只有一个1） 2 （1）先异或^（2）统计结果中1的个数","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"剑指Offer14. 剪绳子 P96","slug":"剑指offer14","date":"2019-10-31T06:54:39.000Z","updated":"2019-11-01T08:48:30.168Z","comments":true,"path":"2019/10/31/剑指offer14/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer14/","excerpt":"","text":"剑指offer14 . 剪绳子 P96题目：给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1]…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。 动态规划， 令 f(n) 是长度n最后的最大乘积，剪在整数上i上 ，显然f(n) = max( f(i) * f(n-i) ) i 从4到n，前3个要特判，因为当n等于1-3时，得到的乘积最大数和把前3个当作乘数因子（提供给后面4~n时的数当作f(i) 或者f(n-i)）不一样。 123456789101112131415161718192021222324int maxProduct(int length) &#123; if (length &lt; 2) return 0; // 要求length &gt; 1 if (length == 2) return 1; // 只能从i=1处剪 if (length == 3) return 2; // 同上 int *dp = new int[length + 1]; memset(dp, 0, sizeof(dp)); // dp在前三个存的并不是答案，只是为了充当dp[i] 或 dp[n-i]，所以才在上面特判 // 因为n是1到3时，还必须要剪一刀，但是充当乘法因子不一定要在它们中间剪 dp[1] = 1; //前三个代表长度为i的子绳最大能提供的乘法因子是多少 dp[2] = 2; dp[3] = 3; for (int i = 4; i &lt;= length; ++i) &#123; // i是绳长 for (int j = 1; j &lt;= i / 2; ++j) &#123; dp[i] = max(dp[i], dp[j] * dp[i - j]); //括号里的dp[i]存的是前几个j的dp[i]的最大值，跟当前比 &#125; &#125; int ans = dp[length]; delete [ ] dp; return ans; &#125; 贪心那个解法已然放弃。。。我这样的学术辣鸡不配使用贪心。","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指Offer13. 机器人的运动范围 P92","slug":"剑指offer13","date":"2019-10-31T06:54:30.000Z","updated":"2019-11-01T08:48:11.897Z","comments":true,"path":"2019/10/31/剑指offer13/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer13/","excerpt":"","text":"剑指offer13. 机器人的运动范围 P92题目：地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和 大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 12345678910111213141516171819202122232425262728293031323334353637// 判断当前访问的格子是不是有效// 参数：二维数组行，列总数，当前行，列索引，给定k值，访问标志bool isValid(int rows, int cols, int i, int j, int k, bool *visited) &#123; if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || visited[i * cols + j]) return false; // 边界条件不满足，访问访问过 int sum = 0; // i，j的各位和 while (i != 0) &#123; sum += i % 10; i /= 10; &#125; while (j != 0) &#123; sum += j % 10; j /= 10; &#125; if (sum &gt; k) return false; return true;&#125;int countS(int rows, int cols, int i, int j, int k, bool *visited) &#123; // 递归 int count = 0; if (isValid(rows, cols, i, j, k, visited)) &#123; //当前格满足条件 visited[i * cols + j] = true; count = 1 + countS(rows, cols, i - 1, j, k, visited) //不是count += + countS(rows, cols, i, j - 1, k, visited) + countS(rows, cols, i + 1, j, k, visited) + countS(rows, cols, i, j + 1, k, visited); &#125; return count;&#125;int movingCount( int k, int rows, int cols) &#123; if (k &lt; 0 || rows &lt; 1 || cols &lt; 1) return 0; bool *visited = new bool[rows * cols]; memset(visited, 0, rows * cols); int ans = countS(rows, cols, 0, 0, k, visited);//不用再两层for遍历了 delete []visited; return ans; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"剑指Offer12.  矩阵中匹配字符串 P89","slug":"剑指offer12","date":"2019-10-31T06:54:12.000Z","updated":"2019-11-01T08:48:00.597Z","comments":true,"path":"2019/10/31/剑指offer12/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer12/","excerpt":"","text":"剑指offer12. 矩阵中匹配字符串P89题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。A B T GC F C SJ D E H // 参数：原始数组，二维数组行，列，当前访问元素的行，列，// 目标字符串，访问标志，路径索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool isHavePath(const char *matrix, int rows, int cols, int i, int j, const char *str, bool *visited, int&amp; pathlength) &#123; if (str[pathlength] == '\\0') return true; // 匹配结束，返回true bool havepath = false; // 答案 // 当前访问元素的行列没有越界，没有访问过，值和目标字符串对应位置一样 if (i &gt;= 0 &amp;&amp; i &lt; rows &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; cols &amp;&amp; !visited[i * cols + j] &amp;&amp; matrix[i * cols + j] == str[pathlength]) &#123; visited[i * cols + j] = true; // 设置访问过 ++pathlength; // 注意：c++对于引用类型，不能传临时变量 // 也就是说，下面递归调用不能传pathlength+1 havepath = isHavePath(matrix, rows, cols, i - 1, j, str, visited, pathlength ) || isHavePath(matrix, rows, cols, i, j - 1, str, visited, pathlength ) || isHavePath(matrix, rows, cols, i + 1, j, str, visited, pathlength ) || isHavePath(matrix, rows, cols, i, j + 1, str, visited, pathlength ); if (!havepath) &#123; // 没有找到，回溯，把访问标记和路径索引回溯-1 visited[i * cols + j] = false; --pathlength; &#125; &#125; return havepath;&#125;bool hasPath(const char *matrix, int rows, int cols,const char *str) &#123; if (matrix == NULL || rows &lt;= 0 || cols &lt;= 0 || str == NULL) return false; bool *visited = new bool(rows * cols); // 访问标志初始化 memset(visited, 0, rows * cols); int path = 0; for (int i = 0; i &lt; rows; ++i) &#123; // 遍历二维数组每一个元素 for (int j = 0; j &lt; cols; ++j) &#123;**// path = 0; 这个可写可不写，因为如果匹配失败，在上面递归函数里，// path会回溯-1，直到减回0；匹配 成功直接返回了** if (isHavePath(matrix, rows, cols, i, j, str, visited, path)) // 递归 &#123; delete []visited; return true; &#125; &#125; &#125; delete []visited; return false; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"剑指Offer11．旋转数组的最小数字 P82","slug":"剑指offer11","date":"2019-10-31T06:42:37.000Z","updated":"2019-11-01T08:47:44.344Z","comments":true,"path":"2019/10/31/剑指offer11/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer11/","excerpt":"","text":"剑指offer11． 旋转数组的最小数字 P82题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。 看到有序两个字，要条件反射的想到二分。 这题应该注意的二分的划分依据是：中间值mid和子序列首尾大小比较（注意三者相等时的特殊情况），首先，i总是指向前面递增数组的元素，j总是指向后面递增数组的元素。如果i和j相差是1的话，那么索引i指向第一个递增数组的末尾，j指向后一个递增数组的开头。自然j指的就是答案了 123456789101112131415161718192021222324int Min(int *num, int length) &#123; if (num == NULL || length &lt; 1) throw (&quot;Invalid Input&quot;); if (length == 1 || num[0] &lt; num[length - 1]) return num[0]; // 递增 int i = 0, j = length -1, mid = 0; while (i &lt;= j ) &#123; mid = ((j - i) &gt;&gt; 1) + i; //三个指针值一样，不能二分，只有从头遍历 if (num[mid] == num[i] &amp;&amp; num[mid] ==num[j])&#123; for (int i = 1; i &lt; length; ++i) &#123; if (num[i] &lt; num[i - 1]) return num[i]; &#125; &#125;else if (num[mid] &gt;= num[i]) i = mid; //往右二分，不能从mid+1开始， // 因为如果mid此时刚好是答案，刚好错过正确的答案 else if (num[mid] &lt;= num[j]) j = mid; // 往左二分 ，同样必须从mid开始 if (j - i == 1 ) return num[j]; // i指向前一个递增数组结尾，j指向后一个开头 &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer（扩展）快排 P80","slug":"剑指offer扩展","date":"2019-10-31T06:14:48.000Z","updated":"2019-11-01T08:51:14.709Z","comments":true,"path":"2019/10/31/剑指offer扩展/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer%E6%89%A9%E5%B1%95/","excerpt":"","text":"剑指offer（扩展）快排 P801234567891011121314151617181920212223242526272829303132333435363738391. 快速排序 （递归实现）void quickSort(int nums[], int start, int end) &#123; if (nums == NULL || start &gt; end || start &lt; 0) return; int flag = nums[start], i = start, j = end; while (i &lt; j) &#123; while (nums[j] &gt;= flag &amp;&amp; i &lt; j) --j; // 一定是 先 从右往左找 nums[i] = nums[j]; while(nums[i] &lt;= flag &amp;&amp; i &lt; j) ++i; nums[j] = nums[i]; &#125; nums[i] = flag; // 确定当前基准值的位置 i quickSort(nums, start, i - 1); quickSort(nums, i + 1, end);&#125;2. 给公司员工年龄排序 P81void ageSort(int nums[], int len) &#123; if (nums == NULL || len &lt; 1) return; const int range_of_age_up = 100; // 年龄上界 const int range_of_age_down = 0; // 年龄下界 int *hash = new int[range_of_age_up + 1]; // hash表存对应年龄出现次数 memset(hash, 0, sizeof(hash) * (range_of_age_up + 1) ); // 注意长度！ for (int i = 0; i &lt; len; ++i) &#123; if (nums[i] &lt; range_of_age_down || nums[i] &gt; range_of_age_up) &#123; // 异常 throw \"sorry , out of range !\"; &#125; ++hash[nums[i]]; &#125; int index = 0; // 排序后的数组索引 for (int i = 0; i &lt;= range_of_age_up; ++i) // 统计每个年龄 i出现的次数hash[j] for (int j = 0; j &lt; hash[i]; ++j) // 那么连着hash[j]个元素就是年龄i nums[index++] = i; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"剑指Offer10. 高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题P74","slug":"剑指offer10","date":"2019-10-31T06:14:44.000Z","updated":"2019-11-03T03:14:25.272Z","comments":true,"path":"2019/10/31/剑指offer10/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer10/","excerpt":"","text":"剑指offer10 . 高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题p74123456789101112131415//优化后的斐波那契long long fb(int n) &#123; if (n &lt; 0) return -1; int table[2] = &#123;0, 1&#125;; if (n &lt; 2) return table[n]; long long pre1 = 1, pre2 = 0, fbn = 0; for (int i = 2; i &lt;= n; ++i) &#123; fbn = pre1 + pre2; pre2 = pre1; pre1 = fbn; &#125; return fbn;&#125; 青蛙跳台阶（只能跳1，2步） 设f(n)表示青蛙跳上n级台阶的跳法数。当只有一个台阶时，n = 1时， 只有1中跳法； n = 2时，有两种跳法；；当n很大时，青蛙在最后一步跳到第n级台阶时，有两种情况：一种是青蛙在第n-1个台阶跳一个台阶，那么青蛙完成前面n-1个台阶，就有f(n-1)种跳法，这是一个子问题。另一种是青蛙在第n-2个台阶跳两个台阶到第n个台阶，那么青蛙完成前面n-2个台阶，就有f(n-2)种情况，这又是另外一个子问题。两个子问题构成了最终问题的解，所以当n&gt;=3时，青蛙就有f(n)=f(n-1)+f(n-2)种跳法。 扩展 ：如果一次可以跳1，2，3…n 级的话 f(n) = 2的n-1次方证明： f(n) = f(n-1) + f(n-2) + f(n-3) …+f(n-n) 方程1 f(n-1) = f(n-2) + f(n-3) + f(n-4) …+f(n-n) 方程2 方程1-2得 ： f(n) – f(n-1) = f(n-1) f(n) = 2*f(n-1) = 2*2*f(n-2)=…2的n-1次方p79 页的矩阵覆盖也是同样的道理，不再赘述（注意n是初始几个值0，1，2的特判）","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"剑指Offer9. 两个栈实现队列 P68","slug":"剑指offer9","date":"2019-10-31T06:14:40.000Z","updated":"2019-11-03T03:13:41.865Z","comments":true,"path":"2019/10/31/剑指offer9/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer9/","excerpt":"","text":"剑指offer9. 两个栈实现队列 p68题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 /*在stack1 中存入；从stack2里取，如果取得时候2是null，把1的值全压到2再取 */ 12345678910111213141516171819202122232425262728#include&lt;stdexcept&gt; template &lt;typename T&gt; class CQueue &#123; public: CQueue(void)&#123; &#125;; // 不能只写个名字 ~CQueue(void)&#123;&#125;; void appendTail(const T&amp; node) &#123; // node的值不能被改变 stack1.push(node); &#125; T deleteHead() &#123; if (stack2.empty()) &#123; while (!stack1.empty()) &#123; stack2.push(stack1.top()); stack1.pop(); &#125; &#125; if (stack2.empty()) &#123; // 说明没有插入数据 ，抛出，不会往下执行 std::logic_error ex(\"queue is null !\"); throw std::exception(ex); &#125; T t = stack2.top(); stack2.pop(); return t; &#125; private: std::stack&lt;T&gt; stack1; std::stack&lt;T&gt; stack2; &#125;; 扩展： 用两个队列模拟栈思想： 两个队列交替充当队列。比如 压栈c时：往非空的队列1插入c，1内容变成cba。弹栈时，需要的是c，但是队列1头是a，那么依此把队列1的内容插入队列2中，把最后一个元素c返回。这时队列2变成非空了，那么再压栈就往2里插入了。如此循环","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"栈&队列","slug":"栈-队列","permalink":"http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"}]},{"title":"剑指Offer8. 二叉树的下一个节点 P65","slug":"剑指offer8","date":"2019-10-31T06:14:35.000Z","updated":"2019-11-01T08:47:09.413Z","comments":true,"path":"2019/10/31/剑指offer8/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer8/","excerpt":"","text":"剑指offer8. 二叉树的下一个节点 P65题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。 Case1: p有右子树， 答案next就是右子树最左节点Case2: p 无右子树, 且是父节点的左儿子，next就是父节点Case3: p 无右子树, 且是父节点的右儿子，那么沿着右分支往上一直找父节点，当前节点cur = parent; 当前节点的父节点parent = parent -&gt; m_pParent; 直到父节点parent是null（这时cur是根节点），或者还有父节点但是已经不是沿右分支了（parent -&gt; m_pRight ！= cur），那么这第一个左分支的父节点（parent）就是next。 123456789101112131415161718192021222324BinaryTreeNode *getNextNode(BinaryTreeNode *p) &#123;//不用传根，p带的就是树的信息 if (p == NULL) return NULL; BinaryTreeNode *nextNode = NULL; // 可以覆盖p是最后一个节点情况 if(p -&gt; m_pRight != NULL) &#123; // case1 BinaryTreeNode *right = p -&gt; m_pRight; while (right -&gt; m_pLeft != NULL) right = right -&gt; m_pLeft; nextNode = right; &#125;else if (p -&gt; m_pParent != NULL) &#123; // case2，3 可以一起处理 BinaryTreeNode *parent = p -&gt; m_pParent; BinaryTreeNode *cur = p; // case2 不会进入这个循环，因为不满足第二个条件 while (parent != NULL &amp;&amp; parent -&gt; m_pRight== cur) &#123;//沿右分支找父亲 cur = parent; parent = parent -&gt; m_pParent; &#125; // 循环结束，case3就转换到和case2的情况了 nextNode = parent; // 下一个节点就是父节点 &#125; return nextNode; // 如果p是最后一个节点，上面if else都不会执行&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer7. 重建二叉树 P62","slug":"剑指offer7","date":"2019-10-31T06:14:31.000Z","updated":"2019-11-01T08:46:56.222Z","comments":true,"path":"2019/10/31/剑指offer7/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer7/","excerpt":"","text":"剑指offer7. 重建二叉树 p62题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出 图2.6所示的二叉树并输出它的头结点。 123456789101112131415161718192021222324252627282930313233struct BinaryTreeNode &#123; int key; BinaryTreeNode *left; BinaryTreeNode *right; BinaryTreeNode(int val) &#123; key = val; left = right =NULL;&#125;&#125;; // pre,in 分别是先序和中序列，length是序列长 BinaryTreeNode *constructBinaryTree(std::vector&lt;int&gt; pre, std::vector&lt;int&gt; in, int length) &#123; if (pre.size() == 0 || in.size() == 0 || length == 0) return NULL; BinaryTreeNode *head = new BinaryTreeNode(pre[0]); //初始化根节点 // 下面四个数组分别存储左，右子树的先根，中根序列 std::vector&lt;int&gt; leftpre, leftin, rightpre, rightin; int root; // 根节点索引 for (int i = 0; i &lt; length; ++i) &#123; if (in[i] == pre[0]) &#123; // 在中根序列中找到当前树根节点root的索引 root = i; break; &#125; &#125; for (int i = 0; i &lt; root; ++i) &#123; // 以root为界左边是左子树的先序，中序 leftpre.push_back(pre[i + 1]); leftin.push_back(in[i]); &#125; for (int i = root + 1; i &lt;length; ++i) &#123;//以root为界右边是右子树的先序，中序 rightpre.push_back(pre[i]); rightin.push_back(in[i]); &#125; //在下面完成父子节点的链接 ，并递归构建左右子树 head -&gt; left = constructBinaryTree(leftpre, leftin, leftpre.size()); head -&gt; right = constructBinaryTree(rightpre, rightin, rightpre.size()); return head; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"剑指Offer6. 插入并从尾到头打印链表 P58","slug":"剑指offer6","date":"2019-10-31T06:14:27.000Z","updated":"2019-11-01T08:46:45.799Z","comments":true,"path":"2019/10/31/剑指offer6/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer6/","excerpt":"","text":"剑指offer6 . 插入并从尾到头打印链表P58题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。 1234567891011121314151617181920212223242526272829303132333435struct ListNode &#123; int key; ListNode *next;&#125;;void addToTail(ListNode **pHead, int value) &#123; // 调用时实参指针pHead应该取引用 ListNode *temp = new ListNode; temp -&gt; key = value; temp -&gt; next =NULL; if (*pHead == NULL) &#123; *pHead = temp; return; &#125; ListNode* p = *pHead; while (p -&gt; next != NULL) p = p -&gt; next; p -&gt; next = temp; &#125; void printListReversingly(ListNode *pHead) &#123; //用栈实现 反向便利 std:: stack&lt;ListNode* &gt; nodes; ListNode *p = pHead; while (p != NULL) &#123; nodes.push(p); p = p -&gt; next; &#125; while (!nodes.empty()) &#123; std::cout &lt;&lt; nodes.top() -&gt; key &lt;&lt; std:: endl; nodes.pop(); &#125;&#125;void printListReversingRecursively(ListNode *pHead) &#123; //递归实现 if (pHead == NULL) return; printListReversingRecursively(pHead -&gt; next); std:: cout&lt;&lt; pHead -&gt; key &lt;&lt; std:: endl; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指Offer5. 替换空格   P51","slug":"剑指offer5","date":"2019-10-31T06:14:21.000Z","updated":"2019-11-01T08:46:30.972Z","comments":true,"path":"2019/10/31/剑指offer5/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer5/","excerpt":"","text":"剑指offer 5. 替换空格 P511. 第一种做法可以用sting = “”,遍历原始数组，遇到非空格直接加，遇到空格加上%20，最后string就是答案。 这种做法比较简洁易懂，但是空间复杂度是O(N) 2. 第二种做法就是书上的用两个指针倒着工作。在原地操作，空间开销小 1234567891011121314151617181920212223void replaceBlank(char string[], int length) &#123; if (string == NULL || length &lt;= 0) return; int count = 0, old_tail = 0; // 记录空格数；原数组索引指针 while (string[old_tail] != '\\0') &#123; if (string[old_tail] == ' ') ++count; old_tail++; &#125; // 新数组结尾 int new_tail = old_tail + count * 2; //不是*3，因为原来的空格还可以放一个 if (new_tail &gt; length) return; //不能=， 因为’\\0’ while (old_tail &gt;= 0) &#123; // 两个指针一起倒着走 if (string[old_tail] != ' ') string[new_tail--] = string[old_tail]; else &#123; string[new_tail--] = '0'; string[new_tail--] = '2'; string[new_tail--] = '%'; &#125; old_tail--; //不能在if里面减 &#125; &#125; 扩展： 有两个从小到大排序数组a，b。 a尾部有足够的空间容纳b，试着把b合并到a中，并且保持依然有序。 思想：跟这题很像，可以确定a的新结尾len（a）+len(b) – 1；然后倒着遍历两数组，把较大的放入新结尾，更新工作指针。","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"剑指offer4.二维数组中查找  P44","slug":"剑指offer4","date":"2019-10-31T06:11:24.000Z","updated":"2019-11-01T08:45:59.007Z","comments":true,"path":"2019/10/31/剑指offer4/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer4/","excerpt":"","text":"剑指offer4. 二维数组中查找 P44题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 c++传二维数组，要么像下面这样传一维指针之后计算（此时实参不能new或者malloc出，因为地址可能不连续） 要么必须指明所有维数大小或者省略第一维的，但是不能省略第二维或者更高维的大小，这是由编译器原理限制的。编译器是这样处理数组的： 对于数组 int p[m][n];如果要取p[i][j]的值(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; 0&lt;=j &amp;&amp; j &lt; n)，编译器是这样寻址的，它的地址为： p + i*n + j; （p是数组首地址）所以不指定n的话，没办法计算。 建议用vector数组替代二维数组，使用灵活，且不涉及指针这种乱七八糟的操作。 12345678910111213141516/* 行是增的，列是减的 注意： 本题用不了横纵向的二分查找！！！*/bool findNumbers( const int *martix, int t, int rows, int columns) &#123; if ((martix == NULL) || (rows == 0 &amp;&amp; columns == 0)) return false; int x = 0, y = columns - 1; while (x &lt; rows &amp;&amp; y &gt;= 0) &#123; // 注意两个边界不一样 int temp = martix[x * columns + y]; if (temp == t) return true; else if (t &gt; temp) ++x; else --y; &#125; return false; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer 3. 数组中重复的(所有)数字","slug":"剑指offer3","date":"2019-10-31T04:04:12.000Z","updated":"2019-11-15T08:28:11.868Z","comments":true,"path":"2019/10/31/剑指offer3/","link":"","permalink":"http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer3/","excerpt":"","text":"3 . 数组中重复的(所有)数字 p39题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。（原题只是找出一个，下面实现比原题多一步，打印所有的） 1. 允许修改数组 因为每个数字都只能对应一个索引，从索引i=0开始一步一步找到所有i对应的数，那么一定会慢慢逼近到有个值是i，但是不在索引i（i已经有一个值=i了）上。尽管有for，while两重循环，但是基本上每一次比较之后要么前进，要么交换（交换后保证一个元素处在自己的索引位置, 遍历到它的时候就跳过，这也相当于前进了），所以时间复杂度还是O（n），空间复杂度是O（1） 1234567891011121314151617181920vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (nums[i] &lt; 1 || nums[i] &gt; nums.size()) // 有没有不符合规定的数 return ans; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; while (nums[nums[i]] != nums[i]) &#123; // 不相等，交换 int temp = nums[i]; nums[i] = nums[temp]; nums[temp] = temp; &#125; &#125; // 上面交换完成之后，所有只出现一次的数满足：i=nums[i] for (int i = 0; i &lt; nums.size(); ++i) &#123; if (nums[i] != i) ans.push_back(nums[i]); &#125; return ans; &#125; 2. 不允许修改数组 P41找出数组中重复的数字用O(1)空间，nlogn时间，不能找出来所有重复数字 123456789101112131415161718192021222324252627int countNumbersBetweenStartAndEnd(const int *nums, int length,int,start,int end) &#123; if (nums == NULL || length &lt; 1) return 0; int count = 0; for (int i = 0; i &lt; length; ++i) &#123; if (nums[i] &gt;= start &amp;&amp; nums[i] &lt;= end) ++count; &#125; return count;&#125;int findRepeatNumber(const int *nums, int length) &#123; if (nums == NULL || length &lt; 2) return -1; int start = 1; //这是边界范围，不是索引 int end = length - 1; while (start &lt;= end) &#123; int mid = ((end - start) &gt;&gt; 1) + start; //默认先在左边范围统计 int count = countNumbersBetweenStartAndEnd(nums, length, start, mid); if (start == end) &#123; // 循环出口 if (count &gt;= 2) return start; else return -1; // 没有找到 &#125; else &#123; if (count &gt; mid - start + 1) end = mid; // 确实在左边重复 else start = mid + 1; // 左边没有重复右“循环” &#125; &#125; &#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]}]}