<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>G2.int.BUPT</title>
  
  <subtitle>我爱网管</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-01T08:23:59.533Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郭源潮</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer41. 数据流中的中位数  P214</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer41/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer41/</id>
    <published>2019-11-01T08:13:28.000Z</published>
    <updated>2019-11-01T08:23:59.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer41-数据流中的中位数-P214"><a href="#剑指offer41-数据流中的中位数-P214" class="headerlink" title="剑指offer41. 数据流中的中位数  P214"></a>剑指offer41. 数据流中的中位数  P214</h2><p>题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值</p><p><strong>首先，题目说一个数据流，就证明可能不能一次读入内存</strong>（我们这里用一个数组模拟输入流）</p><p>如果将数组从中间一分为二，中间的一个（len是奇数）或者两个元素（len是偶数）左边都比他们小，右边都比他们大，前后两半部分不用排序，只用划分出来就行。那么最后在中间的就是中位数。<br><strong>左半部分是最大堆，右边是最小堆。</strong>  </p><p>这个想法是使用两个堆（一个最大堆，一个最小堆）保存输入数据。<br> max_pq是一个大堆，以较小的值保存数据的前半部分，而min_pq是最小堆，以较大的值保存数据的后半个。 每次插入新值时，我们都会先比较它是否小于max_pq的顶部（前一半的最大值），如果是，则将其插入max_pq。 否则，它属于下半部分。 插入后，我们必须平衡前半部分和后半部分，以确保它们具有相同的长度或长度差仅为1,否则最后两个堆顶的元素不在最中间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;<span class="keyword">int</span>&gt; max_pq; <span class="comment">//最大堆，其中最大元素堆顶也小于最小堆中任一元素</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; min_pq;  <span class="comment">// 最小堆，堆顶最小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isAnsValid = <span class="literal">false</span>;<span class="comment">// 返回0.0时有效与否</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addHeap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; <span class="comment">// 插入节点</span></span><br><span class="line"><span class="keyword">if</span> (max_pq.empty() || num &lt; max_pq.top()) &#123;    <span class="comment">// 先插入最大堆</span></span><br><span class="line">max_pq.push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                                <span class="comment">// 当前值比最大堆顶还大，插入最小堆</span></span><br><span class="line">min_pq.push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min_pq.size() &gt; max_pq.size() + <span class="number">1</span>) &#123;  <span class="comment">// 最小堆元素个数比最大的超过1，调整</span></span><br><span class="line"><span class="keyword">int</span> temp = min_pq.top();</span><br><span class="line">min_pq.pop();</span><br><span class="line">max_pq.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (max_pq.size() &gt; min_pq.size() + <span class="number">1</span>) &#123;  <span class="comment">// 同理</span></span><br><span class="line"><span class="keyword">int</span> temp = max_pq.top();</span><br><span class="line">max_pq.pop();</span><br><span class="line">min_pq.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findCore</span><span class="params">()</span> </span>&#123;  <span class="comment">// 找中位数</span></span><br><span class="line"><span class="keyword">if</span> (!max_pq.empty()) &#123;</span><br><span class="line">isAnsValid = <span class="literal">true</span>;                        <span class="comment">// 返回值有效</span></span><br><span class="line"><span class="keyword">if</span> (max_pq.size() == min_pq.size()) &#123;        <span class="comment">// len偶数，取均值</span></span><br><span class="line"><span class="keyword">return</span> (max_pq.top() + min_pq.top()) / <span class="number">2.0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                               <span class="comment">// len奇数，取堆顶</span></span><br><span class="line"><span class="keyword">return</span> (max_pq.size() &gt; min_pq.size()) ? max_pq.top() : min_pq.top();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="number">0.0</span>; <span class="comment">// 失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMidInList</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span> || len &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">while</span> (!max_pq.empty()) max_pq.pop();   <span class="comment">// 清空堆</span></span><br><span class="line"><span class="keyword">while</span> (!min_pq.empty()) min_pq.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;      <span class="comment">// 建堆</span></span><br><span class="line">addHeap(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> findCore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展</strong><br><strong>优先队列（堆）</strong><br>头文件：<code>#include&lt; queue &gt;</code><br>大根堆定义：<code>priority_queue&lt; int &gt;pq</code><br>小根堆定义：<code>priority_queue&lt; int ,vector&lt; int &gt;,greater&lt; int &gt; &gt;pq</code><br>（注意最后两个“&gt;”符号不要连在一起，否则很多编译器误认为是‘&gt;&gt;’运算符）   </p><p>操作：<br>push() 元素入队  pop() 队首元素出队    top() 取队首元素<br>empty() 如果队列为空，则返回true（1），否则返回false（0）<br>size() 返回优先队列中拥有的元素个数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer41-数据流中的中位数-P214&quot;&gt;&lt;a href=&quot;#剑指offer41-数据流中的中位数-P214&quot; class=&quot;headerlink&quot; title=&quot;剑指offer41. 数据流中的中位数  P214&quot;&gt;&lt;/a&gt;剑指offer41. 数据流中
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer40. 最小的K个数 P209</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer40/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer40/</id>
    <published>2019-11-01T07:26:35.000Z</published>
    <updated>2019-11-01T08:11:28.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer40-最小的k个数-P209"><a href="#剑指offer40-最小的k个数-P209" class="headerlink" title="剑指offer40. 最小的k个数  P209"></a>剑指offer40. 最小的k个数  P209</h2><p>题目：输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>方法一</strong>：类似于上一题39， 同样基于Partition函数对数组进行划分，基于第k个元素调整，使得第k个索引之前的都比num[k]小, k之后的都比nums[k]大。左边的k个数字就是最小的k个数字，但是这些数字可能无序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;<span class="keyword">int</span>&gt;  findCore(<span class="keyword">int</span> *nums,<span class="keyword">int</span> len) &#123;      <span class="comment">// 主调函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;     <span class="comment">// 返回list</span></span><br><span class="line"><span class="keyword">if</span> (!isValid(nums, len)) &#123;           <span class="comment">// 鲁棒性</span></span><br><span class="line"><span class="keyword">return</span> v; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = len &gt;&gt; <span class="number">1</span>;          <span class="comment">// 中位数索引</span></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = Partition(nums, start, end);  <span class="comment">// 第一次划分</span></span><br><span class="line"><span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;                   <span class="comment">// 出口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index &gt; k - <span class="number">1</span>)  </span><br><span class="line">end = index -  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">start = index + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   index = Partition(nums, start, end);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        v.push_back(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度是 O(n), 不适合海量数据（快排必须一次性读入内存）而且会污染数组。</strong></p><p><strong>方法2： 最大堆</strong></p><p>本方法使用于海量数据处理。大致思想是建一个K个数的大堆，每次拿一个数和堆顶元素比较，如果这个数比堆顶元素大，则必然不是最小的K个数，如果这个数比堆顶元素小，则与堆顶元素交换，然后在向下调整一次建成新的大堆，然后遍历所有的数，直到最小的K个数都进堆里。<br>这样既可以保证堆中是存的目前的最小的k个数，还不用一次性把所有数据读入内存，每次只从磁盘取一个和堆顶比较即可。时间复杂度O(nlogk), 但是非常适用海量数据<br><strong>注意：最大的K个数—- 建小堆        最小的K个数—-建大堆</strong></p><p>// 下面是自建大顶堆  或者允许的话，更简单的办法是用STL： 优先队列（见下一题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> k, <span class="keyword">int</span> parent)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (input == <span class="literal">NULL</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> <span class="keyword">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (child &lt; k)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((child + <span class="number">1</span> &lt; k) &amp;&amp; (input[child] &lt; input[child + <span class="number">1</span>]))</span><br><span class="line">   ++child;</span><br><span class="line">  <span class="keyword">if</span> (input[child]&gt;input[parent])</span><br><span class="line">  &#123;</span><br><span class="line">   Swap(&amp;input[child], &amp;input[parent]);</span><br><span class="line">   parent = child;</span><br><span class="line">   child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MinKNumber_op</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"> assert(input);    <span class="comment">// 鲁棒性</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = (<span class="number">2</span> * k - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)    <span class="comment">//利用前K个数建大堆</span></span><br><span class="line">  AdjustDown(input, k, i);</span><br><span class="line"> <span class="comment">//  遍历后边的数，如果小于堆顶元素则入堆</span></span><br><span class="line"> <span class="keyword">for</span> (i = k; i &lt; len; i++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (input[i] &lt; input[<span class="number">0</span>]) &#123;</span><br><span class="line">Swap(&amp;input[i], &amp;input[<span class="number">0</span>]);</span><br><span class="line">AdjustDown(input, k, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer40-最小的k个数-P209&quot;&gt;&lt;a href=&quot;#剑指offer40-最小的k个数-P209&quot; class=&quot;headerlink&quot; title=&quot;剑指offer40. 最小的k个数  P209&quot;&gt;&lt;/a&gt;剑指offer40. 最小的k个数  P2
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer39. 数组中出现次数超过一半的数字 P39</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer39/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer39/</id>
    <published>2019-11-01T07:26:30.000Z</published>
    <updated>2019-11-01T07:58:56.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer39-数组中出现次数超过一半的数字-P39"><a href="#剑指offer39-数组中出现次数超过一半的数字-P39" class="headerlink" title="剑指offer39. 数组中出现次数超过一半的数字 P39"></a>剑指offer39. 数组中出现次数超过一半的数字 P39</h2><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1, 2, 3, 2, 2, 2, 5, 4, 2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p><p><strong>1.    基于快排   （会污染数组）</strong><br>其实只要涉及顺序的问题，大多数都可以排序。这题可以建立在快排的基础上，每做一次划分之后，把当前划分元素的索引index返回，这个数就是整个数组第index小的数，如果index=len/2, 结束递归。因为出现次数超过数组长度一半的元素最后一定有一个在索引是len/2的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ansIsValid = <span class="literal">true</span>;          <span class="comment">// 全局变量，=true时返回的0代表没有找到</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> len)</span></span>&#123;  <span class="comment">//  输入鲁棒性检查</span></span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span> || len &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMoreHalf</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> len, <span class="keyword">int</span> num)</span></span>&#123;  <span class="comment">//看最后找到的元素的个数是否真的超过一半</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] == num) ++count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count &lt;= len / <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="comment">// 必须 &gt; len / 2 才行！！</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123; <span class="comment">//快排的一次划分，返回固定元素后的索引</span></span><br><span class="line"><span class="keyword">int</span> flag = nums[start];</span><br><span class="line"><span class="keyword">int</span> i = start, j = end;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= flag) --j;</span><br><span class="line"><span class="keyword">int</span> rightmin = nums[j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= flag) ++i;</span><br><span class="line">nums[j] = nums[i];</span><br><span class="line">nums[i] = rightmin;</span><br><span class="line">&#125;</span><br><span class="line">nums[start] = nums[i];</span><br><span class="line">nums[i] = flag;</span><br><span class="line">    <span class="keyword">return</span> i;            <span class="comment">// i的位置不会变了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCore</span><span class="params">(<span class="keyword">int</span> *nums,<span class="keyword">int</span> len)</span> </span>&#123;      <span class="comment">// 主调函数</span></span><br><span class="line">ansIsValid = <span class="literal">true</span>;         <span class="comment">// 默认答案无效，不仅下面鲁棒性要用，最后检验也要用</span></span><br><span class="line"><span class="keyword">if</span> (!isValid(nums, len)) &#123;           <span class="comment">// 鲁棒性</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = len &gt;&gt; <span class="number">1</span>;          <span class="comment">// 中位数索引</span></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = Partition(nums, start, end);  <span class="comment">// 第一次划分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  为什么比的是索引而不是值，因为index前后一边大一边小是确定的 </span></span><br><span class="line"><span class="comment">只有index到中间时，才能保证从头到中间，或者从中间到尾巴都是一个数</span></span><br><span class="line"><span class="comment">这样才能找到超过一半的数 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (index != mid) &#123;      <span class="comment">// 出口</span></span><br><span class="line"><span class="keyword">if</span> (index &gt; mid)  </span><br><span class="line">end = index -  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">start = index + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   index = Partition(nums, start, end);    <span class="comment">// 选择左还是右划分</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (isMoreHalf(nums, len, nums[index])) &#123;  <span class="comment">// 检验是不是真的个数超过数组长度一半</span></span><br><span class="line">ansIsValid = <span class="literal">false</span>;                   <span class="comment">// 确实超过</span></span><br><span class="line"><span class="keyword">return</span> nums[index];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                     </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2： 比较个数差  （没有污染数组）</strong></p><p>从个数入手，有一个数字出现次数超过一半，也就是说它比其他所有数字次数和都多。我们把这个数和其他数分成两组 “相对抗” , 用一个变量存数字res，另一个存次数count。遍历数组，当前数字和上一个相等，次数+1；不等，次数-1，如果次数减到0，把res更新为当前数字，count更新为1. 到最后因为我们要找的数次数比其他的和都多，那么它一定时最后一次把count设成1的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isAns = <span class="literal">true</span>;        <span class="comment">// 判断return 0 时是不是有效 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSBNumber</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">isAns = <span class="literal">true</span>;          <span class="comment">// 要在鲁棒性检查之前设置</span></span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span> || len &lt; <span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = nums[<span class="number">0</span>];      <span class="comment">// 上文中的res</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] != ans) &#123;</span><br><span class="line">--count;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">ans = nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;   <span class="comment">// 验证是不是真的个数超过一半 </span></span><br><span class="line"><span class="keyword">if</span> (nums[i] == ans)</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &lt;= len / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">isAns = <span class="literal">false</span>;  </span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer39-数组中出现次数超过一半的数字-P39&quot;&gt;&lt;a href=&quot;#剑指offer39-数组中出现次数超过一半的数字-P39&quot; class=&quot;headerlink&quot; title=&quot;剑指offer39. 数组中出现次数超过一半的数字 P39&quot;&gt;&lt;/a&gt;剑
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer38. 字符串全排列、子集 P197</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer38/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer38/</id>
    <published>2019-11-01T07:26:26.000Z</published>
    <updated>2019-11-01T08:38:46.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer38-字符串全排列、子集-P197"><a href="#剑指offer38-字符串全排列、子集-P197" class="headerlink" title="剑指offer38. 字符串全排列、子集 P197"></a>剑指offer38. 字符串全排列、子集 P197</h2><p>题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。</p><p><strong>方法一</strong> :  非递归方法（字典序，这种方法被用在STL库中）<br>转载自：<a href="https://www.cnblogs.com/pmars/p/3458289.html" target="_blank" rel="noopener">转载博客</a>  </p><p>对给定的字符集中的字符规定了一个先后关系，在此基础上规定两个全排列的先后是从左到右逐个比较对应的字符的先后。  </p><p>[例]字符集{1,2,3},较小的数字较先,这样按字典序生成的全排列是: 123,132,213,231,312,321  </p><p>一个全排列可看做一个字符串，字符串可有前缀、后缀。生成给定全排列的下一个排列：所谓一个的下一个就是这一个与下一个之间没有其他的。这就要求这一个与下一个有尽可能长的共同前缀。<br>例如：如何得到346987521的下一个  </p><ol><li>从尾部往前找第一个P(i-1) &lt; P(i)的位置，最终找到6是第一个，记录下6的位置i-1<pre><code>3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1</code></pre></li><li>从i位置往后找到最后一个大于6的数，最终找到7的位置，记录位置为m<pre><code>3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1</code></pre></li><li>交换位置i-1和m的值 ：  3 4 7 9 8 6 5 2 1</li><li>倒序i-1位置后的所有数据： 3 4 7 1 2 5 6 8 9</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">sort(str, str + len, cmp);  <span class="comment">// 按某种规则排序</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>, str);   <span class="comment">// 一定要先打印，不然排序后的第一个序列打印不了</span></span><br><span class="line"><span class="keyword">int</span> first = len - <span class="number">1</span>;   </span><br><span class="line"><span class="keyword">while</span> (first &gt; <span class="number">0</span> &amp;&amp; str[first] &lt; str[first - <span class="number">1</span>]) --first; <span class="comment">// 倒序找第一个比后面小的数字</span></span><br><span class="line"><span class="keyword">if</span> (first == <span class="number">0</span>) <span class="keyword">break</span>;     <span class="comment">// 如果倒序结束，都没有找到，说明序列完全递减，结束</span></span><br><span class="line"><span class="keyword">int</span> minBigger = first;   <span class="comment">// 从first位置出发，找比first-1大的数字里面的最小的</span></span><br><span class="line"><span class="keyword">while</span> (minBigger + <span class="number">1</span> &lt; len &amp;&amp; str[minBigger + <span class="number">1</span>] &gt; str[first - <span class="number">1</span>]) ++minBigger;</span><br><span class="line"></span><br><span class="line">swap(str, minBigger, first - <span class="number">1</span>);    <span class="comment">// 交换两个值</span></span><br><span class="line">    reverse(str + first, str + len);     <span class="comment">// 倒置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2</strong>：递归<br>递归全排列 1 2 3 4 5<br>    1，for循环将每个位置的数据交换到第一位         swap(1,1~5)<br>2，按相同的方式全排列剩余的位  </p><p>关于循环里面有递归可以这么想：在最外层的需求是要把当前序列的第一个数和后面的每一个都交换，显然递归是做不到的，只能用循环。在交换之后，要对除了当前子序列的第一个元素外的剩余元素做全排列，这显然是递归过程。两者是分层的嵌套关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prem</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (start &gt;= end)     <span class="comment">// 起始位置等于终止位置，自然不往下递归交换了，结束并输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>, str);   </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; ++i) &#123;   <span class="comment">// 把起始位置和后面的位置依此交换</span></span><br><span class="line">          <span class="comment">// sort(str + i, str + end + 1,cmp); 如果要按某种顺序输出，这里排序</span></span><br><span class="line">swap(str, i, start);</span><br><span class="line"></span><br><span class="line">    prem(str, start + <span class="number">1</span>, end);    <span class="comment">// 递归下一个位置</span></span><br><span class="line"></span><br><span class="line">swap(str, i, start);       </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">premation</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span> </span>&#123;   <span class="comment">// 主调函数</span></span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">prem(str, <span class="number">0</span>, len - <span class="number">1</span>);         <span class="comment">// 全排列的起始位置，终止位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展: 求组合数（子集）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; zuhe(<span class="keyword">char</span> *str) &#123;  <span class="comment">// 主调函数，返回二维list 存储所有子集</span></span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; ans ;  </span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">char</span>&gt; t;                <span class="comment">// 存储当前遍历到的一个子集</span></span><br><span class="line">DFS(str, <span class="number">0</span>, t, ans);</span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> index, <span class="built_in">vector</span> &lt;<span class="keyword">char</span>&gt; &amp;t, <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">ans.push_back(t);            <span class="comment">// 第一次调用，存的空集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = index; j &lt; <span class="built_in">strlen</span>(str); ++j) &#123;</span><br><span class="line">t.push_back(str[j]);       <span class="comment">// 当前数字加入当前子集中</span></span><br><span class="line">DFS(str, j + <span class="number">1</span>, t, ans);     <span class="comment">// 递归下一个位置的数</span></span><br><span class="line">t.pop_back();            <span class="comment">// 回溯，当前子集舍弃当前数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展</strong>：<br>      1.     8个数放正方体的8个顶点，要求任意一个面的4个顶点和相等<br>       2.    8皇后问题，8个皇后放在8*8棋盘，不能同行，同列，或者对角线 P200</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer38-字符串全排列、子集-P197&quot;&gt;&lt;a href=&quot;#剑指offer38-字符串全排列、子集-P197&quot; class=&quot;headerlink&quot; title=&quot;剑指offer38. 字符串全排列、子集 P197&quot;&gt;&lt;/a&gt;剑指offer38. 字符
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer37. 序列化，反序列化二叉树 P194</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer37/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer37/</id>
    <published>2019-11-01T07:26:23.000Z</published>
    <updated>2019-11-01T07:48:32.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer37-序列化，反序列化二叉树-P194（书上用的流操作）"><a href="#剑指offer37-序列化，反序列化二叉树-P194（书上用的流操作）" class="headerlink" title="剑指offer37. 序列化，反序列化二叉树 P194（书上用的流操作）"></a>剑指offer37. 序列化，反序列化二叉树 P194（书上用的流操作）</h2><p>题目：请实现两个函数，分别用来序列化和反序列化二叉树。<br>比如：下面这颗树的先序序列化是： 1 2 $ $ 3 $ $ ($表示空节点)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure><p>// 序列化二叉树  ，用队列模拟流操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serilize</span><span class="params">(BinaryTreeNode *root, <span class="built_in">queue</span> &lt;<span class="keyword">char</span>&gt; &amp;q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">q.push(<span class="string">'$'</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.push(root -&gt; m_nValue );</span><br><span class="line">    serilize(root -&gt; m_pLeft, ans);</span><br><span class="line">    serilize(root -&gt; m_pRight, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 反序列化二叉树 ,根据序列q，还原二叉树 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseSerilize</span><span class="params">(BinaryTree **root, <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q.empty()) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (q.fornt() == <span class="string">'$'</span>) &#123;<span class="comment">//当前节点是空，无操作，因为下面在创建节点时左右节点默认空</span></span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">*root = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">(*root) -&gt; m_nValue = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">(*root) -&gt; m_pLeft = <span class="literal">NULL</span>;  </span><br><span class="line">(*root) -&gt; m_pRight = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">reverseSerilize(&amp;((*root) -&gt; m_pLeft), q);</span><br><span class="line">reverseSerilize(&amp;((*root) -&gt; m_pRight), q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer37-序列化，反序列化二叉树-P194（书上用的流操作）&quot;&gt;&lt;a href=&quot;#剑指offer37-序列化，反序列化二叉树-P194（书上用的流操作）&quot; class=&quot;headerlink&quot; title=&quot;剑指offer37. 序列化，反序列化二叉树
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer36. 二叉搜索树BST转换成双向链表 P191</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer36/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer36/</id>
    <published>2019-11-01T07:26:19.000Z</published>
    <updated>2019-11-01T07:45:33.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer36-二叉搜索树BST转换成双向链表-P191"><a href="#剑指offer36-二叉搜索树BST转换成双向链表-P191" class="headerlink" title="剑指offer36. 二叉搜索树BST转换成双向链表 P191"></a>剑指offer36. 二叉搜索树BST转换成双向链表 P191</h2><p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p><strong>首先，牵扯到排序，就只能对BST中序遍历（这也是下面递归函数的模板）。另外，双向链表有左右两个指针，二叉树刚好左右两指针，通过对比显然可以用二叉树的left指针充当链表前驱指针，right指针充当后继指针。至于为什么要在递归函数中多一个lastnode，是因为一次指针变更操作，（除了涉及空节点的）操作节点一定是两个（一个指针指向另一个节点），所以需要给当前递归的操作节点显式地指明它的前驱或者后继。</strong></p><p>// 主调函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode *<span class="title">convert</span><span class="params">(BinaryTreeNode *proot)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (proot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode *lastNode = <span class="literal">NULL</span>;    <span class="comment">// 前驱节点，最左叶节点前驱是NULL</span></span><br><span class="line">preOrderConvert(proot, &amp;lastNode);   <span class="comment">// 递归转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后递归结束，lastnode指向的是链表的最右节点，但是应该返回最左的头结点</span></span><br><span class="line"><span class="comment">//书上多一个判lastnode空，因为在书上函数开始没有判空</span></span><br><span class="line"><span class="keyword">while</span> (lastNode -&gt; m_pLeft != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">lastNode = lastNode -&gt; m_pLeft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lastNode;                    <span class="comment">// 返回双向链表左头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 递归转换，传入当前节点和当前节点前驱节点<strong>（实际上就是中序遍历模板）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderConvert</span><span class="params">(BinaryTreeNode *root, BinaryTreeNode **lastNode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;                      <span class="comment">// 递归出口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root -&gt; m_pLeft != <span class="literal">NULL</span>)                  <span class="comment">// 左递归</span></span><br><span class="line">preOrderConvert(root -&gt; m_pLeft, lastNode);</span><br><span class="line"></span><br><span class="line">root -&gt; m_pLeft = *lastNode;     <span class="comment">// 当前节点前驱指针指向前驱节点</span></span><br><span class="line"><span class="keyword">if</span> ((*lastNode) != <span class="literal">NULL</span>) &#123;          <span class="comment">// 前驱节点不是空，前驱的后继节点指向当前节点</span></span><br><span class="line">(*lastNode) -&gt; m_pRight = root;  <span class="comment">// 只有root是最左叶节点才不执行，没有前驱</span></span><br><span class="line">&#125; </span><br><span class="line">(*lastNode) = root;                 <span class="comment">// 更新前驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root -&gt; m_pRight != <span class="literal">NULL</span>)                  <span class="comment">// 右递归</span></span><br><span class="line">preOrderConvert(root -&gt; m_pRight, lastNode);                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>// 思考：把双向链表转换成BST ？</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer36-二叉搜索树BST转换成双向链表-P191&quot;&gt;&lt;a href=&quot;#剑指offer36-二叉搜索树BST转换成双向链表-P191&quot; class=&quot;headerlink&quot; title=&quot;剑指offer36. 二叉搜索树BST转换成双向链表 P191&quot;
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer35. 复杂链表的复制 P187</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer35/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer35/</id>
    <published>2019-11-01T07:26:16.000Z</published>
    <updated>2019-11-01T07:42:28.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer35-复杂链表的复制P187"><a href="#剑指offer35-复杂链表的复制P187" class="headerlink" title="剑指offer35. 复杂链表的复制P187"></a>剑指offer35. 复杂链表的复制P187</h2><p>题目：请实现函数ComplexListNode* Clone(ComplexListNode* pHead)，复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指向下一个结点外，还有一个m_pSibling 指向链表中的任意结点或者nullptr。</p><p><strong>方法1</strong>：  空间方法是用hash表存（N，N^）的映射<br><strong>方法2</strong>：  时间方法分三步：<br>                               1 把复制后的节点N^接到N后边<br>                                    2 设置每个N^的slibing指针<br>                                          3. 将N和N^分开保存为原始链表和copy后的链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cloneNodes</span><span class="params">(ComplexListNode *head)</span> </span>&#123;   <span class="comment">// 第一步：复制后的节点N^接到N后边</span></span><br><span class="line">ComplexListNode *p = head;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ComplexListNode *temp = <span class="keyword">new</span> ComplexListNode();</span><br><span class="line">temp -&gt; m_nValue = p -&gt; m_nValue;</span><br><span class="line">temp -&gt; m_pNext = p -&gt; m_pNext;</span><br><span class="line">p -&gt; m_pNext = temp;</span><br><span class="line">p = temp -&gt; m_pNext; </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectSiblingNodes</span><span class="params">(ComplexListNode *head)</span> </span>&#123;  <span class="comment">// 第二步：设置每个N^的slibing</span></span><br><span class="line">ComplexListNode *p = head;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ComplexListNode *temp = p -&gt; m_pNext;</span><br><span class="line"><span class="keyword">if</span> (p -&gt; m_pSibling != <span class="literal">NULL</span>) &#123;</span><br><span class="line">temp -&gt; m_pSibling = p -&gt; m_pSibling -&gt; m_pNext; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> temp -&gt; m_pSibling = <span class="literal">NULL</span>;        <span class="comment">// 可以不写，m_pSibling默认的是null </span></span><br><span class="line">p = temp -&gt; m_pNext;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ComplexListNode *<span class="title">reconnectNodes</span><span class="params">(ComplexListNode *head)</span></span>&#123;  <span class="comment">// 第三步，拆分两个链表</span></span><br><span class="line">ComplexListNode *newHead = head -&gt; m_pNext;        <span class="comment">// copy链表头</span></span><br><span class="line"></span><br><span class="line">ComplexListNode *p = head, *cp = newHead;</span><br><span class="line"><span class="keyword">while</span> (cp -&gt; m_pNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p -&gt; m_pNext   =  cp -&gt; m_pNext;</span><br><span class="line">cp -&gt; m_pNext  =  cp -&gt; m_pNext -&gt; m_pNext;</span><br><span class="line">p = p -&gt; m_pNext;</span><br><span class="line">cp = cp -&gt; m_pNext;</span><br><span class="line">&#125;</span><br><span class="line">p -&gt; m_pNext = cp -&gt;m_pNext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ComplexListNode* <span class="title">Clone</span><span class="params">(ComplexListNode* pHead)</span> <span class="comment">// 依次调用三个函数</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">if</span> (pHead == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    cloneNodes(pHead);</span><br><span class="line">    connectSiblingNodes(pHead);</span><br><span class="line">    <span class="keyword">return</span> reconnectNodes(pHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer35-复杂链表的复制P187&quot;&gt;&lt;a href=&quot;#剑指offer35-复杂链表的复制P187&quot; class=&quot;headerlink&quot; title=&quot;剑指offer35. 复杂链表的复制P187&quot;&gt;&lt;/a&gt;剑指offer35. 复杂链表的复制P187
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer34. 二叉树路径和 P182</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer34/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer34/</id>
    <published>2019-11-01T07:26:13.000Z</published>
    <updated>2019-11-01T07:38:46.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer34-二叉树路径和-P182"><a href="#剑指offer34-二叉树路径和-P182" class="headerlink" title="剑指offer34.  二叉树路径和  P182"></a>剑指offer34.  二叉树路径和  P182</h2><p>题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p>// <strong>主递归函数参数: 当前节点 上一步路径和 期待值 路径存储数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_FindPath</span><span class="params">(BinaryTreeNode *root, <span class="keyword">int</span> sum, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span> || root -&gt; m_nValue + sum &gt; k) <span class="keyword">return</span> ; <span class="comment">// 当前路径和大于k，返回</span></span><br><span class="line">path.push_back(root -&gt; m_nValue);                   <span class="comment">// 否则，把节点加入path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root -&gt; m_nValue + sum &lt; k) &#123;      <span class="comment">// 小于k，递归往下找， </span></span><br><span class="line"><span class="comment">//  递归放在打印前就不用显示判断叶节点</span></span><br><span class="line">DFS_FindPath(root -&gt; m_pLeft,  sum + root -&gt; m_nValue, k, path);</span><br><span class="line">DFS_FindPath(root -&gt; m_pRight, sum + root -&gt; m_nValue, k, path);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;                           <span class="comment">// 等于k，打印路径path</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : path) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125; </span><br><span class="line">path.pop_back();             <span class="comment">// 回溯，把当前节点移除，继续找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer34-二叉树路径和-P182&quot;&gt;&lt;a href=&quot;#剑指offer34-二叉树路径和-P182&quot; class=&quot;headerlink&quot; title=&quot;剑指offer34.  二叉树路径和  P182&quot;&gt;&lt;/a&gt;剑指offer34.  二叉树路径和  
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer33. 二叉搜索树的后序遍历序列 P179</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer33/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer33/</id>
    <published>2019-11-01T07:26:09.000Z</published>
    <updated>2019-11-01T07:36:08.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer33-二叉搜索树的后序遍历序列-P179"><a href="#剑指offer33-二叉搜索树的后序遍历序列-P179" class="headerlink" title="剑指offer33.  二叉搜索树的后序遍历序列   P179"></a>剑指offer33.  二叉搜索树的后序遍历序列   P179</h2><p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。  </p><p><strong>首先要明确的是：每一个子序列的最后一个数是根结点（end标识）</strong></p><ol><li><p>找到左子树子序列，左子树子序列可以通过从当前子序列开始索引start向后扫描，直到出现比根结点大的元素就停止（因为左子树子序列都是小于根节点的）；</p></li><li><p>剩下的子序列是右子树子序列（不包含子序列最后节点end也就是根节点），检查右子树子序列中所有元素是否都大于根结点元素，如果存在小于根节点的元素，则不满足二叉搜索树的定义，返回false.</p></li><li><p>递归地判断左子树和右子树是否是二叉搜索树。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBSTPostOrder</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;  <span class="comment">// 原始输入序列，子序列的首尾索引</span></span><br><span class="line"><span class="keyword">if</span> (num == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">// 鲁棒性 （如果有主调函数可以放在主调里）</span></span><br><span class="line"><span class="keyword">if</span> (start &gt;= end)   <span class="keyword">return</span> <span class="literal">true</span>;             <span class="comment">// 没有发现异常，两个成功相遇</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = num[end];                     <span class="comment">// 根节点是最后一个节点</span></span><br><span class="line"><span class="keyword">int</span> i = start;                            <span class="comment">// 开始索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; i &lt; end; ++i) &#123;         <span class="comment">// 从开始索引找第一个比根大的节点，注意条件不能=end</span></span><br><span class="line"><span class="keyword">if</span> (num[i] &gt; root) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;                                 <span class="comment">// 此时i存的是第一个比根大的节点的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; end ; ++j) &#123;      <span class="comment">// 从下一个位置出发，看右子树有没有比根小的</span></span><br><span class="line"><span class="keyword">if</span> (num[j] &lt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 递归左右子树看是否满足BST</span></span><br><span class="line"><span class="keyword">return</span> (isBSTPostOrder(num, start, i - <span class="number">1</span>)  &amp;&amp;  isBSTPostOrder(num, i, end - <span class="number">1</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这个递归函数的end参数是子序列最后一个索引，调用的时候传的length - 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer33-二叉搜索树的后序遍历序列-P179&quot;&gt;&lt;a href=&quot;#剑指offer33-二叉搜索树的后序遍历序列-P179&quot; class=&quot;headerlink&quot; title=&quot;剑指offer33.  二叉搜索树的后序遍历序列   P179&quot;&gt;&lt;/a&gt;剑
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer32. 从上到下打印二叉树 P171（三种层次遍历的要求）</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer32/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer32/</id>
    <published>2019-11-01T07:26:06.000Z</published>
    <updated>2019-11-01T07:33:29.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer32-从上到下打印二叉树-P171（三种层次遍历的要求）"><a href="#剑指offer32-从上到下打印二叉树-P171（三种层次遍历的要求）" class="headerlink" title="剑指offer32.  从上到下打印二叉树 P171（三种层次遍历的要求）"></a>剑指offer32.  从上到下打印二叉树 P171（三种层次遍历的要求）</h2><p><strong>1.    不分（换）行，从上到下打印二叉树</strong>   </p><p>原始的层次遍历  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PrintFromTopToBottom1</span><span class="params">(BinaryTreeNode *pRoot)</span> </span>&#123;  <span class="comment">// 不分行层次打印 </span></span><br><span class="line"><span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;BinaryTreeNode* &gt; q;</span><br><span class="line">q.push(pRoot);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;                        <span class="comment">// 层次遍历</span></span><br><span class="line">BinaryTreeNode *p = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, p -&gt; m_nValue);</span><br><span class="line"><span class="keyword">if</span> (p -&gt; m_pLeft) q.push(p -&gt; m_pLeft);</span><br><span class="line"><span class="keyword">if</span> (p -&gt; m_pRight) q.push(p -&gt; m_pRight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 分行（层）打印二叉树</strong>  </p><p><strong>两个变量分别存当前行的节点个数，和下一行节点个数</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PrintFromTopToBottom2</span><span class="params">(BinaryTreeNode *pRoot)</span> </span>&#123;    <span class="comment">// 分行层次打印 </span></span><br><span class="line"><span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;BinaryTreeNode* &gt; q;</span><br><span class="line">q.push(pRoot);</span><br><span class="line">    <span class="keyword">int</span> currentLayCount = <span class="number">1</span>, nextLayCount = <span class="number">1</span>;   <span class="comment">// 分别存当前行和下一行的节点数 </span></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">currentLayCount = nextLayCount;      <span class="comment">//  每一次打印一行时，更新两个变量</span></span><br><span class="line">nextLayCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (currentLayCount &gt; <span class="number">0</span>) &#123;           <span class="comment">//  打印当前行</span></span><br><span class="line">BinaryTreeNode *p = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, p -&gt; m_nValue);</span><br><span class="line"><span class="keyword">if</span> (p -&gt; m_pLeft) &#123;</span><br><span class="line">q.push(p -&gt; m_pLeft);</span><br><span class="line">nextLayCount++;      </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (p -&gt; m_pRight)  &#123;</span><br><span class="line">q.push(p -&gt; m_pRight);</span><br><span class="line">nextLayCount++;</span><br><span class="line">&#125;</span><br><span class="line">--currentLayCount;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);         </span><br><span class="line">    &#125;     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>3  .之字形打印二叉树</strong>  </p><p>题目：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印 其他行以此类推。</p><p><strong>用两个栈交替存当前行和下一行，偶数行的子节点从左往右入栈（保证下一行从右到左输出），奇数行的与之相反。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PrintFromTopToBottom</span><span class="params">(BinaryTreeNode *pRoot)</span> </span>&#123;   <span class="comment">// 之字型打印二叉树 </span></span><br><span class="line"><span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;BinaryTreeNode* &gt; s[<span class="number">2</span>];    <span class="comment">//两个辅助栈，0代表偶数行，（省去判奇偶的操作）</span></span><br><span class="line"><span class="keyword">int</span>  current = <span class="number">0</span>, next = <span class="number">1</span>;       <span class="comment">// 当前和下一行要访问的栈是s[0]还是s[1] </span></span><br><span class="line">s[<span class="number">0</span>].push(pRoot);              <span class="comment">// 默认根节点是偶数行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s[<span class="number">0</span>].empty() || !s[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">BinaryTreeNode *node =  s[current].top();   <span class="comment">// 当前栈出栈</span></span><br><span class="line">s[current].pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, node -&gt; m_nValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>) &#123;                   <span class="comment">// 0栈是正向,从左到右入栈</span></span><br><span class="line">            <span class="keyword">if</span> (node -&gt; m_pLeft) &#123;</span><br><span class="line">        s[next].push(node -&gt; m_pLeft);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (node -&gt; m_pRight)  &#123;</span><br><span class="line">        s[next].push(node -&gt; m_pRight);</span><br><span class="line">    &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                           <span class="comment">// 1栈是反向 从右到左入栈</span></span><br><span class="line"><span class="keyword">if</span> (node -&gt; m_pRight)  &#123;</span><br><span class="line">        s[next].push(node -&gt; m_pRight);</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">if</span> (node -&gt; m_pLeft) &#123;</span><br><span class="line">        s[next].push(node -&gt; m_pLeft);</span><br><span class="line">    &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[current].empty()) &#123;              <span class="comment">// 一行打印结束，（写的真好）</span></span><br><span class="line">            current = <span class="number">1</span> - current;          <span class="comment">//  奇偶互换</span></span><br><span class="line">            next = <span class="number">1</span> - next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer32-从上到下打印二叉树-P171（三种层次遍历的要求）&quot;&gt;&lt;a href=&quot;#剑指offer32-从上到下打印二叉树-P171（三种层次遍历的要求）&quot; class=&quot;headerlink&quot; title=&quot;剑指offer32.  从上到下打印二叉树 
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer31.栈的压入弹出序列 P168</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer31/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer31/</id>
    <published>2019-11-01T07:25:06.000Z</published>
    <updated>2019-11-01T07:28:15.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer31-栈的压入弹出序列-P168"><a href="#剑指offer31-栈的压入弹出序列-P168" class="headerlink" title="剑指offer31. 栈的压入弹出序列    P168"></a>剑指offer31. 栈的压入弹出序列    P168</h2><p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。</p><p><strong>用辅助栈 s，nums是给定的弹出序列，inputs是压栈序列</strong></p><ol><li>如果栈不空，而且而且下一个弹出数字num恰好时栈顶数字，直接弹出</li><li>如果num和栈顶元素不等，把压栈序列inputs中num及num之前的数字压栈，如果在inputs这一轮的压栈中没有找到num，匹配失败。</li><li>最后两个序列都走到末尾，而且辅助栈空，匹配成功</li></ol><p><strong>换句话说：在弹出串中找到栈顶值之前，把没有访问过的输入串元素入栈，更新没有访问的元素头索引vis ，如果到最后都没有找到当前栈顶值，匹配失败</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找并压栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findAndPush</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> *input, <span class="keyword">const</span> <span class="keyword">int</span> *pattern, <span class="keyword">int</span> &amp;vis, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = vis + <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">s.push(input[i]);</span><br><span class="line"><span class="keyword">if</span> (input[i] == pattern[index]) &#123;</span><br><span class="line">vis = i;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *input, <span class="keyword">const</span> <span class="keyword">int</span> *pattern, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (input == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span> || len &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> vis = <span class="number">-1</span>;           <span class="comment">// 不能从0开始，因为find函数里从vis+1开始压栈 </span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">findAndPush(s,input, pattern, vis, len, <span class="number">0</span>);<span class="comment">//初始 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = pattern[i];</span><br><span class="line"><span class="keyword">if</span> (!s.empty() &amp;&amp; s.top() == temp) &#123; <span class="comment">// 栈顶和当前值相等，比较下一个元素 </span></span><br><span class="line">s.pop();</span><br><span class="line">++i;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ( !findAndPush(s, input, pattern, vis, len, i) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;            <span class="comment">// 找不到匹配失败 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer31-栈的压入弹出序列-P168&quot;&gt;&lt;a href=&quot;#剑指offer31-栈的压入弹出序列-P168&quot; class=&quot;headerlink&quot; title=&quot;剑指offer31. 栈的压入弹出序列    P168&quot;&gt;&lt;/a&gt;剑指offer31. 栈的
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈&amp;队列" scheme="http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer30. 包含Min函数的栈 P165</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer30/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer30/</id>
    <published>2019-11-01T06:34:35.000Z</published>
    <updated>2019-11-01T07:19:03.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer30-包含min函数的栈-P165"><a href="#剑指offer30-包含min函数的栈-P165" class="headerlink" title="剑指offer30. 包含min函数的栈   P165"></a>剑指offer30. 包含min函数的栈   P165</h2><p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。</p><p><strong>构造一共辅助栈min，栈顶是当前数据栈data中的最小元素。 即：每次数据num入数据栈data时，把num和当前min栈顶元素tip比较，存入较小的那个到min栈（只把栈顶做比较，不要弹栈；假如栈顶小，再压入一个栈顶元素，否则，压入num）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">StackWithMin</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StackWithMin() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~StackWithMin() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt;   m_data;     <span class="comment">// 数据栈，存放栈的所有元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt;   m_min;      <span class="comment">// 辅助栈，存放栈的最小元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> StackWithMin&lt;T&gt;::push(<span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 把新元素添加到辅助栈</span></span><br><span class="line">    m_data.push(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当新元素比之前的最小元素小时，把新元素插入辅助栈里；</span></span><br><span class="line">    <span class="comment">// 否则把之前的最小元素重复插入辅助栈里</span></span><br><span class="line">    <span class="keyword">if</span>(m_min.size() == <span class="number">0</span> || value &lt; m_min.top())</span><br><span class="line">        m_min.push(value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m_min.push(m_min.top());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> StackWithMin&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行。</span></span><br><span class="line">    assert(m_data.size() &gt; <span class="number">0</span> &amp;&amp; m_min.size() &gt; <span class="number">0</span>);</span><br><span class="line">    m_data.pop();</span><br><span class="line">    m_min.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; StackWithMin&lt;T&gt;::min() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(m_data.size() &gt; <span class="number">0</span> &amp;&amp; m_min.size() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_min.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T&amp; StackWithMin&lt;T&gt;::top()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; StackWithMin&lt;T&gt;::top() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> StackWithMin&lt;T&gt;::empty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">size_t</span> StackWithMin&lt;T&gt;::size() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer30-包含min函数的栈-P165&quot;&gt;&lt;a href=&quot;#剑指offer30-包含min函数的栈-P165&quot; class=&quot;headerlink&quot; title=&quot;剑指offer30. 包含min函数的栈   P165&quot;&gt;&lt;/a&gt;剑指offer30. 
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈&amp;队列" scheme="http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer29. 顺时针打印矩阵 P161</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer29/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer29/</id>
    <published>2019-11-01T06:34:29.000Z</published>
    <updated>2019-11-01T07:16:40.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer29-顺时针打印矩阵-P161"><a href="#剑指offer29-顺时针打印矩阵-P161" class="headerlink" title="剑指offer29.  顺时针打印矩阵    P161"></a>剑指offer29.  顺时针打印矩阵    P161</h2><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。<br>1   2   3   4<br>5   6   7   8<br>9   10  11  12<br>13  14  15  16           打印： 1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</p><p><strong>当我们顺时针打印该矩阵时，每一圈的起始位置是左上角的元素，并且每一圈左上角元素都有一个共同点：它的行rows和列cols所对应的的下标都是相同的。因此不难想到，该矩阵打印结束的条件就是左上角的元素下标走到了该矩阵行和列的一半时，该矩阵打印结束了。因为矩阵也是用下标来确定某个数字的，所以这里就是：rows &gt; start * 2 &amp;&amp; cols &gt; start * 2</strong></p><p>矩阵打印一圈需要四步（从左到右，从上到下，从右到左，从下到上），这个是一般情况，当矩阵是行大于列、列大于行的时候可能不需要四步，就可以打印结束</p><p>无论是一个怎样的矩阵，它都会进行第一步从左到右，并且如果打印一个矩阵它进行了第三步，那么一定走了一二步，也就是说后面的每一步是建立在前面步的基础之上的，总结一下打印每一圈：<br>（1）<strong>从左往右</strong>：肯定有；</p><p>（2）<strong>从上到下</strong>：矩阵行数至少为2，即：终止行号必须大于起始行号（这里不可以等于，否则会产生矩阵右上角的元素重复多打印一次）；</p><p>（3）<strong>从右往左</strong>：矩阵至少为两行两列，即：终止列号必须大于起始列号，并且终止行号必须大于起始行号（同样，不可以等于，否则矩阵右下角的元素会多打印一次）；</p><p>（4）<strong>从下到上</strong>：矩阵至少为三行两列，即：终止行号必须比起始行号大2，并且终止列号必须大于起始列号（同样，不可以等于，否则会出现左下角和右上角元素多打印一次）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> **number, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (number == <span class="literal">NULL</span> || rows &lt; <span class="number">0</span> || cols &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (rows == <span class="number">0</span> &amp;&amp; cols == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;                      <span class="comment">// 对角线上的行列号 </span></span><br><span class="line"><span class="keyword">while</span> (rows &gt; start * <span class="number">2</span> &amp;&amp; cols &gt; start * <span class="number">2</span>) &#123;</span><br><span class="line">printMatrix(number, rows, cols, start);</span><br><span class="line">++start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> **a, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> start)</span> </span>&#123;   <span class="comment">//顺时针打印一圈</span></span><br><span class="line"><span class="keyword">int</span> endx = rows - start - <span class="number">1</span>, endy = cols - start - <span class="number">1</span>;   <span class="comment">// 终止行号和列号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= endy; ++i) &#123;                  <span class="comment">// 从左往右，直接打印</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[start][i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (endx &gt; start) &#123;                            <span class="comment">// 从上到下：终止行号必须大于起始行号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endx; ++i) &#123; <span class="comment">//  从start+1开始，不然重复打 </span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; a[i][endy] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endx &gt; start &amp;&amp; endy &gt; start) &#123;  <span class="comment">// 从右往左：终止列号必须大于起始列号，并且终止行号必须大于起始行号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = endy - <span class="number">1</span>; i &gt;= start; --i) &#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[endx][i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endx - <span class="number">1</span> &gt; start &amp;&amp; endy &gt; start) &#123;   <span class="comment">//从下到上：终止行号必须比起始行号大2，并且终止列号必须大于起始列号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = endx - <span class="number">1</span>; i &gt; start; --i) &#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i][start] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer29-顺时针打印矩阵-P161&quot;&gt;&lt;a href=&quot;#剑指offer29-顺时针打印矩阵-P161&quot; class=&quot;headerlink&quot; title=&quot;剑指offer29.  顺时针打印矩阵    P161&quot;&gt;&lt;/a&gt;剑指offer29.  顺时针
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer28. 对称的二叉树 P159</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer28/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer28/</id>
    <published>2019-11-01T06:34:26.000Z</published>
    <updated>2019-11-01T07:12:39.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer28-对称的二叉树-P159"><a href="#剑指offer28-对称的二叉树-P159" class="headerlink" title="剑指offer28. 对称的二叉树  P159"></a>剑指offer28. 对称的二叉树  P159</h2><p>题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(BinaryTreeNode *proot1, BinaryTreeNode *proot2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (proot1 == <span class="literal">NULL</span> &amp;&amp; proot2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (proot1 == <span class="literal">NULL</span> || proot2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (proot1 -&gt; key != proot2 -&gt; key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意下面，1的左子树和2的右子树比较，不要惯性思维搞错！</span></span><br><span class="line"><span class="keyword">return</span> judge(proot1 -&gt; left, proot2 -&gt; right) &amp;&amp; judge(proot1 -&gt; right, proot2 -&gt; left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer28-对称的二叉树-P159&quot;&gt;&lt;a href=&quot;#剑指offer28-对称的二叉树-P159&quot; class=&quot;headerlink&quot; title=&quot;剑指offer28. 对称的二叉树  P159&quot;&gt;&lt;/a&gt;剑指offer28. 对称的二叉树  P1
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer27.二叉树的镜像 P157</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer27/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer27/</id>
    <published>2019-11-01T06:34:20.000Z</published>
    <updated>2019-11-01T07:10:28.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer27-二叉树的镜像-P157"><a href="#剑指offer27-二叉树的镜像-P157" class="headerlink" title="剑指offer27.二叉树的镜像 P157"></a>剑指offer27.二叉树的镜像 P157</h2><p>题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><strong>// 其实就是先根遍历的模板，在左右子树递归访问前交换左右子树</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MirrorRecursively</span><span class="params">(BinaryTreeNode *pNode)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (pNode == <span class="literal">NULL</span>) <span class="keyword">return</span>;               <span class="comment">// 两个递归出口</span></span><br><span class="line"><span class="keyword">if</span> (pNode -&gt; left == <span class="literal">NULL</span> &amp;&amp; pNode -&gt; right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"> </span><br><span class="line">BinaryTreeNode *temp = pNode -&gt; left;   <span class="comment">// 交换左右子树（先根遍历是访问节点）</span></span><br><span class="line">pNode -&gt; left = pNode -&gt; right;</span><br><span class="line">pNode -&gt; right = temp;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pNode -&gt; left)                         <span class="comment">// 左递归</span></span><br><span class="line">MirrorRecursively(pNode -&gt; left);</span><br><span class="line"><span class="keyword">if</span> (pNode -&gt; right)                       <span class="comment">// 右递归</span></span><br><span class="line">MirrorRecursively(pNode -&gt; right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer27-二叉树的镜像-P157&quot;&gt;&lt;a href=&quot;#剑指offer27-二叉树的镜像-P157&quot; class=&quot;headerlink&quot; title=&quot;剑指offer27.二叉树的镜像 P157&quot;&gt;&lt;/a&gt;剑指offer27.二叉树的镜像 P157&lt;/
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer26.树的子结构（一棵二叉树b是不是被二叉树a包含）P148</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer26/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer26/</id>
    <published>2019-11-01T06:34:13.000Z</published>
    <updated>2019-11-01T07:08:20.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer26-树的子结构（一棵二叉树b是不是被二叉树a包含）P148"><a href="#剑指offer26-树的子结构（一棵二叉树b是不是被二叉树a包含）P148" class="headerlink" title="剑指offer26. 树的子结构（一棵二叉树b是不是被二叉树a包含）P148"></a>剑指offer26. 树的子结构（一棵二叉树b是不是被二叉树a包含）P148</h2><p>题目：输入两棵二叉树A和B，判断B是不是A的子结构。</p><p><strong>递归结束条件</strong>：如果rootp为空，说明对比的子树已经找完了，此时不管root是不是空，都可以返回true（主调函数提前判断了rootp一开始就为空的情况），如果在rootp不为空的情况下root为空，说明这里肯定不对，因为子树还没有对比完，母树已经没了，返回false;</p><p><strong>逻辑判断</strong>：如果<code>root.val==rootp.val</code>,那么此时有两种情况:</p><ol><li><p>这个root节点是子结构的一部分，我们要判断roop的左右子树是不是也分别包含在root的左右子树中（这里用的是&amp;&amp;，因为要同时满足）：</p><p><code>HasSubtree(root -&gt; m_pLeft, rootp -&gt; m_pLeft)</code><br><code>&amp;&amp; HasSubtree(root -&gt; m_pRight, rootp -&gt; m_pRight</code></p></li></ol><ol start="2"><li>如果不包含这个节点（虽然两个根节点一样，但是在后面的递归过程出现两个结构不等的情况），我们就不能取这个root，所以要看root的左右子树是不是存在包含子结构的 （这里用的是||，因为不管左右子树哪个包含，只要出现就行）<br><code>HasSubtree(root -&gt; m_pLeft, rootp)</code><br><code>||  HasSubtree(root -&gt; m_pRight, rootp);</code></li></ol><p>两种情况一种成立就可以，所以中间用||连接 <strong>（这里会容易忽略第二种情况）</strong></p><p>回到开始，如果<code>root.val != rootp.val</code>,也就是进入那个else判断，这时就和上面的情况2一样了，直接返回左右子树和rootp比较的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   HasSubtree(root -&gt; m_pLeft, rootp)</span><br><span class="line">|| HasSubtree(root -&gt; m_pRight, rootp);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------主递归函数---------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(BinaryTreeNode *root, BinaryTreeNode *rootp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rootp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (equal(root -&gt; m_dbValue, rootp -&gt; m_dbValue)) &#123;            <span class="comment">// 比较浮点数</span></span><br><span class="line"><span class="keyword">return</span> (HasSubtree(root -&gt; m_pLeft, rootp -&gt; m_pLeft)      <span class="comment">// 情况1</span></span><br><span class="line">     &amp;&amp; HasSubtree(root -&gt; m_pRight, rootp -&gt; m_pRight))</span><br><span class="line"> || HasSubtree(root -&gt; m_pLeft, rootp)                <span class="comment">// 情况2</span></span><br><span class="line">     || HasSubtree(root -&gt; m_pRight, rootp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span>  HasSubtree(root -&gt; m_pLeft, rootp)               <span class="comment">// 情况2</span></span><br><span class="line">     || HasSubtree(root -&gt; m_pRight, rootp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has</span><span class="params">(BinaryTreeNode *root, BinaryTreeNode *rootp)</span> </span>&#123; <span class="comment">// 主调函数，root是母树</span></span><br><span class="line"><span class="keyword">if</span> (rootp == <span class="literal">NULL</span> || root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//默认两棵树任一个是空，返回false</span></span><br><span class="line"><span class="keyword">return</span> HasSubtree(root, rootp);                <span class="comment">// 递归判断  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer26-树的子结构（一棵二叉树b是不是被二叉树a包含）P148&quot;&gt;&lt;a href=&quot;#剑指offer26-树的子结构（一棵二叉树b是不是被二叉树a包含）P148&quot; class=&quot;headerlink&quot; title=&quot;剑指offer26. 树的子结构（一
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer25.合并两个排序的链表 P145</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer25/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer25/</id>
    <published>2019-11-01T06:34:10.000Z</published>
    <updated>2019-11-01T06:57:35.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer25-合并两个排序的链表-P145"><a href="#剑指offer25-合并两个排序的链表-P145" class="headerlink" title="剑指offer25. 合并两个排序的链表 P145"></a>剑指offer25. 合并两个排序的链表 P145</h2><p><strong>每次比较两个链表表头，那个小，哪个就是当前节点mergeHead，然后把剩下的链表继续合并，找这个mergeHead的下一个节点。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeSortedLinkedList</span><span class="params">(ListNode *head1, ListNode *head2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任一个链表比较完，把剩下的直接加到当前合并的链表尾</span></span><br><span class="line"><span class="keyword">if</span> (head1 == <span class="literal">NULL</span>) <span class="keyword">return</span> head2; </span><br><span class="line"><span class="keyword">if</span> (head2 == <span class="literal">NULL</span>) <span class="keyword">return</span> head1;</span><br><span class="line"></span><br><span class="line">ListNode *mergeHead = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次选出来两个链表头里最小的作为上一个节点的next</span></span><br><span class="line"><span class="keyword">if</span> (head1 -&gt; key &lt; head2 -&gt; key) &#123;</span><br><span class="line">mergeNode = head1;</span><br><span class="line">mergeNode -&gt; next =  mergeSortedLinkedList(head1 -&gt; next, head2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mergeNode = head2;</span><br><span class="line">mergeNode -&gt; next =  mergeSortedLinkedList(head1, head2 -&gt; next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mergeNode; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer25-合并两个排序的链表-P145&quot;&gt;&lt;a href=&quot;#剑指offer25-合并两个排序的链表-P145&quot; class=&quot;headerlink&quot; title=&quot;剑指offer25. 合并两个排序的链表 P145&quot;&gt;&lt;/a&gt;剑指offer25. 合并
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer24. 反转链表 P142</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer24/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer24/</id>
    <published>2019-11-01T06:34:06.000Z</published>
    <updated>2019-11-01T06:55:13.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer24-反转链表-p142"><a href="#剑指offer24-反转链表-p142" class="headerlink" title="剑指offer24. 反转链表 p142"></a>剑指offer24. 反转链表 p142</h2><p>题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">ReverseList</span><span class="params">(ListNode *pHeadList)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pHeadList == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ListNode *preNode = <span class="literal">NULL</span>;         <span class="comment">// 前驱节点</span></span><br><span class="line">ListNode *pNode = pHeadList;      <span class="comment">// 工作节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ListNode *nextNode = pNode -&gt; m_pNext;</span><br><span class="line">pNode -&gt; m_pNext = preNode;</span><br><span class="line">preNode = pNode;</span><br><span class="line">pNode = nextNode; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> preNode;                 <span class="comment">// 前驱就是头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归解法见p145 页</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer24-反转链表-p142&quot;&gt;&lt;a href=&quot;#剑指offer24-反转链表-p142&quot; class=&quot;headerlink&quot; title=&quot;剑指offer24. 反转链表 p142&quot;&gt;&lt;/a&gt;剑指offer24. 反转链表 p142&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer23.链表是否有环，找出环的入口 P139</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer23/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer23/</id>
    <published>2019-11-01T06:34:02.000Z</published>
    <updated>2019-11-01T06:53:23.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer23-链表是否有环，找出环的入口-P139"><a href="#剑指offer23-链表是否有环，找出环的入口-P139" class="headerlink" title="剑指offer23.  链表是否有环，找出环的入口  P139"></a>剑指offer23.  链表是否有环，找出环的入口  P139</h2><p><strong>和书上不太一样，这里用的弗洛伊德龟兔算法<br>Fast指针 比 slow 每次多走一步，相遇之后，fast从头开始一次走一步，slow从当前开始每次走一步，两者再相遇点就是入口。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">EntryNodeOfLoop</span><span class="params">(ListNode *pHeadList)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pHeadList == <span class="literal">NULL</span> || pHeadList -&gt; m_pNext == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ListNode  *slow = pHeadList -&gt; m_pNext , *fast = slow -&gt; m_pNext;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; slow != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;                    <span class="comment">// 第一次相遇</span></span><br><span class="line"><span class="keyword">if</span> (fast -&gt; m_pNext == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//  没有环</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">fast = fast -&gt; m_pNext -&gt; m_pNext;   <span class="comment">// 前进</span></span><br><span class="line">slow = slow -&gt; m_pNext;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fast != slow || fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 没有环</span></span><br><span class="line">fast = pHeadList;                              <span class="comment">// fast从头走</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast != slow) &#123;                        <span class="comment">// 再一次相遇，相遇点就是入口</span></span><br><span class="line">fast = fast -&gt; m_pNext;</span><br><span class="line">slow = slow -&gt; m_pNext; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer23-链表是否有环，找出环的入口-P139&quot;&gt;&lt;a href=&quot;#剑指offer23-链表是否有环，找出环的入口-P139&quot; class=&quot;headerlink&quot; title=&quot;剑指offer23.  链表是否有环，找出环的入口  P139&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer22.链表中的倒数第k个节点 P134</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer22/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer22/</id>
    <published>2019-11-01T06:33:59.000Z</published>
    <updated>2019-11-01T06:49:29.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer22-链表中的倒数第k个节点-P134"><a href="#剑指offer22-链表中的倒数第k个节点-P134" class="headerlink" title="剑指offer22. 链表中的倒数第k个节点  P134"></a>剑指offer22. 链表中的倒数第k个节点  P134</h2><p>题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。</p><p><strong>// 本题主要是鲁棒性检测 两个if条件的内容。第二个if不能用p!=NULL 是因为，p定义指的是最后一共节点，如果最后p是NULL(最后一共节点的下一个节点)了，就失去意义了。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">findK</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;           </span><br><span class="line"></span><br><span class="line">ListNode *p = head;             <span class="comment">// 指向倒数第一个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k- <span class="number">1</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (p -&gt; m_pNext != <span class="literal">NULL</span>) p = p -&gt; m_pNext;  <span class="comment">// 节点总数小于k</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;                      </span><br><span class="line">&#125;</span><br><span class="line">ListNode *q = head;            <span class="comment">// 倒数第k个节点</span></span><br><span class="line"><span class="keyword">while</span> (p -&gt; m_pNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = p -&gt; m_pNext;</span><br><span class="line">q = q -&gt; m_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong><br>求链表的中间节点：如果链表节点数是奇数，返回中间节点，否则返回中间两个节点任一个。  </p><p><strong>定义一个快指针一次走两步，一个慢指针一次走一步。快指针走到末尾慢指针指的就是答案</strong>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">find_mid</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line"> ListNode *slow, *fast;</span><br><span class="line">    slow = fast = head;   <span class="comment">/*快慢指针都指向第一个节点*/</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;       <span class="comment">/*慢指针每次走一步*/</span></span><br><span class="line">        fast = fast-&gt;next-&gt;next;  <span class="comment">/*快指针每次走两步*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer22-链表中的倒数第k个节点-P134&quot;&gt;&lt;a href=&quot;#剑指offer22-链表中的倒数第k个节点-P134&quot; class=&quot;headerlink&quot; title=&quot;剑指offer22. 链表中的倒数第k个节点  P134&quot;&gt;&lt;/a&gt;剑指offe
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
