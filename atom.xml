<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>G2.int.BUPT</title>
  
  <subtitle>我爱网管</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-03T02:57:37.421Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郭源潮</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer66. 构建乘积数组（不用除法） P312</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer66/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer66/</id>
    <published>2019-11-03T02:49:38.000Z</published>
    <updated>2019-11-03T02:57:37.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer66-构建乘积数组（不用除法）-P312"><a href="#剑指offer66-构建乘积数组（不用除法）-P312" class="headerlink" title="剑指offer66. 构建乘积数组（不用除法） P312"></a>剑指offer66. 构建乘积数组（不用除法） P312</h2><p>题目：给定一个数组A[0, 1, …, n-1]，请构建一个数组B[0, 1, …, n-1]，其中B中的元素B[i] =A[0]×A[1]×… ×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><p>其实也是两点法的思想。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">令 i左边乘积，C[i] = a[<span class="number">0</span>] * a[<span class="number">1</span>] *…* a[i<span class="number">-1</span>]; </span><br><span class="line"> i右边乘积  D[i] = a[i+<span class="number">1</span>] * a[i+<span class="number">2</span>] *…* a[n<span class="number">-2</span>]*a[n<span class="number">-1</span>];</span><br><span class="line">从左到右算： C[i] = c[i<span class="number">-1</span>] * a[i<span class="number">-1</span>];    从右到左 算D[i] = D[i+<span class="number">1</span>]*a[i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>// 数组copy存最后的结果</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildProductionArray</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;copy)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.size() != copy.size() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">copy[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">copy[i] = copy[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];  <span class="comment">// 第一次遍历可以省略temp变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">1</span>;                       <span class="comment">// 是右边i之后所有元素的乘积</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="comment">//copy[i]= copy[i+1]*nums[i+1];不能这样,因为copy[i+1]里包含了num[i] </span></span><br><span class="line">temp *= nums[i + <span class="number">1</span>];</span><br><span class="line">copy[i] *= temp;      <span class="comment">// 原来的copy存的是左边的乘积，再乘以右边乘积temp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer66-构建乘积数组（不用除法）-P312&quot;&gt;&lt;a href=&quot;#剑指offer66-构建乘积数组（不用除法）-P312&quot; class=&quot;headerlink&quot; title=&quot;剑指offer66. 构建乘积数组（不用除法） P312&quot;&gt;&lt;/a&gt;剑指of
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer65.不用加减乘除做加法 P310.</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer65/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer65/</id>
    <published>2019-11-03T02:49:34.000Z</published>
    <updated>2019-11-03T02:56:00.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer65-不用加减乘除做加法-P310"><a href="#剑指offer65-不用加减乘除做加法-P310" class="headerlink" title="剑指offer65. 不用加减乘除做加法 P310."></a>剑指offer65. 不用加减乘除做加法 P310.</h2><p>题目：写一个函数，求两个整数之和，要求在函数体内不得使用＋、－、×、÷ </p><p><strong>// 把相加结果分为进位和不计进位两个结果 ，这里用递归感觉容易理解</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line"><span class="comment">//if (b == 0) return a; 最后等来的肯定是进位先为0，因为进位是靠与运算的，非进位是异或 </span></span><br><span class="line"><span class="keyword">int</span> no_carry_num = <span class="number">0</span>, carry_num = <span class="number">0</span>;  <span class="comment">// 存非进位结果，进位结果</span></span><br><span class="line"></span><br><span class="line">no_carry_num = a ^ b;    <span class="comment">// 异或运算之后存储非进位 </span></span><br><span class="line">carry_num = (a &amp; b) &lt;&lt; <span class="number">1</span>;<span class="comment">// 用&amp;看此位是否向高位提供进位，最后左移把进位给高位 </span></span><br><span class="line"><span class="keyword">return</span> addSum(carry_num, no_carry_num);  <span class="comment">// 递归进位和不计进位的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.    不用新变量，交换两个变量a、b的值 P312</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">基于加减法                          基于异或          </span><br><span class="line">a = a + b;                          a = a ^ b;</span><br><span class="line">b = a – b;                          b = a ^ b;</span><br><span class="line">a = a – b;                          a = a ^ b;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer65-不用加减乘除做加法-P310&quot;&gt;&lt;a href=&quot;#剑指offer65-不用加减乘除做加法-P310&quot; class=&quot;headerlink&quot; title=&quot;剑指offer65. 不用加减乘除做加法 P310.&quot;&gt;&lt;/a&gt;剑指offer65. 不
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="位运算" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer63. 股票最大利润 P304</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer63/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer63/</id>
    <published>2019-11-03T02:49:31.000Z</published>
    <updated>2019-11-03T02:53:30.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer63-股票最大利润-P304"><a href="#剑指offer63-股票最大利润-P304" class="headerlink" title="剑指offer63. 股票最大利润    P304"></a>剑指offer63. 股票最大利润    P304</h2><p>题目：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖交易该股票可能获得的利润是多少？例如一只股票在某些时间节点的价格为{9, 11, 8, 5,7, 12, 16, 14}。如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。</p><p><strong>不同条件的股票问题在leetcode 上有大神做了详细的对比总结，参考：</strong><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems</a></p><p><strong>在这里只列出来简单的两个情况：1.只能买卖一次 .2. 不限买卖次数。</strong><br>其它股票问题见笔者leetcode题解文档。</p><p><strong>1.    买卖一次</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *nums, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span> || len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = INT_MIN;          <span class="comment">// 头文件 climits          </span></span><br><span class="line"><span class="keyword">int</span> min_buy_value = nums[<span class="number">0</span>]; <span class="comment">// 第i之前买入的最低价 </span></span><br><span class="line">                         <span class="comment">//  nums[i] - min_buy_value表示第i天股票卖出的利润 </span></span><br><span class="line">                        <span class="comment">//   ans 取利润最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="comment">// dp_sail[i] = nums[i] - min_buy_value; =右边没有用到dp，所以不用开dp数组 </span></span><br><span class="line">ans          = (nums[i] - min_buy_value) &gt; ans ? (nums[i] - min_buy_value) : ans;</span><br><span class="line">min_buy_value = nums[i] &lt;  min_buy_value ? nums[i] : min_buy_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.    买卖不限次数（后缀为0表示卖出，为1表示买入）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T_ik0_old = T_ik0;  <span class="comment">// 这个old是可以累计之前卖出的利润</span></span><br><span class="line"></span><br><span class="line">T_ik0 = Math.max(T_ik0, T_ik1 + price);</span><br><span class="line">T_ik1 = Math.max(T_ik1, T_ik0_old - price);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer63-股票最大利润-P304&quot;&gt;&lt;a href=&quot;#剑指offer63-股票最大利润-P304&quot; class=&quot;headerlink&quot; title=&quot;剑指offer63. 股票最大利润    P304&quot;&gt;&lt;/a&gt;剑指offer63. 股票最大利润  
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer62.圆圈中最后剩下的数字（Josephuse约瑟夫环问题）P300</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer62/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer62/</id>
    <published>2019-11-03T02:49:27.000Z</published>
    <updated>2019-11-03T02:52:15.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer62-圆圈中最后剩下的数字（Josephuse约瑟夫环问题）-P300"><a href="#剑指offer62-圆圈中最后剩下的数字（Josephuse约瑟夫环问题）-P300" class="headerlink" title="剑指offer62. 圆圈中最后剩下的数字（Josephuse约瑟夫环问题）  P300"></a>剑指offer62. 圆圈中最后剩下的数字（Josephuse约瑟夫环问题）  P300</h2><p>题目：0, 1, …, n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p><strong>方法1. 循环链表 （C++官网说list不是循环链表 ， 但是为啥所有博客都说是循环呢？ ）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; list_loop;                    <span class="comment">// 用std::list 模拟循环链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;             <span class="comment">// 初始创建链表</span></span><br><span class="line">list_loop.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator p = list_loop.begin();  <span class="comment">// 链表头</span></span><br><span class="line"><span class="keyword">while</span> (list_loop.size() != <span class="number">1</span>) &#123;           <span class="comment">// 没有删到只剩最后一共数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)  &#123;         <span class="comment">// p找到当前要删的元素</span></span><br><span class="line">++p;                 </span><br><span class="line"><span class="keyword">if</span> (p == list_loop.end())  p = list_loop.begin();  <span class="comment">// 循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator p_next = ++p;  <span class="comment">// 用p_next缓存下一个元素，不能p_next = p+1</span></span><br><span class="line">--p;                         <span class="comment">// list 迭代器没有重载操作符 +，- 只能赋值</span></span><br><span class="line">list_loop.erase(p);   </span><br><span class="line">p = p_next;                 </span><br><span class="line"><span class="keyword">if</span> (p == list_loop.end())  p = list_loop.begin();  <span class="comment">// 不要忘了处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (list&lt;int&gt;::iterator io = list_loop.begin(); io != list_loop.end();++io) &#123;</span></span><br><span class="line"><span class="comment">//printf(" %d ", (*io));</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list_loop.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2.  数学推导递归  n &gt; 1 : f（n）= （f(n-1)+ m ）% n;     n = 1: f(n) = 0,</strong><br>//请参考<a href="http://www.360doc.com/content/19/0212/18/32116899_814506447.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/19/0212/18/32116899_814506447.shtml</a>   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ysfdg</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> (ysfdg(n - <span class="number">1</span>, m) + m) % n;  <span class="comment">// m是固定的，f函数里完全可以不带m，</span></span><br><span class="line"><span class="comment">//不要被书上303页带m的式子唬住</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ysf</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ysfdg(n, m);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer62-圆圈中最后剩下的数字（Josephuse约瑟夫环问题）-P300&quot;&gt;&lt;a href=&quot;#剑指offer62-圆圈中最后剩下的数字（Josephuse约瑟夫环问题）-P300&quot; class=&quot;headerlink&quot; title=&quot;剑指offer6
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer61. 扑克牌中的顺子 P298</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer61/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer61/</id>
    <published>2019-11-03T02:16:26.000Z</published>
    <updated>2019-11-03T02:48:25.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer61-扑克牌中的顺子-P298"><a href="#剑指offer61-扑克牌中的顺子-P298" class="headerlink" title="剑指offer61. 扑克牌中的顺子  P298"></a>剑指offer61. 扑克牌中的顺子  P298</h2><p>题目：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。</p><p>统计<strong>大小王的数量（0的个数）</strong>，用来填补顺子里缺失的数。把5张牌排序，从后往前遍历，如果出现不连续的两个数a,b的话，b和a之间差几个数，就拿上一步统计的0来填补这个空缺。如果a，b一样而且不是0（大小王），证明肯定不连续 最后遍历完，如果0的个数非负，证明可以填补缺失。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> len)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span> || len &lt; <span class="number">1</span> || len &gt; <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">sort(nums, nums + len);                      <span class="comment">// 排序！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> zeroCount = <span class="number">0</span>;   <span class="comment">// 大小王个数（0 的个数）（一副牌大小王能有无数个。。。。。）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] == <span class="number">0</span>)  ++zeroCount;   <span class="comment">// 统计大小王数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] - nums[i - <span class="number">1</span>] &gt; <span class="number">1</span> &amp;&amp; nums[i - <span class="number">1</span>] != <span class="number">0</span>)  <span class="comment">// 相邻两个数差值比1大,</span></span><br><span class="line">zeroCount -= (nums[i] - nums[i - <span class="number">1</span>] - <span class="number">1</span>);<span class="comment">//大多少就用0来补救中间的差值</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; nums[i] != <span class="number">0</span>)    <span class="comment">// 出现对子，指定不行</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (zeroCount &gt;= <span class="number">0</span> )  <span class="keyword">return</span> <span class="literal">true</span>;               <span class="comment">// 0够用</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer61-扑克牌中的顺子-P298&quot;&gt;&lt;a href=&quot;#剑指offer61-扑克牌中的顺子-P298&quot; class=&quot;headerlink&quot; title=&quot;剑指offer61. 扑克牌中的顺子  P298&quot;&gt;&lt;/a&gt;剑指offer61. 扑克牌中的顺子
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer60. N个骰子的点数  P294</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer60/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer60/</id>
    <published>2019-11-03T02:16:20.000Z</published>
    <updated>2019-11-03T02:46:53.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer60-n个骰子的点数-P294"><a href="#剑指offer60-n个骰子的点数-P294" class="headerlink" title="剑指offer60. n个骰子的点数  P294"></a>剑指offer60. n个骰子的点数  P294</h2><p>题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>实质就是一个动态规划。该问题具备DP的两个特征：最优子结构性质和子问题的重叠性。具体的表现在：(1)n个骰子的点数依赖于n-1个骰子的点数，相当于在n-1个骰子点数的基础上再进行投掷。(2)求父问题的同时，需要多次利用子问题。由此定义状态转移方程为f(n,k)表示n个骰子点数和为k时出现的次数，于是可得  </p><pre><code>f(n,k) = f(n−1,k−1)+f(n−1,k−2)+f(n−1,k−3)+f(n−1,k−4)+f(n−1,k−5)+f(n−1,k−6)n &gt;= 1且k&lt;=6n （点数和最大是6n，就是所有骰子都是6）</code></pre><p>右边的6个式子除了表示前n-1个骰子点数和为k-j（j属于1-6）外，还可以理解成最后一个骰子掷出来：1，2，3，4，5，6，分别把6种情况相加  </p><p>初始状态是：  f(1,1)=f(1,2)=f(1,3)=f(1,4)=f(1,5)=f(1,6)=1  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_size = <span class="number">6</span>;   <span class="comment">// 骰子的面数，下面循环里max_size * n表示最大的和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>)   <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> dp[n + <span class="number">1</span>][max_size * n + <span class="number">1</span>];   <span class="comment">// 最好用new</span></span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= max_size; ++j)   <span class="comment">// 初始状态</span></span><br><span class="line">dp[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//下面第二层for里从int sum 到 dp[i][j]+=sum的5行实际上就是dp[i][j] += (dp [i - 1][j - 1] + dp [i - 1][j - 2] +dp [i - 1][j - 3] + dp [i - 1][j - 4] + dp [i - 1][j - 5]+ dp [i - 1][j - 6]);但是因为列索引j-k这些在j&lt;k的时候会失效，所以再搞个循环只累加列索引大于0时候的dp</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= max_size * n; ++j) &#123; <span class="comment">// j 从 i开始因为和最小是全掷出来1</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= max_size; ++k) &#123;</span><br><span class="line"><span class="keyword">if</span> (j - k &gt;= <span class="number">0</span>)  sum += dp[i - <span class="number">1</span>][j - k];</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j] += sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum_n = <span class="number">1</span>;           <span class="comment">// n个骰子一共出现多少个数字和 dp[n][i] != 0 表示和是i</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= max_size * n; ++i) </span><br><span class="line">sum_n += dp[n][i];           <span class="comment">// 统计 数字和 一共多少种情况（分母）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= max_size * n; ++i)          <span class="comment">// 数字和范围从n到6n</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d: %e\n"</span>, i, <span class="number">1.0</span> * dp[n][i] / sum_n);   <span class="comment">// 算概率  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer60-n个骰子的点数-P294&quot;&gt;&lt;a href=&quot;#剑指offer60-n个骰子的点数-P294&quot; class=&quot;headerlink&quot; title=&quot;剑指offer60. n个骰子的点数  P294&quot;&gt;&lt;/a&gt;剑指offer60. n个骰子的点数
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer59. 队列中的最大值  P288</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer59/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer59/</id>
    <published>2019-11-03T02:16:14.000Z</published>
    <updated>2019-11-03T02:44:05.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer59-队列中的最大值-P288"><a href="#剑指offer59-队列中的最大值-P288" class="headerlink" title="剑指offer59. 队列中的最大值  P288"></a>剑指offer59. 队列中的最大值  P288</h2><p><strong>1.    滑动窗口的最大值 P288</strong></p><p>题目：给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组{2, 3, 4, 2, 6, 2, 5, 1}及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为{4, 4, 6, 6, 6, 5}，</p><p>通常，er会这样考虑：记录当前窗口的最大值，然后移动的时候把最大值和下一个进入窗口的元素比较取最大的就好，但是如果最大值划出窗口了，拿什么比较呢？是不是应该拿上一个窗口第二大的元素和这个刚进入窗口的元素比较呢？ 这样就只用一个数据结构同时保存窗口最大，次大值（这两个就是书上所说的：有可能成为下一个窗口最大值的元素）就好了。<br>可以用双端队列。<br>每次读入一个新值，首先看最大值是不是已经划出窗口，如果是，把次大值和新值比较，更新队列，不是，把最大值比较新值，更新队列。因为要比较上一个最大值是不是划出窗口，所以队列存的是索引。用i - dq_index.front() &gt;= k判别当前最大是不是划出窗口了。队头存的是当前窗口的最大值的索引，<strong>（不要误认为队列中元素个数保持&lt;=2，不管是否更新队列，都把当前元素入队）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> k) &#123; <span class="comment">// k是窗口大小</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;    <span class="comment">// 返回最大值序列</span></span><br><span class="line"><span class="keyword">if</span> (nums.size() &lt; k || k &lt; <span class="number">1</span> || nums.size() &lt; <span class="number">1</span>) <span class="keyword">return</span> v;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq_index;   <span class="comment">// 双端队列放的是索引，</span></span><br><span class="line"><span class="comment">// 用i - dq_index.front() &gt;= k判别当前最大是不是划出窗口了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;              <span class="comment">// 处理第一个窗口</span></span><br><span class="line"><span class="keyword">while</span> (!dq_index.empty() &amp;&amp; nums[i] &gt; nums[dq_index.back()]) </span><br><span class="line">dq_index.pop_back();</span><br><span class="line">dq_index.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">    v.push_back(nums[dq_index.front()]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k ; i &lt; nums.size(); ++i) &#123;    <span class="comment">// 从第k个值到结尾</span></span><br><span class="line"><span class="keyword">while</span> (!dq_index.empty() &amp;&amp; nums[i] &gt; nums[dq_index.back()]) </span><br><span class="line">dq_index.pop_back();   <span class="comment">// 当前值比队列尾部元素大，弹出尾部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dq_index.empty()  &amp;&amp; i - dq_index.front() &gt;= k )  <span class="comment">//队头划出窗口</span></span><br><span class="line">dq_index.pop_front(); </span><br><span class="line"> </span><br><span class="line">dq_index.push_back(i);         <span class="comment">// 不管是否更新队列，都把当前元素入队</span></span><br><span class="line">v.push_back(nums[dq_index.front()]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>2.    队列的最大值 P292   （实现一个队列，并在O(1)时间找出最大的队列元素）</strong>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">QueueWithMax</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InternalData</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> index;     <span class="comment">// 出队时比较索引大小，以此更新max_dq;</span></span><br><span class="line">T number;     <span class="comment">// 入队时比较数据大小 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="built_in">queue</span> &lt;InternalData&gt; data_dq;</span><br><span class="line"><span class="built_in">deque</span> &lt;InternalData&gt; max_dq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">QueueWithMax()&#123; index = <span class="number">0</span>; &#125;;</span><br><span class="line">~QueueWithMax()&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line">InternalData data;  <span class="comment">// 不可以new </span></span><br><span class="line">data.index = index;</span><br><span class="line">data.number = num;</span><br><span class="line">++index;</span><br><span class="line">data_dq.push(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面3行和上面滑动窗口一样 ，插入最大的</span></span><br><span class="line"><span class="keyword">while</span> (!max_dq.empty() &amp;&amp; max_dq.back().number &lt; num) </span><br><span class="line">max_dq.pop_back();</span><br><span class="line">max_dq.push_back(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data_dq.empty())  <span class="keyword">throw</span> <span class="string">"queue is empty!"</span>;</span><br><span class="line"> <span class="comment">// 出队的时候，要用索引判断data队头是不是当前最大的，是的话当前max也要出队 </span></span><br><span class="line"><span class="keyword">if</span> (data_dq.front().index == max_dq.front().index) &#123;</span><br><span class="line">max_dq.pop_front();</span><br><span class="line">&#125;</span><br><span class="line">data_dq.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为测试Test函数形参声明模板类是const QueueWithMax&lt;int&gt;&amp; queue</span></span><br><span class="line">   <span class="comment">// 一个const对象不能调用它的non-const成员函数 </span></span><br><span class="line">  <span class="comment">//  const在成员函数右边表示不能修改成员变量</span></span><br><span class="line"> <span class="comment">//   前面两个void函数在测试中是在main中直接调的，queue没有用const修饰 </span></span><br><span class="line">    <span class="function">T <span class="title">max</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;      </span><br><span class="line"><span class="keyword">if</span> (max_dq.empty())    <span class="keyword">throw</span> <span class="string">"queue is empty!"</span>;</span><br><span class="line"><span class="keyword">return</span> max_dq.front().number;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer59-队列中的最大值-P288&quot;&gt;&lt;a href=&quot;#剑指offer59-队列中的最大值-P288&quot; class=&quot;headerlink&quot; title=&quot;剑指offer59. 队列中的最大值  P288&quot;&gt;&lt;/a&gt;剑指offer59. 队列中的最大值
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈&amp;队列" scheme="http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer58. 翻转字符串 P284</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer58/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer58/</id>
    <published>2019-11-03T02:16:11.000Z</published>
    <updated>2019-11-03T02:41:15.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer58-翻转字符串-P284"><a href="#剑指offer58-翻转字符串-P284" class="headerlink" title="剑指offer58.  翻转字符串 P284"></a>剑指offer58.  翻转字符串 P284</h2><ol><li>题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 </li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> (<span class="number">1</span>)可以用<span class="built_in">string</span>一个从前一个从后+</span><br><span class="line"> (<span class="number">2</span>)用栈存<span class="built_in">string</span>  </span><br><span class="line">（<span class="number">3</span>）   书上的方法，先反转整个数组，然后反转每个单词。</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ReverseSentence</span><span class="params">(<span class="keyword">char</span> *pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">char</span> *pEnd = pData;</span><br><span class="line">    <span class="keyword">while</span>(*pEnd != <span class="string">'\0'</span>)        <span class="comment">// 找输入字符串的结尾</span></span><br><span class="line">        pEnd ++;</span><br><span class="line">    pEnd--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转整个句子</span></span><br><span class="line">    Reverse(pBegin, pEnd);   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转句子中的每个单词</span></span><br><span class="line">    pBegin = pEnd = pData;</span><br><span class="line">    <span class="keyword">while</span>(*pBegin != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pBegin == <span class="string">' '</span>)        <span class="comment">// 跳过空格</span></span><br><span class="line">        &#123;</span><br><span class="line">            pBegin ++;</span><br><span class="line">            pEnd ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*pEnd == <span class="string">' '</span> || *pEnd == <span class="string">'\0'</span>)  <span class="comment">// 句子中间遇到空格，或者遍历结束</span></span><br><span class="line">        &#123;</span><br><span class="line">            Reverse(pBegin, --pEnd);      <span class="comment">// 反转begin和end之间的单词</span></span><br><span class="line">            pBegin = ++pEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pEnd ++;                   <span class="comment">// begin和end之间还不是一个单词</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *pBegin, <span class="keyword">char</span> *pEnd)</span>  <span class="comment">// 反转数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pBegin == <span class="literal">nullptr</span> || pEnd == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pBegin;</span><br><span class="line">        *pBegin = *pEnd;</span><br><span class="line">        *pEnd = temp;</span><br><span class="line"></span><br><span class="line">        pBegin ++, pEnd --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试题58（二）： 左旋转字符串 P286</strong></p><p>题目：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”。  </p><p><strong>方法1：书上方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">LeftRotateString</span><span class="params">(<span class="keyword">char</span>* pStr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pStr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nLength = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(pStr));</span><br><span class="line">        <span class="keyword">if</span>(nLength &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n &lt; nLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>* pFirstStart = pStr;</span><br><span class="line">            <span class="keyword">char</span>* pFirstEnd = pStr + n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span>* pSecondStart = pStr + n;</span><br><span class="line">            <span class="keyword">char</span>* pSecondEnd = pStr + nLength - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 翻转字符串的前面n个字符</span></span><br><span class="line">            Reverse(pFirstStart, pFirstEnd);</span><br><span class="line">            <span class="comment">// 翻转字符串的后面len-n个字符</span></span><br><span class="line">            Reverse(pSecondStart, pSecondEnd);</span><br><span class="line">            <span class="comment">// 翻转整个字符串</span></span><br><span class="line">            Reverse(pFirstStart, pSecondEnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2： string  分割之后+</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">LeftRotateString</span><span class="params">(<span class="keyword">char</span> *in, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (in == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *p = in;</span><br><span class="line"><span class="keyword">while</span>((*p) != <span class="string">'\0'</span>) &#123;</span><br><span class="line">++p;</span><br><span class="line">++len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span> || k &gt;= len) <span class="keyword">return</span> in;</span><br><span class="line"><span class="built_in">string</span> strfront = <span class="string">""</span>;      </span><br><span class="line"><span class="built_in">string</span> strback = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">strfront += in[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; ++i) &#123;</span><br><span class="line">strback += in[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> ans[len];       <span class="comment">// 这里不能用char *ans ,, 原因见下面（string和char*转换问题）</span></span><br><span class="line"><span class="built_in">strcpy</span>(ans, (strback + strfront ).c_str());</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char* c;<br>string s=”1234”;<br>c = s.c_str(); //c最后指向的内容是垃圾,因为s对象被析构,其内容被处理<br>应该这样用：<br>char c[20];<br>string s=”1234”;<br>strcpy(c,s.c_str());<br>返回 c </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer58-翻转字符串-P284&quot;&gt;&lt;a href=&quot;#剑指offer58-翻转字符串-P284&quot; class=&quot;headerlink&quot; title=&quot;剑指offer58.  翻转字符串 P284&quot;&gt;&lt;/a&gt;剑指offer58.  翻转字符串 P284&lt;/
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer57. 连续数组中和为S的数字 P280</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer57/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer57/</id>
    <published>2019-11-03T02:16:08.000Z</published>
    <updated>2019-11-03T02:36:48.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer57-连续数组中和为s的数字-P280"><a href="#剑指offer57-连续数组中和为s的数字-P280" class="headerlink" title="剑指offer57. 连续数组中和为s的数字  P280"></a>剑指offer57. 连续数组中和为s的数字  P280</h2><ol><li><p>一个递增序列中，找出任意两个数和为s   （两点法，前后同时走）P280</p></li><li><p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）P282<br>如： 输入s=15   1+2+3+4+5=4+5+6=7+8= 15</p></li></ol><p><strong>// 还是两点法，small指向最小的，big指向最大的，只不过两个同方向运动 ，sum存两者之间的所有数字和， small前进时sum是减少的，big前进，sum是增加的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindContinuousSequence</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">2</span>)  </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> small = <span class="number">1</span>, big = <span class="number">2</span>;           <span class="comment">// 左右指针初始值 </span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">3</span>;                     <span class="comment">// small 到 big的和  </span></span><br><span class="line"><span class="keyword">while</span> (small &lt;= (num + <span class="number">1</span>) / <span class="number">2</span>) &#123; <span class="comment">// sum=num时前进的是small，所以最好用small比较 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sum == num) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = small; i &lt;= big; ++i) &#123;  <span class="comment">// 打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">sum -= small;         <span class="comment">// small前进sum是减少的</span></span><br><span class="line">++small;             <span class="comment">// 要前进，不然死循环 </span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; num) &#123;     <span class="comment">// sum小，前进大指针big</span></span><br><span class="line">++big;</span><br><span class="line">sum += big;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">sum -= small;</span><br><span class="line">++small;            <span class="comment">// sum 比给定num大，small前进</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer57-连续数组中和为s的数字-P280&quot;&gt;&lt;a href=&quot;#剑指offer57-连续数组中和为s的数字-P280&quot; class=&quot;headerlink&quot; title=&quot;剑指offer57. 连续数组中和为s的数字  P280&quot;&gt;&lt;/a&gt;剑指offe
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer56. 数组中数字出现的次数 P275</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer56/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer56/</id>
    <published>2019-11-03T02:16:05.000Z</published>
    <updated>2019-11-03T02:35:23.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer56-数组中数字出现的次数-P275"><a href="#剑指offer56-数组中数字出现的次数-P275" class="headerlink" title="剑指offer56. 数组中数字出现的次数 P275"></a>剑指offer56. 数组中数字出现的次数 P275</h2><p><strong>1.    数组中只出现一次的1个数字，其他数字出现两次，</strong><br> 直接拿0和nums中每个数字异或得到结果。  </p><p><strong>2.    数组中只出现一次的两个数字 p275</strong>    （两个数字只出现一次，其余的出现两次）</p><p><strong>在1的基础上，把0和nums异或。得到的数肯定不是0，因为两个数不想等。那么找到这个结果二进制里的1位的索引。这两个数在这位上一定一个是0另一个是1。那么把数组根据这位是0或者1分成两个数组。分别对两个数组异或，得到两个结果就行。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span> </span>&#123;   <span class="comment">// 判断倒数第n位是不是1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">p = p &lt;&lt; n;</span><br><span class="line"><span class="keyword">if</span> (p &amp; num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> len, <span class="keyword">int</span> &amp;flag, <span class="keyword">int</span> &amp;flag2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span> || len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">flag = <span class="number">0</span>;                 <span class="comment">// 和nums元素异或得到两个答案的异或值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">flag ^= nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index_1 = <span class="number">0</span>;          <span class="comment">// 异或之后的结果在倒数第几位</span></span><br><span class="line"><span class="keyword">while</span> (p) &#123;               <span class="comment">// 从右到左查找上一部结果，倒数第n位是1</span></span><br><span class="line"><span class="keyword">if</span> (flag &amp; p) <span class="keyword">break</span>;</span><br><span class="line">++index_1;</span><br><span class="line">p = p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">0</span>;  <span class="comment">//两个结果分别存两个子数组的异或结果（划分条件是倒数第n位是不是1）</span></span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (is1(nums[i], index_1)) flag ^= nums[i];</span><br><span class="line"><span class="keyword">else</span> flag2 ^= nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.    数组中唯一只出现一次的数字，其他数字出现三次 P278</strong></p><p>如果一个数字出现三次，那么它的二进制的每一位也出现三次，那么把这些数的二进制对应位的和加起来一定 %3=0。如果在32位中，比如第1位和%3=0，说明ans的这一位是0，如果%3不是0，说明这一位是1. 最后统计32位就能还原出ans</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isAnsValid = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindNumberAppearingOnce</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span> || len &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> bits[<span class="number">32</span>];</span><br><span class="line"> <span class="built_in">memset</span>(bits, <span class="number">0</span>, <span class="keyword">sizeof</span>(bits));</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> p = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">  <span class="keyword">int</span> bit = p &amp; nums[i];</span><br><span class="line">  <span class="keyword">if</span> (bit != <span class="number">0</span>) &#123;</span><br><span class="line">  bits[j] += <span class="number">1</span>; <span class="comment">//不能加上p&amp;nums[i]结果不只是0or1，p的1跑到高位了！</span></span><br><span class="line">  &#125;</span><br><span class="line">  p = p &lt;&lt; <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">ans = ans &lt;&lt; <span class="number">1</span>;</span><br><span class="line">ans += bits[i] % <span class="number">3</span>;  <span class="comment">// 把ans根据bits数组里的和拼接起来</span></span><br><span class="line">&#125;</span><br><span class="line">isAnsValid = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> ans;    <span class="comment">// 10进制结果</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer56-数组中数字出现的次数-P275&quot;&gt;&lt;a href=&quot;#剑指offer56-数组中数字出现的次数-P275&quot; class=&quot;headerlink&quot; title=&quot;剑指offer56. 数组中数字出现的次数 P275&quot;&gt;&lt;/a&gt;剑指offer56.
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="位运算" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer55.二叉树的深度，平衡二叉 P271</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer55/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer55/</id>
    <published>2019-11-03T02:16:01.000Z</published>
    <updated>2019-11-03T02:31:47.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-55-二叉树的深度，平衡二叉-P271"><a href="#剑指offer-55-二叉树的深度，平衡二叉-P271" class="headerlink" title="剑指offer 55. 二叉树的深度，平衡二叉 P271"></a>剑指offer 55. 二叉树的深度，平衡二叉 P271</h2><p>题目：输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>1.    普通二叉树的深度  P271</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一棵二叉树的深度：是左右子树深度较大的+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(<span class="keyword">const</span> BinaryTreeNode *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>left = TreeDepth(root -&gt; m_pLeft);</span><br><span class="line"><span class="keyword">int</span> right = TreeDepth(root -&gt; m_pRight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (left &gt; right ? left : right) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.    判断是不是平衡二叉树   P273</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上是后根遍历模板，比书上的先根少了重复遍历</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(<span class="keyword">const</span> BinaryTreeNode *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root -&gt; m_pLeft != <span class="literal">NULL</span>) </span><br><span class="line">IsBalanced_Solution(root -&gt; m_pLeft);</span><br><span class="line"><span class="keyword">if</span> (root -&gt; m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">IsBalanced_Solution(root -&gt; m_pRight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftdepth  = TreeDepth(root -&gt; m_pLeft);</span><br><span class="line"><span class="keyword">int</span> rightdepth = TreeDepth(root -&gt; m_pRight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sub = leftdepth - rightdepth;  <span class="comment">// 每个节点左右子树深度差&lt;=1</span></span><br><span class="line"><span class="keyword">if</span> ( sub &lt; <span class="number">-1</span> || sub &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-55-二叉树的深度，平衡二叉-P271&quot;&gt;&lt;a href=&quot;#剑指offer-55-二叉树的深度，平衡二叉-P271&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 55. 二叉树的深度，平衡二叉 P271&quot;&gt;&lt;/a&gt;剑指of
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer54. 二叉搜索树的第K大个节点 P269</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer54/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer54/</id>
    <published>2019-11-03T02:15:58.000Z</published>
    <updated>2019-11-03T02:29:38.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer54-二叉搜索树的第k大个节点-P269"><a href="#剑指offer54-二叉搜索树的第k大个节点-P269" class="headerlink" title="剑指offer54.  二叉搜索树的第k大个节点  P269"></a>剑指offer54.  二叉搜索树的第k大个节点  P269</h2><p>题目：给定一棵二叉搜索树，请找出其中的第k大的结点。</p><p><strong>中序遍历BST就是有序数列</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> BinaryTreeNode* <span class="title">KthNode</span><span class="params">(<span class="keyword">const</span> BinaryTreeNode* pRoot, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> <span class="comment">// 主调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span> || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inorder(pRoot, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序模板</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> BinaryTreeNode* <span class="title">inorder</span> <span class="params">(<span class="keyword">const</span> BinaryTreeNode* root, <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       BinaryTreeNode* resu = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">       resu = inorder(root-&gt;left, k);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (k == <span class="number">1</span>) </span><br><span class="line">           resu = root;         <span class="comment">//真正赋值的地方只有这     </span></span><br><span class="line">       k--;</span><br><span class="line">       <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">              resu = inorder(root-&gt;right, k);</span><br><span class="line">       <span class="keyword">return</span> resu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer54-二叉搜索树的第k大个节点-P269&quot;&gt;&lt;a href=&quot;#剑指offer54-二叉搜索树的第k大个节点-P269&quot; class=&quot;headerlink&quot; title=&quot;剑指offer54.  二叉搜索树的第k大个节点  P269&quot;&gt;&lt;/a&gt;剑指
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer53. 在排序数组中查找满足条件的数字 P263</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer53/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer53/</id>
    <published>2019-11-03T02:15:55.000Z</published>
    <updated>2019-11-03T02:27:47.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer53-在排序数组中查找满足条件的数字-P263"><a href="#剑指offer53-在排序数组中查找满足条件的数字-P263" class="headerlink" title="剑指offer53.  在排序数组中查找满足条件的数字   P263"></a>剑指offer53.  在排序数组中查找满足条件的数字   P263</h2><p>题目：统计一个数字在排序数组中出现的次数。例如输入排序数组{1, 2, 3, 3, 3, 3, 4, 5}和数字3，由于3在这个数组中出现了4次，因此输出4。</p><p><strong>在排序的数组里找第1个XX，都是在二分查找的模板下，在if（==）那里为真时，比较mid前一个数是不是满足某种条件，再递归。 二分查找，start&gt;end时，查找失败</strong></p><p><strong>1.    统计一个数字在排序数组中出现的次数P263</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找数组中第一个k的索引 （看两个**注释哪里，其实就是在二分查找成功模板） </span></span><br><span class="line">findFirstK(<span class="keyword">int</span> *nums,  <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">// 数组中没有k</span></span><br><span class="line"><span class="keyword">int</span> mid = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == k) &#123;          <span class="comment">// ****** 相等条件 </span></span><br><span class="line"><span class="keyword">if</span> (mid == <span class="number">0</span>) <span class="keyword">return</span> mid;    <span class="comment">// 索引是0肯定是第一个k </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] == k) &#123; <span class="comment">// mid上一个也是k，说明第一个k在左半边 </span></span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;                     <span class="comment">// mid上一个不是k，说明第一个k是mid </span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; k) &#123;       <span class="comment">// ******左右递归条件 </span></span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">start = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> findFirstK(nums, k, start, end);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 找数组中最后一个k的索引 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLastK</span><span class="params">(<span class="keyword">int</span> *nums,<span class="keyword">int</span> len, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == k) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == len - <span class="number">1</span>) <span class="keyword">return</span> mid;    <span class="comment">// 肯定是最后一个</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid + <span class="number">1</span>] == k) &#123;    <span class="comment">// 右边还有k</span></span><br><span class="line">start = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; k) &#123;           <span class="comment">// 递归条件</span></span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> </span><br><span class="line">start = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> findLastK(nums, k, start, end);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findK</span><span class="params">(<span class="keyword">int</span> *nums,<span class="keyword">int</span> len, <span class="keyword">int</span> k)</span> </span>&#123;           <span class="comment">// 主调函数</span></span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> first_index_of_k = findFirstK(nums, k, <span class="number">0</span>, len - <span class="number">1</span>);   <span class="comment">// 第一个k出现的位置</span></span><br><span class="line"><span class="keyword">int</span> last_index_of_k  = findLastK (nums, k, <span class="number">0</span>, len - <span class="number">1</span>); <span class="comment">//  最后一个k出现的位置</span></span><br><span class="line"><span class="comment">//数组只有一个k时，两个递归返回索引值一样 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (first_index_of_k &gt; <span class="number">-1</span> &amp;&amp; last_index_of_k &gt; <span class="number">-1</span>) </span><br><span class="line"><span class="keyword">return</span> last_index_of_k - first_index_of_k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">// 数组没有k</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.    0 <del>n缺失的数字  P266（n是长度数值在0</del>n之间取，一个数字只出现一次，且有序）</strong>   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换成在排序数组中找到第一个nums[i] != i的数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *nums, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums[mid] != mid ) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] == mid - <span class="number">1</span>) <span class="keyword">return</span> mid;  <span class="comment">// 这里有特判0</span></span><br><span class="line"><span class="keyword">if</span> (nums[mid - <span class="number">1</span>] != mid - <span class="number">1</span>) &#123;</span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">start = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(start == len) <span class="keyword">return</span> len; <span class="comment">//到最后发现所有i都等于nums[i],缺失的数就是n</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> findCore(nums, len, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用等差数列和减去sum，时间复杂度是O(n)，二分是logN；</strong>  </p><p><strong>3.    排序数组中数组和下标相等的元素  P267</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums[i] = i，那么索引小于i的j都满足 nums[j] &lt; j;大于i的相反 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">// 没有找到符合条件 </span></span><br><span class="line"><span class="keyword">int</span> mid = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == mid) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; mid)      <span class="comment">// 索引和对应的数比较，作为递归条件</span></span><br><span class="line">             start = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>   </span><br><span class="line">             end = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> findCore(nums, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer53-在排序数组中查找满足条件的数字-P263&quot;&gt;&lt;a href=&quot;#剑指offer53-在排序数组中查找满足条件的数字-P263&quot; class=&quot;headerlink&quot; title=&quot;剑指offer53.  在排序数组中查找满足条件的数字   P2
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer52. 两个链表第一个公共节点 P253</title>
    <link href="http://yoursite.com/2019/11/03/%E5%89%91%E6%8C%87offer52/"/>
    <id>http://yoursite.com/2019/11/03/剑指offer52/</id>
    <published>2019-11-03T02:15:51.000Z</published>
    <updated>2019-11-03T02:22:50.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer52-两个链表第一个公共节点-P253"><a href="#剑指offer52-两个链表第一个公共节点-P253" class="headerlink" title="剑指offer52.  两个链表第一个公共节点 P253"></a>剑指offer52.  两个链表第一个公共节点 P253</h2><p>题目：输入两个链表，找出它们的第一个公共结点。</p><p><strong>统计两个链表的长度差sub，长的先走sub步，第二次遍历看两个工作指针是不是相等</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode *head)</span> </span>&#123;   <span class="comment">// 统计链表长度</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">ListNode *p = head;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = p -&gt; m_pNext;</span><br><span class="line">++count;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找两个链表长度差值sub，长的先走sub步，然后一起出发看指针是否相同即可</span></span><br><span class="line"><span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = getLength(pHead1);</span><br><span class="line"><span class="keyword">int</span> len2 = getLength(pHead2);</span><br><span class="line"><span class="keyword">if</span> (len1 == <span class="number">0</span> || len2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">ListNode *p, *q;</span><br><span class="line"><span class="keyword">int</span> sub = len1 &gt; len2 ? (len1 - len2) : (len2 - len1);</span><br><span class="line"><span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">p = pHead1;</span><br><span class="line">q = pHead2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p = pHead2;</span><br><span class="line">q = pHead1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sub--) p = p -&gt;m_pNext;</span><br><span class="line"><span class="keyword">while</span> (p != q &amp;&amp; p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = p -&gt; m_pNext;</span><br><span class="line">q = q -&gt; m_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">// 没有公共节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer52-两个链表第一个公共节点-P253&quot;&gt;&lt;a href=&quot;#剑指offer52-两个链表第一个公共节点-P253&quot; class=&quot;headerlink&quot; title=&quot;剑指offer52.  两个链表第一个公共节点 P253&quot;&gt;&lt;/a&gt;剑指offe
      
    
    </summary>
    
    
      <category term="剑指offr" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offr/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer51. 逆序对 P249</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer51/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer51/</id>
    <published>2019-11-01T08:13:57.000Z</published>
    <updated>2019-11-03T02:10:56.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer51-逆序对-P249"><a href="#剑指offer51-逆序对-P249" class="headerlink" title="剑指offer51.  逆序对 P249"></a>剑指offer51.  逆序对 P249</h2><p>题目：在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">归并的思想</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000000</span>; <span class="comment">// 模值 如果答案比较大，可以根据题意返回取模结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mergeArray</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> *copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= end) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line"><span class="keyword">int</span> left = mergeArray(nums, copy, start, mid); <span class="comment">//先递归才能保证下面左右子数组有序</span></span><br><span class="line"><span class="keyword">int</span> right = mergeArray(nums, copy, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;                        <span class="comment">// 此次归并的逆序数</span></span><br><span class="line"><span class="keyword">int</span> i = mid, j = end, index_copy = end;  <span class="comment">// 从右到左遍历、对比</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &gt;= start &amp;&amp; j &gt; mid ) &#123;    <span class="comment">// 两段子数组都没有到头</span></span><br><span class="line"><span class="comment">// 因为两段都排续了，第一段最右边nums[i]的比第二段最右num[j]的大，</span></span><br><span class="line"><span class="comment">// 证明nums[i]比第二段剩下的所有（mid+1到j）都大，对于对应的逆序数就是第二段剩余的数字个数</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;   </span><br><span class="line">count += j - mid;                     <span class="comment">// 第二段剩余个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = mid + <span class="number">1</span>; k &lt;= j; ++k)         <span class="comment">// 在这里可以输出所有逆序对</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d - %d, "</span>, nums[i], nums[k]);</span><br><span class="line">copy[index_copy--] = nums[i--];  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">copy[index_copy--] = nums[j--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count &gt; MAX) count %= MAX;    <span class="comment">// 可选项，太大了的话就取给定的max模 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &gt;= start) copy[index_copy--] = nums[i--];  <span class="comment">//有一段没有遍历完，加到copy</span></span><br><span class="line"><span class="keyword">while</span> (j &gt; mid)    copy[index_copy--] = nums[j--]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">nums[i] = copy[i];  </span><br><span class="line"><span class="comment">// 在递归里上一次操作的是copy，但是下次比较的是nums，所以要把更新的数组重给nums </span></span><br><span class="line"><span class="keyword">return</span> count + left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span> || len &lt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; ++i)    copy[i] = nums[i];   <span class="comment">// 复制辅助数组</span></span><br><span class="line"><span class="keyword">int</span> ans = mergeArray(nums, copy, <span class="number">0</span>, len - <span class="number">1</span>); </span><br><span class="line"><span class="keyword">delete</span>[] copy;   <span class="keyword">return</span> ans;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer51-逆序对-P249&quot;&gt;&lt;a href=&quot;#剑指offer51-逆序对-P249&quot; class=&quot;headerlink&quot; title=&quot;剑指offer51.  逆序对 P249&quot;&gt;&lt;/a&gt;剑指offer51.  逆序对 P249&lt;/h2&gt;&lt;p&gt;题目
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer49.丑数 P240 Leetcode 264</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer49/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer49/</id>
    <published>2019-11-01T08:13:51.000Z</published>
    <updated>2019-11-03T02:14:39.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer49-丑数-P240-leetcode-264"><a href="#剑指offer49-丑数-P240-leetcode-264" class="headerlink" title="剑指offer49.丑数 P240 leetcode 264"></a>剑指offer49.丑数 P240 leetcode 264</h2><p>题目：我们把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做第一个丑数。</p><p><strong>丑数应该是另一个丑数乘以2，3，5得到的结果所以创建应该丑数表，里面是从小到大的丑数，每个丑数都是前面某个丑数乘以2，3或5得到的。</strong></p><ol><li>丑数初始打表，三个指针分别指向 乘以2，3，5的指针</li><li>把丑数表头和2，3，5分别相乘，最小的一定是下一个丑数，然后更新三个指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;                      <span class="comment">// 求三个数最小</span></span><br><span class="line"><span class="keyword">return</span> (a &lt; b ? a : b) &lt; c ? (a &lt; b ? a : b) : c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;           <span class="comment">// 找到第n个丑数</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *uglytable = <span class="keyword">new</span> <span class="keyword">int</span>[n];          </span><br><span class="line">    uglytable[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = <span class="number">0</span>, index3 = <span class="number">0</span>, index5 = <span class="number">0</span>; <span class="comment">// 分别指向当前235因子指向的table索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;              <span class="comment">// 往后打丑数表，丑数值递增</span></span><br><span class="line">        <span class="comment">// 3个索引分别跟三个因子相乘，一定是丑数，而且最小的一定是下一个丑数</span></span><br><span class="line">    <span class="keyword">int</span> minof235 = min(uglytable[index2] * <span class="number">2</span>, uglytable[index3] * <span class="number">3</span>, </span><br><span class="line">                           uglytable[index5] * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">uglytable[i] = minof235;</span><br><span class="line"><span class="comment">//更新三个索引，小于当前丑数的时候，索引肯定是小的，所以用while一直找，if效率低</span></span><br><span class="line">While  (minof235 &gt;= uglytable[index2] * <span class="number">2</span>) ++index2;</span><br><span class="line">While  (minof235 &gt;= uglytable[index3] * <span class="number">3</span>) ++index3;</span><br><span class="line">While  (minof235 &gt;= uglytable[index5] * <span class="number">5</span>) ++index5;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> ans = uglytable[n - <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">delete</span>[] uglytable;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer49-丑数-P240-leetcode-264&quot;&gt;&lt;a href=&quot;#剑指offer49-丑数-P240-leetcode-264&quot; class=&quot;headerlink&quot; title=&quot;剑指offer49.丑数 P240 leetcode 264&quot;&gt;
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer48.最长不含重复字符的子串 P236 Leetcode 3</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer48/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer48/</id>
    <published>2019-11-01T08:13:48.000Z</published>
    <updated>2019-11-03T02:05:44.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer48-最长不含重复字符的子串-P236-leetcode-3"><a href="#剑指offer48-最长不含重复字符的子串-P236-leetcode-3" class="headerlink" title="剑指offer48. 最长不含重复字符的子串  P236   leetcode 3"></a>剑指offer48. 最长不含重复字符的子串  P236   leetcode 3</h2><p>题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。</p><p><strong>用压缩优化后的dp，（只用ans_cur一个变量存，不用数组）</strong>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstringWithoutDuplication</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="string">""</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, ans_cur = <span class="number">0</span>;          <span class="comment">// ans存当前最大的长度，ans_last存dp[i]长度</span></span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">27</span>];                   <span class="comment">// 存上一次这个字母出现的位置</span></span><br><span class="line">fill(hash, hash + <span class="number">27</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i)&#123; </span><br><span class="line"><span class="keyword">int</span> temp = str[i] - <span class="string">'a'</span>; </span><br><span class="line">        <span class="comment">// 当前字符第一次出现，或者在这两个重复字符之间已经有别的重复字符出现，</span></span><br><span class="line">       <span class="comment">// 已经更新过当前的ans_cur了。</span></span><br><span class="line"><span class="keyword">if</span> (hash[temp] == <span class="number">-1</span> || i - hash[temp] &gt; ans_cur) &#123;   <span class="comment">// 后一个条件容易忽略！！！</span></span><br><span class="line">    ++ ans_cur;                                  </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ans_cur = i - hash[temp];              <span class="comment">// 更新当前的dp[i]长度</span></span><br><span class="line">   &#125;</span><br><span class="line">   ans = ans &gt; ans_cur ? ans : ans_cur;      <span class="comment">// 看历史最大长度和当前长度谁大</span></span><br><span class="line">hash[temp] = i;                        <span class="comment">// 更新这个字符最近一次出现的索引i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">解法<span class="number">2</span>：用trick ：start变量来代替hash表  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>); <span class="comment">// 用来记录字符上次出现的位置</span></span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>, start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.length(); i++)&#123;</span><br><span class="line"> <span class="comment">// s[i]字符上次出现的下标是否在start之后，若是，则重复了，则修改start为上一次s[i]的位置，从它后一位开始搜索</span></span><br><span class="line">            <span class="keyword">if</span> (dict[s[i]] &gt; start)  </span><br><span class="line">                start = dict[s[i]];</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            maxlen = max(maxlen, i - start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer48-最长不含重复字符的子串-P236-leetcode-3&quot;&gt;&lt;a href=&quot;#剑指offer48-最长不含重复字符的子串-P236-leetcode-3&quot; class=&quot;headerlink&quot; title=&quot;剑指offer48. 最长不含重复字
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer47.礼物最大值（矩阵路径和最大最小）P233</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer47/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer47/</id>
    <published>2019-11-01T08:13:45.000Z</published>
    <updated>2019-11-03T02:03:52.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer47-礼物最大值（矩阵路径和最大最小）P233"><a href="#剑指offer47-礼物最大值（矩阵路径和最大最小）P233" class="headerlink" title="剑指offer47 .礼物最大值（矩阵路径和最大最小）P233"></a>剑指offer47 .礼物最大值（矩阵路径和最大最小）P233</h2><p>题目：在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格直到到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p><p><strong>此解法原为dp二维矩阵，此方法为优化dp矩阵为cols长的一维数组，解析见235页（手画的图，没办法贴上。。。）</strong></p><p>状态转移方程： <code>dp[j] = max(dp[j], dp[j-1]) + num;</code><br>当前的上一行j对应路径和dp[j]，当前左边的路径和dp[j-1] 取最大的， 加上当前权重</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findBiggestPathSum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *matrix,  <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="literal">NULL</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp_cols[cols];</span><br><span class="line"><span class="built_in">memset</span>(dp_cols, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp_cols));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> up = <span class="number">0</span>;     <span class="comment">// 这两行是处理i，j有0的时候（下面方程有dp[j-1]）</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i  &gt;=  <span class="number">1</span>) &#123;   <span class="comment">// 两个if如果i，j不是0，就把上一列和上一行dp搬下来</span></span><br><span class="line">up = dp_cols[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j  &gt;=  <span class="number">1</span>) &#123;</span><br><span class="line">left = dp_cols[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp_cols[j] = (left &gt; up ? left : up) + matrix[i * cols + j];</span><br><span class="line">          <span class="comment">// 上面比较大小不加括号的话，返回不是up是up+martix！ </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp_cols[cols - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer47-礼物最大值（矩阵路径和最大最小）P233&quot;&gt;&lt;a href=&quot;#剑指offer47-礼物最大值（矩阵路径和最大最小）P233&quot; class=&quot;headerlink&quot; title=&quot;剑指offer47 .礼物最大值（矩阵路径和最大最小）P233&quot;
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer46.把数字翻译成字符串 P231</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer46/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer46/</id>
    <published>2019-11-01T08:13:42.000Z</published>
    <updated>2019-11-03T02:00:07.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer46-把数字翻译成字符串-P231"><a href="#剑指offer46-把数字翻译成字符串-P231" class="headerlink" title="剑指offer46 .  把数字翻译成字符串 P231"></a>剑指offer46 .  把数字翻译成字符串 P231</h2><p>题目：给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成”a”，1翻<br>译成”b”，……，11翻译成”l”，……，25翻译成”z”。一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p><p>其实还是<strong>斐波那契问题</strong>，只不过要多加一个判断，看当前数字和前一个能不能组合成字母。<br>因为要遍历数字的每个位数，所以可以转换成字符串处理。</p><p><strong>状态转移方程:</strong>  </p><pre><code>如果当前元素和上一个元素可以组合成字母：                dp[i] = dp[i - 1] + dp[i - 2];否则，当前数字只有一个选择，那当前种类就和i-1时种类一样  dp[i] =  dp[i - 1];</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transferNumberToString</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = to_string(num); <span class="comment">// 转换成字符串</span></span><br><span class="line"><span class="keyword">int</span> len = str.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];   <span class="comment">// dp初始化</span></span><br><span class="line">dp[<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">int</span> temp = (str[<span class="number">0</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + str[<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span> (temp &gt;= <span class="number">10</span> &amp;&amp; temp &lt;= <span class="number">25</span>) </span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; ++i) &#123;  </span><br><span class="line"><span class="keyword">int</span> last = str[i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">int</span> cur  = str[i] - <span class="string">'0'</span> + last * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (cur &gt;= <span class="number">10</span> &amp;&amp; cur &lt;= <span class="number">25</span>) &#123;   <span class="comment">// 可以组成</span></span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                 <span class="comment">// 上一个字和自己组不成一个字母</span></span><br><span class="line">dp[i] =  dp[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = dp[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">delete</span>[] dp;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer46-把数字翻译成字符串-P231&quot;&gt;&lt;a href=&quot;#剑指offer46-把数字翻译成字符串-P231&quot; class=&quot;headerlink&quot; title=&quot;剑指offer46 .  把数字翻译成字符串 P231&quot;&gt;&lt;/a&gt;剑指offer46 .
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer45.把数组排成最小(大)数 P227</title>
    <link href="http://yoursite.com/2019/11/01/%E5%89%91%E6%8C%87offer45/"/>
    <id>http://yoursite.com/2019/11/01/剑指offer45/</id>
    <published>2019-11-01T08:13:38.000Z</published>
    <updated>2019-11-03T01:56:24.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer45-把数组排成最小-大-数-P227"><a href="#剑指offer45-把数组排成最小-大-数-P227" class="headerlink" title="剑指offer45  把数组排成最小(大)数  P227"></a>剑指offer45  把数组排成最小(大)数  P227</h2><p>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3, 32, 321}，则打印出这3个数字能排成的最小数字321323。</p><p>这道题是隐藏的<strong>大数问题</strong>，应该想到用字符串操作，<strong>难点在于找到一个新的比较规则来排序数组</strong>，其实整数不好比的话，字符串字典序比较很容易想到，按字典序排, 321 ，32，3 拼接起来刚好满足要求。<strong>（和书上做法不太一样，这里用string + 可能存在效率问题）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;  <span class="comment">// 不是a &lt; b</span></span><br><span class="line"><span class="keyword">return</span> a + b &lt; b + a;    <span class="comment">// 看两个字符串相加怎么样字典序最小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123; <span class="comment">// 原数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v_str;            <span class="comment">// 用来把整数转换成string存储</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">v_str.push_back(to_string(i)); </span><br><span class="line">&#125; </span><br><span class="line">sort(v_str.begin(), v_str.end(), cmp); <span class="comment">// 按字典序排, 321, 32，3</span></span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">""</span>;           <span class="comment">// 直接加就行       </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v_str) &#123; <span class="comment">// str =str+ "a"加的运算产生的是一个新的对象，再把结果返回，                                    </span></span><br><span class="line">ans += i;   <span class="comment">// str += "a"涉及的是对象的引用，操作后返回引用，避免产生新对象。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer45-把数组排成最小-大-数-P227&quot;&gt;&lt;a href=&quot;#剑指offer45-把数组排成最小-大-数-P227&quot; class=&quot;headerlink&quot; title=&quot;剑指offer45  把数组排成最小(大)数  P227&quot;&gt;&lt;/a&gt;剑指offe
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
