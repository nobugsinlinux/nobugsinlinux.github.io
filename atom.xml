<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>G2.int.BUPT</title>
  
  <subtitle>我爱网管</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-31T08:06:23.762Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郭源潮</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer20. 表示数值的字符串P127</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer20/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer20/</id>
    <published>2019-10-31T06:55:08.000Z</published>
    <updated>2019-10-31T08:06:23.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer20-表示数值的字符串P127"><a href="#剑指offer20-表示数值的字符串P127" class="headerlink" title="剑指offer20 .  表示数值的字符串P127"></a>剑指offer20 .  表示数值的字符串P127</h2><p>题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”、“5e2”、“-123”、“3.1416”及“-1E-16”都是，但“12e”、“1a3.14”、“1.2.3、“+-5”及“12e+5.4不是<br>（这个题的描述相当不清楚，很多有悖常理的数字格式也是对的，leetcode上很多人吐槽）</p><p><strong>1.    用自动机做</strong></p><p><a href="https://blog.csdn.net/qq_43778308/article/details/102838980" target="_blank" rel="noopener" title="图片这这个博客里面">https://blog.csdn.net/qq_43778308/article/details/102838980</a></p><p>上图只是为了说明自动机处理的原理，下面代码不是按照上面这个图写的**。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> state=<span class="number">1</span>;   <span class="comment">// 初始状态</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i)&#123;</span><br><span class="line">       <span class="keyword">char</span> c = str[i];</span><br><span class="line">           <span class="keyword">switch</span> (state)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                   <span class="keyword">if</span>(c==<span class="string">' '</span>)              state=<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'+'</span>||c==<span class="string">'-'</span>) state=<span class="number">2</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))     state=<span class="number">3</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'.'</span>)         state=<span class="number">4</span>;</span><br><span class="line">                   <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                   <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))          state=<span class="number">3</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'.'</span>)         state=<span class="number">4</span>;</span><br><span class="line">                   <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                   <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))          state=<span class="number">3</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'e'</span>||c==<span class="string">'E'</span>) state=<span class="number">6</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'.'</span>)         state=<span class="number">5</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">' '</span>)         state=<span class="number">9</span>;</span><br><span class="line">                   <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                   <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))          state=<span class="number">5</span>;</span><br><span class="line">                   <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                   <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))          state=<span class="number">5</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'e'</span>||c==<span class="string">'E'</span>) state=<span class="number">6</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">' '</span>)         state=<span class="number">9</span>;</span><br><span class="line">                   <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                   <span class="keyword">if</span>(c==<span class="string">'+'</span>||c==<span class="string">'-'</span>)      state=<span class="number">7</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))     state=<span class="number">8</span>;</span><br><span class="line">                   <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                   <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))          state=<span class="number">8</span>;</span><br><span class="line">                   <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                   <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))          state=<span class="number">8</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">' '</span>)         state=<span class="number">9</span>;</span><br><span class="line">                   <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                   <span class="keyword">if</span>(c==<span class="string">' '</span>)              state=<span class="number">9</span>;</span><br><span class="line">                   <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> state==<span class="number">3</span>||state==<span class="number">5</span>||state==<span class="number">8</span>||state==<span class="number">9</span>;   <span class="comment">// 一共有4个正确的结束状态</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer20-表示数值的字符串P127&quot;&gt;&lt;a href=&quot;#剑指offer20-表示数值的字符串P127&quot; class=&quot;headerlink&quot; title=&quot;剑指offer20 .  表示数值的字符串P127&quot;&gt;&lt;/a&gt;剑指offer20 .  表示数值
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="自动机" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="正则匹配" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer19. 正则表达式匹配 P124</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer19/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer19/</id>
    <published>2019-10-31T06:55:02.000Z</published>
    <updated>2019-10-31T07:31:57.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer19-正则表达式匹配-P124"><a href="#剑指offer19-正则表达式匹配-P124" class="headerlink" title="剑指offer19. 正则表达式匹配  P124"></a>剑指offer19. 正则表达式匹配  P124</h2><p>题目：请实现一个函数用来匹配包含’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”及”ab*a”均不匹配。</p><p><strong>因为 * 的存在让整个题目复杂，那我们把下一个字符是不是*作为划分依据。</strong></p><p>Case 1. 当模式中的第二个字符不是“*”时：<br>1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。<br>2、如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</p><p>Case 2 . <strong>当模式中的第二个字符是“*”时：</strong><br>可以有3种匹配方式：<br>1、模式后移2字符，相当于x*被忽略；比如 str : ab , pattern : b*ab<br>2、字符串后移1字符，模式后移2字符，x*相当于只匹配一个字符；ab 和 a*b<br>3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为<em>可以匹配多位；aab 和a\</em>b</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatchedCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *pattern)</span> </span>&#123;  <span class="comment">// 匹配递归函数</span></span><br><span class="line"><span class="keyword">if</span> (*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">true</span>;      <span class="comment">// 两个递归出口</span></span><br><span class="line"><span class="keyword">if</span> (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*(pattern + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;                                 <span class="comment">// case 2情况 </span></span><br><span class="line"><span class="keyword">if</span> ((*str == *pattern)|| (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>)) &#123;  </span><br><span class="line"> <span class="comment">// 当前字符匹配成功，相当于又重新进入case 2的情况，有三种选择</span></span><br><span class="line"><span class="keyword">return</span>  isMatchedCore(str + <span class="number">1</span>, pattern)</span><br><span class="line">      || isMatchedCore(str + <span class="number">1</span>, pattern + <span class="number">2</span>) </span><br><span class="line">  || isMatchedCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;  <span class="comment">// 当前匹配失败那么*就没有作用了，跳过下一个*,只能是case 2.1的情况</span></span><br><span class="line"><span class="keyword">return</span> isMatchedCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;                                        <span class="comment">// case1情况下一个不是*</span></span><br><span class="line"><span class="keyword">if</span> ((*str == *pattern)|| (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>)) <span class="comment">// case1.1</span></span><br><span class="line"><span class="keyword">return</span>   isMatchedCore(str + <span class="number">1</span>, pattern + <span class="number">1</span>);   </span><br><span class="line"><span class="keyword">else</span>                                            <span class="comment">//  case 1.2</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatched</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *pattern)</span> </span>&#123;    <span class="comment">// 匹配函数</span></span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span> &amp;&amp; pattern == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (pattern == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> isMatchedCore(str, pattern); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer19-正则表达式匹配-P124&quot;&gt;&lt;a href=&quot;#剑指offer19-正则表达式匹配-P124&quot; class=&quot;headerlink&quot; title=&quot;剑指offer19. 正则表达式匹配  P124&quot;&gt;&lt;/a&gt;剑指offer19. 正则表达式匹配
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="正则匹配" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer18．在O(1)时间内删除链表节点 P119</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer18/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer18/</id>
    <published>2019-10-31T06:54:59.000Z</published>
    <updated>2019-10-31T07:24:55.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer18．-在O-1-时间内删除链表节点-P119"><a href="#剑指offer18．-在O-1-时间内删除链表节点-P119" class="headerlink" title="剑指offer18． 在O(1)时间内删除链表节点  P119"></a>剑指offer18． 在O(1)时间内删除链表节点  P119</h2><p><strong>题目：</strong><br>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。</p><p>/* 既然要在O（1）时间内删除，就不需要遍历，或者说大多数情况下不需要遍历整个链表，那么在O(1) 时间内我们能得到哪些东西呢？ <strong>1.首先头指针和头指针下一个节点</strong>显然没有什么用，再者就是2. 需要<strong>删除的节点p和他的下一个节点next</strong>， 那么肯定是围绕着p和next操作。如果要删除应该链表节点，通常要找到它的前驱，这一道题能够构成这种前后关系的就是删除next，它的前驱是p，于是我们把next的东西复制给p，再删除next就ok了。<strong>以上是普通情况</strong><br><strong>当p是头结点时候，要特判，p是尾节点时候，只能够遍历整个链表了</strong><br>此外，因为o（1）时间的限制，我们不能确保链表中有p，这只能交给函数调用者处理了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode **pHeadList, ListNode *pToDeleteNode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(*pHeadList) || !pToDeleteNode) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (*pHeadList == pToDeleteNode) &#123;           <span class="comment">// 删头节点 </span></span><br><span class="line">ListNode *temp = *pHeadList;</span><br><span class="line"><span class="keyword">if</span> (temp -&gt; next == <span class="literal">NULL</span>) &#123;             <span class="comment">// 链表只有一个节点 </span></span><br><span class="line">*pHeadList = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                               <span class="comment">// 链表有其他节点 </span></span><br><span class="line">*pHeadList = (*pHeadList) -&gt; next;</span><br><span class="line"><span class="comment">// 不要使用delete (*pHeadList)，在没有被分配之前里面的内容还是完好的。</span></span><br><span class="line"><span class="comment">// 而且delete不负责将指针设置为NULL。</span></span><br><span class="line">            <span class="keyword">delete</span> temp; </span><br><span class="line">            temp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pToDeleteNode -&gt; next != <span class="literal">NULL</span>) &#123;   <span class="comment">// 在中间删除，把next值给当前节点，</span></span><br><span class="line">                                            <span class="comment">// 并且删除next</span></span><br><span class="line">ListNode *temp = pToDeleteNode -&gt; next;</span><br><span class="line">pToDeleteNode -&gt; key  = pToDeleteNode -&gt; next -&gt;key;</span><br><span class="line">pToDeleteNode -&gt; next = pToDeleteNode -&gt; next -&gt; next;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">temp = <span class="literal">NULL</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pToDeleteNode -&gt; next == <span class="literal">NULL</span>) &#123;  <span class="comment">// 删除尾节点，必须遍历 </span></span><br><span class="line">ListNode *p = *pHeadList;</span><br><span class="line"><span class="keyword">while</span> (p -&gt; next != pToDeleteNode) p = p -&gt; next;</span><br><span class="line">p -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> pToDeleteNode;</span><br><span class="line">pToDeleteNode = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer18．-在O-1-时间内删除链表节点-P119&quot;&gt;&lt;a href=&quot;#剑指offer18．-在O-1-时间内删除链表节点-P119&quot; class=&quot;headerlink&quot; title=&quot;剑指offer18． 在O(1)时间内删除链表节点  P119&quot;
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer17. 打印从1到最大的n位数 P114</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer17/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer17/</id>
    <published>2019-10-31T06:54:53.000Z</published>
    <updated>2019-10-31T07:42:14.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer17-打印从1到最大的n位数-P114"><a href="#剑指offer17-打印从1到最大的n位数-P114" class="headerlink" title="剑指offer17.  打印从1到最大的n位数     P114"></a>剑指offer17.  打印从1到最大的n位数     P114</h2><p>题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p><p><strong>1.    方法一： 用字符数组str倒着存储大数。每次大数自增1，如果溢出，表明打印完</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数完成大数自增1的功能，并返回是否已经“溢出”（长度满足题目要求）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Increment</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> current_length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;                             <span class="comment">// 进位</span></span><br><span class="line"><span class="keyword">bool</span> overflow = <span class="literal">false</span>;                     <span class="comment">// 溢出标志</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = current_length - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i) &#123;    <span class="comment">// 加1后大数从后往前每一位进行更新</span></span><br><span class="line"><span class="keyword">int</span> num = str[i] - <span class="string">'0'</span> + carry;</span><br><span class="line">      <span class="comment">//不能再上面直接+1，因为这个for后面都是为了处理第一次的进位的</span></span><br><span class="line"><span class="keyword">if</span> (i == current_length - <span class="number">1</span>)  num++;  <span class="comment">// 只有最低位+1</span></span><br><span class="line"><span class="keyword">if</span> (num &gt;= <span class="number">10</span>) &#123;                   <span class="comment">// 有进位</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;                    <span class="comment">// 有进位，而且是最高位i=0产生的，溢出</span></span><br><span class="line">overflow = <span class="literal">true</span>;           <span class="comment">// 调用函数也退出循环</span></span><br><span class="line"><span class="keyword">break</span>;                   <span class="comment">// 退出</span></span><br><span class="line">&#125;</span><br><span class="line">str[i] = num - <span class="number">10</span> + <span class="string">'0'</span>;         <span class="comment">// 否则，处理进位</span></span><br><span class="line">carry = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">str[i] = num + <span class="string">'0'</span>;     <span class="comment">//这后面不用加carry=0 </span></span><br><span class="line">        <span class="keyword">break</span>;    <span class="comment">// 因为后面的循环时为了处理进位，没有进位就直接退出了 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> overflow;        <span class="comment">//返回溢出标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;         <span class="comment">// 调用函数，打印1 -- n位最大数</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span>;           </span><br><span class="line"><span class="keyword">char</span> *str = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="string">'0'</span>,<span class="keyword">sizeof</span>(str));</span><br><span class="line">str[n] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">while</span> (!Increment(str, n))             <span class="comment">// 自增后，判断是否溢出，</span></span><br><span class="line">print(str, n);                   <span class="comment">// 没有溢出，打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.    方法二，递归全排列</strong></p><p>如果我们在数字前面补0，就会发现n位所有十进制数其实就是n个从0到9数字的全排列。也就是说，我们把数字的每一位都从0到9遍历一遍，就得到了所有的十进制数。只是在打印的时候，排在前面的0不打印出来罢了。全排列用递归表达，数字的每一位都可能是0~9中的一个数，然后设置下一位。<br><strong>递归结束的条件是我们设置了的数字的最后一位。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits2</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;      </span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">char</span> *nums = <span class="keyword">new</span> <span class="keyword">char</span>[len];             <span class="comment">// 不用len+1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)          </span><br><span class="line">nums[i] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i)&#123;          <span class="comment">// 从第0位开始设置，取0-9调用递归</span></span><br><span class="line">nums[<span class="number">0</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">printCore(nums,len,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] nums;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCore</span><span class="params">(<span class="keyword">char</span> *nums, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">// 求排列，index是当前设置的第index位</span></span><br><span class="line"><span class="keyword">if</span> (index == len - <span class="number">1</span> ) &#123;        <span class="comment">// 递归出口，设置完最后一位</span></span><br><span class="line">print(nums, len);          <span class="comment">//  打印</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">9</span>; ++i) &#123;  <span class="comment">// 递归当前第index后面的若干位</span></span><br><span class="line"> nums[index + <span class="number">1</span>] = i + <span class="string">'0'</span>;</span><br><span class="line"> printCore(nums, len, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把符合条件的一个数打印出来，注意题干，从1开始打印！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span> </span>&#123;     </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[i] == <span class="string">'0'</span>) ++i;     <span class="comment">//剔除前导0 </span></span><br><span class="line"><span class="keyword">if</span> (i != len) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, str[i]);</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer17-打印从1到最大的n位数-P114&quot;&gt;&lt;a href=&quot;#剑指offer17-打印从1到最大的n位数-P114&quot; class=&quot;headerlink&quot; title=&quot;剑指offer17.  打印从1到最大的n位数     P114&quot;&gt;&lt;/a&gt;剑指
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer16. 数值的整数次方 P110</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer16/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer16/</id>
    <published>2019-10-31T06:54:49.000Z</published>
    <updated>2019-10-31T07:16:44.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer16-数值的整数次方P110"><a href="#剑指offer16-数值的整数次方P110" class="headerlink" title="剑指offer16.  数值的整数次方P110"></a>剑指offer16.  数值的整数次方P110</h2><p>题目：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> esp = <span class="number">1e-6</span>; </span><br><span class="line"><span class="keyword">bool</span> isValid = <span class="literal">false</span>;   <span class="comment">// power函数返回0时，判断合不合法，true时不合法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">powerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 此输入保证指数非负 </span></span><br><span class="line"><span class="keyword">if</span> (exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (exponent == <span class="number">1</span>) <span class="keyword">return</span> base;</span><br><span class="line"><span class="comment">// 指数除以2递归 </span></span><br><span class="line"><span class="keyword">double</span> ans = powerWithUnsignedExponent(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">ans *= ans;            <span class="comment">// 先在上一步递归里算出来a的（n/2）次方， 再平方 </span></span><br><span class="line"><span class="keyword">if</span> ((exponent &amp; <span class="number">1</span>)) &#123;    <span class="comment">// 如果指数是奇数还要再乘以base （规律见p112） </span></span><br><span class="line">ans *= base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">isValid = <span class="literal">false</span>;             <span class="comment">// 这是全局变量，不能省 ，默认合法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(base - <span class="number">0.0</span>) &lt;= esp &amp;&amp; exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    isValid = <span class="literal">true</span>;      <span class="comment">// 不合法 的0.0 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (exponent == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">if</span> (base == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>;           <span class="comment">// 合法的0.0 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先把指数按正数处理 </span></span><br><span class="line"><span class="keyword">int</span> temp = exponent &lt; <span class="number">0</span> ? -exponent : exponent;</span><br><span class="line"><span class="keyword">double</span> ans = powerWithUnsignedExponent(base, temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果指数是负数，结果取倒数 </span></span><br><span class="line"><span class="keyword">if</span> (exponent &lt; <span class="number">0</span>)</span><br><span class="line">ans = <span class="number">1</span> / ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer16-数值的整数次方P110&quot;&gt;&lt;a href=&quot;#剑指offer16-数值的整数次方P110&quot; class=&quot;headerlink&quot; title=&quot;剑指offer16.  数值的整数次方P110&quot;&gt;&lt;/a&gt;剑指offer16.  数值的整数次方P1
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer15. 二进制中1的个数 P100</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer15/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer15/</id>
    <published>2019-10-31T06:54:44.000Z</published>
    <updated>2019-10-31T07:14:15.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer15-二进制中1的个数-P100"><a href="#剑指offer15-二进制中1的个数-P100" class="headerlink" title="剑指offer15. 二进制中1的个数  P100"></a>剑指offer15. 二进制中1的个数  P100</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNumbersOfOne</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (flag) &#123;</span><br><span class="line"><span class="keyword">if</span> ((a &amp; flag)) ++count;</span><br><span class="line">flag = flag &lt;&lt; <span class="number">1</span>;   <span class="comment">//常规方法 让1从右往左分别与a的每一位与</span></span><br><span class="line">         <span class="comment">// 不能右移a，因为 0x80000000时死循环 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNumbersOfOne2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a) &#123;</span><br><span class="line">a &amp;= a - <span class="number">1</span>;    <span class="comment">// a&amp;a-1之后会刚好相当于a的二进制去掉一个最后一个1，</span></span><br><span class="line">++count;   <span class="comment">// 统计它循环次数就知道几个1了 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展：<br>1       一条语句判断整数是不是2的整数次方<br>2      两个整数m,n 求m要改变多少二进制位才能变成n</strong>  </p><p>1 （二进制中只有一个1）  </p><p>2 （1）先异或^（2）统计结果中1的个数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer15-二进制中1的个数-P100&quot;&gt;&lt;a href=&quot;#剑指offer15-二进制中1的个数-P100&quot; class=&quot;headerlink&quot; title=&quot;剑指offer15. 二进制中1的个数  P100&quot;&gt;&lt;/a&gt;剑指offer15. 二进制中
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="位运算" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer14. 剪绳子 P96</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer14/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer14/</id>
    <published>2019-10-31T06:54:39.000Z</published>
    <updated>2019-10-31T07:06:27.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer14-剪绳子-P96"><a href="#剑指offer14-剪绳子-P96" class="headerlink" title="剑指offer14 . 剪绳子 P96"></a>剑指offer14 . 剪绳子 P96</h2><p>题目：给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p><p><strong>动态规划</strong>，  令 f(n) 是长度n最后的最大乘积，剪在整数上i上 ，<br>显然f(n) = max( f(i) * f(n-i) )   i 从4到n，前3个要特判，因为当n等于1-3时，得到的乘积最大数和把前3个当作乘数因子（提供给后面4~n时的数当作f(i) 或者f(n-i)）不一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 要求length &gt; 1 </span></span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// 只能从i=1处剪 </span></span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;   <span class="comment">// 同上 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)); </span><br><span class="line"><span class="comment">// dp在前三个存的并不是答案，只是为了充当dp[i] 或 dp[n-i]，所以才在上面特判 </span></span><br><span class="line"><span class="comment">// 因为n是1到3时，还必须要剪一刀，但是充当乘法因子不一定要在它们中间剪 </span></span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">//前三个代表长度为i的子绳最大能提供的乘法因子是多少 </span></span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= length; ++i) &#123;    <span class="comment">// i是绳长</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">dp[i] = max(dp[i], dp[j] * dp[i - j]);</span><br><span class="line"><span class="comment">//括号里的dp[i]存的是前几个j的dp[i]的最大值，跟当前比 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> ans = dp[length];</span><br><span class="line">    <span class="keyword">delete</span> [ ] dp;</span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>贪心那个解法已然放弃。。。我这样的学术辣鸡不配使用贪心。</del> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer14-剪绳子-P96&quot;&gt;&lt;a href=&quot;#剑指offer14-剪绳子-P96&quot; class=&quot;headerlink&quot; title=&quot;剑指offer14 . 剪绳子 P96&quot;&gt;&lt;/a&gt;剑指offer14 . 剪绳子 P96&lt;/h2&gt;&lt;p&gt;题目：给你一
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer13. 机器人的运动范围 P92</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer13/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer13/</id>
    <published>2019-10-31T06:54:30.000Z</published>
    <updated>2019-10-31T07:03:14.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer13-机器人的运动范围-P92"><a href="#剑指offer13-机器人的运动范围-P92" class="headerlink" title="剑指offer13. 机器人的运动范围   P92"></a>剑指offer13. 机器人的运动范围   P92</h2><p>题目：地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和 大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前访问的格子是不是有效</span></span><br><span class="line"><span class="comment">// 参数：二维数组行，列总数，当前行，列索引，给定k值，访问标志</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="keyword">bool</span> *visited)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || visited[i * cols + j]) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">// 边界条件不满足，访问访问过</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> sum = <span class="number">0</span>;       <span class="comment">// i，j的各位和</span></span><br><span class="line"> <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line"> sum += i % <span class="number">10</span>;</span><br><span class="line"> i /= <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line"> sum += j % <span class="number">10</span>;</span><br><span class="line"> j /= <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (sum &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countS</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="keyword">bool</span> *visited)</span> </span>&#123; <span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (isValid(rows, cols, i, j, k, visited)) &#123;       <span class="comment">//当前格满足条件 </span></span><br><span class="line">visited[i * cols + j] = <span class="literal">true</span>;</span><br><span class="line">count =  <span class="number">1</span> + countS(rows, cols, i - <span class="number">1</span>, j,  k, visited) <span class="comment">//不是count += </span></span><br><span class="line">       + countS(rows, cols, i, j - <span class="number">1</span>,  k, visited) </span><br><span class="line">       + countS(rows, cols, i + <span class="number">1</span>, j,  k, visited) </span><br><span class="line">       + countS(rows, cols, i, j + <span class="number">1</span>,  k, visited);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">( <span class="keyword">int</span> k, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt; <span class="number">0</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line"><span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line"><span class="keyword">int</span> ans = countS(rows, cols, <span class="number">0</span>, <span class="number">0</span>, k, visited);<span class="comment">//不用再两层for遍历了 </span></span><br><span class="line"><span class="keyword">delete</span> []visited;    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer13-机器人的运动范围-P92&quot;&gt;&lt;a href=&quot;#剑指offer13-机器人的运动范围-P92&quot; class=&quot;headerlink&quot; title=&quot;剑指offer13. 机器人的运动范围   P92&quot;&gt;&lt;/a&gt;剑指offer13. 机器人的运动
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer12.  矩阵中匹配字符串 P89</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer12/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer12/</id>
    <published>2019-10-31T06:54:12.000Z</published>
    <updated>2019-10-31T06:59:36.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer12-矩阵中匹配字符串P89"><a href="#剑指offer12-矩阵中匹配字符串P89" class="headerlink" title="剑指offer12.  矩阵中匹配字符串P89"></a>剑指offer12.  矩阵中匹配字符串P89</h2><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有<br>字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、<br>上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入<br>该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字<br>母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个<br>字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。<br>A B T G<br>C F C S<br>J D E H</p><p>// 参数：原始数组，二维数组行，列，当前访问元素的行，列，<br>// 目标字符串，访问标志，路径索引</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHavePath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">bool</span> *visited, <span class="keyword">int</span>&amp; pathlength)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str[pathlength] == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// 匹配结束，返回true</span></span><br><span class="line"><span class="keyword">bool</span> havepath = <span class="literal">false</span>;               <span class="comment">// 答案</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前访问元素的行列没有越界，没有访问过，值和目标字符串对应位置一样</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols &amp;&amp; !visited[i * cols + j]  </span><br><span class="line">        &amp;&amp; matrix[i * cols + j] == str[pathlength]) &#123;</span><br><span class="line">    </span><br><span class="line">        visited[i * cols + j] = <span class="literal">true</span>;           <span class="comment">// 设置访问过</span></span><br><span class="line">    ++pathlength;          <span class="comment">// 注意：c++对于引用类型，不能传临时变量</span></span><br><span class="line">                              <span class="comment">// 也就是说，下面递归调用不能传pathlength+1</span></span><br><span class="line">    havepath = isHavePath(matrix,  rows,  cols,  i - <span class="number">1</span>, j, str, visited,  pathlength )</span><br><span class="line">             || isHavePath(matrix,  rows,  cols,  i, j - <span class="number">1</span>, str, visited,  pathlength )</span><br><span class="line">             || isHavePath(matrix,  rows,  cols,  i + <span class="number">1</span>, j, str, visited,  pathlength )</span><br><span class="line">             || isHavePath(matrix,  rows,  cols,  i, j + <span class="number">1</span>, str, visited,  pathlength );</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> (!havepath) &#123;         <span class="comment">// 没有找到，回溯，把访问标记和路径索引回溯-1</span></span><br><span class="line">visited[i * cols + j] = <span class="literal">false</span>;</span><br><span class="line">--pathlength;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> havepath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols,<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="literal">NULL</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span> || str == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>(rows * cols);   <span class="comment">// 访问标志初始化</span></span><br><span class="line"><span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> path = <span class="number">0</span>;                      </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;         <span class="comment">// 遍历二维数组每一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">**<span class="comment">// path = 0; 这个可写可不写，因为如果匹配失败，在上面递归函数里，// path会回溯-1，直到减回0；匹配 成功直接返回了**</span></span><br><span class="line"><span class="keyword">if</span> (isHavePath(matrix, rows, cols, i, j, str, visited, path))  <span class="comment">// 递归</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> []visited;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []visited;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer12-矩阵中匹配字符串P89&quot;&gt;&lt;a href=&quot;#剑指offer12-矩阵中匹配字符串P89&quot; class=&quot;headerlink&quot; title=&quot;剑指offer12.  矩阵中匹配字符串P89&quot;&gt;&lt;/a&gt;剑指offer12.  矩阵中匹配字符串P
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer11．旋转数组的最小数字 P82</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer11/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer11/</id>
    <published>2019-10-31T06:42:37.000Z</published>
    <updated>2019-10-31T06:51:30.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer11．-旋转数组的最小数字-P82"><a href="#剑指offer11．-旋转数组的最小数字-P82" class="headerlink" title="剑指offer11．  旋转数组的最小数字    P82"></a>剑指offer11．  旋转数组的最小数字    P82</h2><p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。</p><p><strong>看到有序两个字，要条件反射的想到二分。 这题应该注意的二分的划分依据是：中间值mid和子序列首尾大小比较（注意三者相等时的特殊情况），首先，i总是指向前面递增数组的元素，j总是指向后面递增数组的元素。<br>如果i和j相差是1的话，那么索引i指向第一个递增数组的末尾，j指向后一个递增数组的开头。自然j指的就是答案了</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int Min(int *num, int length) &#123;</span><br><span class="line">if (num == NULL || length &lt; 1)throw  (&quot;Invalid Input&quot;);</span><br><span class="line">if (length == 1 || num[0] &lt; num[length - 1])  return num[0];  // 递增</span><br><span class="line"></span><br><span class="line">int i = 0, j = length -1, mid = 0;</span><br><span class="line"></span><br><span class="line">while (i &lt;= j ) &#123;      </span><br><span class="line">    mid = ((j - i) &gt;&gt; 1) + i;</span><br><span class="line"></span><br><span class="line">    //三个指针值一样，不能二分，只有从头遍历</span><br><span class="line">    if (num[mid] == num[i] &amp;&amp; num[mid] ==num[j])&#123; </span><br><span class="line">for (int i = 1; i &lt; length; ++i) &#123;</span><br><span class="line">if (num[i] &lt; num[i - 1]) return num[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if (num[mid] &gt;= num[i]) </span><br><span class="line">            i = mid;        //往右二分，不能从mid+1开始，                     </span><br><span class="line">  // 因为如果mid此时刚好是答案，刚好错过正确的答案</span><br><span class="line">         else if (num[mid] &lt;= num[j]) </span><br><span class="line">j = mid;      // 往左二分 ，同样必须从mid开始</span><br><span class="line"></span><br><span class="line">     if (j - i == 1 )  return num[j]; // i指向前一个递增数组结尾，j指向后一个开头</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer11．-旋转数组的最小数字-P82&quot;&gt;&lt;a href=&quot;#剑指offer11．-旋转数组的最小数字-P82&quot; class=&quot;headerlink&quot; title=&quot;剑指offer11．  旋转数组的最小数字    P82&quot;&gt;&lt;/a&gt;剑指offer11．
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（扩展）快排 P80</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer扩展/</id>
    <published>2019-10-31T06:14:48.000Z</published>
    <updated>2019-10-31T06:51:46.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer（扩展）快排-P80"><a href="#剑指offer（扩展）快排-P80" class="headerlink" title="剑指offer（扩展）快排    P80"></a>剑指offer（扩展）快排    P80</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>快速排序  （递归实现）</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span> || start &gt; end || start &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> flag = nums[start], i = start, j = end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (nums[j] &gt;= flag &amp;&amp; i &lt; j)  --j;    <span class="comment">// 一定是 先 从右往左找</span></span><br><span class="line">nums[i] = nums[j];</span><br><span class="line"><span class="keyword">while</span>(nums[i] &lt;= flag &amp;&amp; i &lt; j)   ++i;</span><br><span class="line">    nums[j] = nums[i];</span><br><span class="line">&#125; </span><br><span class="line">nums[i] = flag;                           <span class="comment">// 确定当前基准值的位置 i</span></span><br><span class="line">quickSort(nums, start, i - <span class="number">1</span>);</span><br><span class="line">quickSort(nums, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>给公司员工年龄排序  P81</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ageSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="literal">NULL</span> || len &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> range_of_age_up  = <span class="number">100</span>;             <span class="comment">// 年龄上界</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> range_of_age_down = <span class="number">0</span>;             <span class="comment">//  年龄下界</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *hash = <span class="keyword">new</span> <span class="keyword">int</span>[range_of_age_up + <span class="number">1</span>];    <span class="comment">// hash表存对应年龄出现次数</span></span><br><span class="line"><span class="built_in">memset</span>(hash, <span class="number">0</span>, <span class="keyword">sizeof</span>(hash) * (range_of_age_up + <span class="number">1</span>) );  <span class="comment">// 注意长度！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; range_of_age_down || nums[i] &gt; range_of_age_up) &#123;   <span class="comment">// 异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"sorry , out of range !"</span>;</span><br><span class="line">&#125;</span><br><span class="line">++hash[nums[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;                          <span class="comment">// 排序后的数组索引 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= range_of_age_up; ++i)  <span class="comment">//  统计每个年龄 i出现的次数hash[j]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hash[i]; ++j)        <span class="comment">// 那么连着hash[j]个元素就是年龄i</span></span><br><span class="line">nums[index++] = i;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer（扩展）快排-P80&quot;&gt;&lt;a href=&quot;#剑指offer（扩展）快排-P80&quot; class=&quot;headerlink&quot; title=&quot;剑指offer（扩展）快排    P80&quot;&gt;&lt;/a&gt;剑指offer（扩展）快排    P80&lt;/h2&gt;&lt;figure
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer10. 高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题P74</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer10/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer10/</id>
    <published>2019-10-31T06:14:44.000Z</published>
    <updated>2019-10-31T06:51:18.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer10-高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题p74"><a href="#剑指offer10-高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题p74" class="headerlink" title="剑指offer10 .  高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题p74"></a>剑指offer10 .  高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题p74</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//优化后的斐波那契</span><br><span class="line">long long fb(int n) &#123;</span><br><span class="line">if (n &lt; 0) return -1;</span><br><span class="line"></span><br><span class="line">int table[2] = &#123;0, 1&#125;;</span><br><span class="line">if (n &lt; 2) return table[n];</span><br><span class="line"></span><br><span class="line">long long pre1 = 1, pre2 = 0, fbn = 0;</span><br><span class="line">for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">fbn = pre1 + pre2;</span><br><span class="line">pre2 = pre1;</span><br><span class="line">pre1 = fbn;</span><br><span class="line">&#125;</span><br><span class="line">return fbn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>青蛙跳台阶（只能跳1，2步）</strong>  </p><p>设f(n)表示青蛙跳上n级台阶的跳法数。当只有一个台阶时，<br>n = 1时， 只有1中跳法；    n = 2时，有两种跳法；；<br>当n很大时，青蛙在最后一步跳到第n级台阶时，有两种情况：<br>一种是青蛙在第n-1个台阶跳一个台阶，那么青蛙完成前面n-1个台阶，就有f(n-1)种跳法，这是一个子问题。<br>另一种是青蛙在第n-2个台阶跳两个台阶到第n个台阶，那么青蛙完成前面n-2个台阶，就有f(n-2)种情况，这又是另外一个子问题。<br>两个子问题构成了最终问题的解，所以当n&gt;=3时，青蛙就有f(n)=f(n-1)+f(n-2)种跳法。  </p><p><strong>扩展 ：如果一次可以跳1，2，3…n 级的话  f(n) = 2的n-1次方</strong><br>证明：  </p><pre><code>      f(n) = f(n-1) + f(n-2) + f(n-3) …+f(n-n)     方程1      f(n-1) = f(n-2) + f(n-3) + f(n-4) …+f(n-n)   方程2  方程1-2得 ：   f(n) – f(n-1) = f(n-1)               f(n) = 2*f(n-1) = 2*2*f(n-2)=…2的n-1次方</code></pre><p><strong>p79 页的矩阵覆盖也是同样的道理，不再赘述（注意n是初始几个值0，1，2的特判）</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer10-高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题p74&quot;&gt;&lt;a href=&quot;#剑指offer10-高效率斐波那契数列，青蛙台阶问题，矩阵覆盖问题p74&quot; class=&quot;headerlink&quot; title=&quot;剑指offer10 .  高效率斐波那契
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer9. 两个栈实现队列 P68</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer9/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer9/</id>
    <published>2019-10-31T06:14:40.000Z</published>
    <updated>2019-10-31T06:51:03.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer9-两个栈实现队列-p68"><a href="#剑指offer9-两个栈实现队列-p68" class="headerlink" title="剑指offer9. 两个栈实现队列 p68"></a>剑指offer9. 两个栈实现队列 p68</h2><p>题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 </p><p>/*在stack1 中存入；从stack2里取，如果取得时候2是null，把1的值全压到2再取 */</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdexcept&gt; </span><br><span class="line">template &lt;typename T&gt; class CQueue &#123;</span><br><span class="line">public:</span><br><span class="line">CQueue(void)&#123; &#125;;                    // 不能只写个名字</span><br><span class="line">~CQueue(void)&#123;&#125;;</span><br><span class="line">void appendTail(const T&amp; node) &#123;    // node的值不能被改变</span><br><span class="line">stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line">T deleteHead() &#123;</span><br><span class="line">if (stack2.empty()) &#123;</span><br><span class="line">    while (!stack1.empty()) &#123;</span><br><span class="line">    stack2.push(stack1.top());</span><br><span class="line">    stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    if (stack2.empty())  &#123;      // 说明没有插入数据 ，抛出，不会往下执行 </span><br><span class="line">    std::logic_error ex(&quot;queue is null !&quot;);</span><br><span class="line">                throw std::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    T t = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">std::stack&lt;T&gt; stack1;</span><br><span class="line">std::stack&lt;T&gt; stack2; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>扩展： 用两个队列模拟栈</strong><br><strong>思想</strong>： 两个队列交替充当队列。比如 压栈c时：往非空的队列1插入c，1内容变成cba。弹栈时，需要的是c，但是队列1头是a，那么依此把队列1的内容插入队列2中，把最后一个元素c返回。这时队列2变成非空了，那么再压栈就往2里插入了。如此循环</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer9-两个栈实现队列-p68&quot;&gt;&lt;a href=&quot;#剑指offer9-两个栈实现队列-p68&quot; class=&quot;headerlink&quot; title=&quot;剑指offer9. 两个栈实现队列 p68&quot;&gt;&lt;/a&gt;剑指offer9. 两个栈实现队列 p68&lt;/h2
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="栈&amp;队列" scheme="http://yoursite.com/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer8. 二叉树的下一个节点 P65</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer8/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer8/</id>
    <published>2019-10-31T06:14:35.000Z</published>
    <updated>2019-10-31T06:50:52.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer8-二叉树的下一个节点-P65"><a href="#剑指offer8-二叉树的下一个节点-P65" class="headerlink" title="剑指offer8. 二叉树的下一个节点   P65"></a>剑指offer8. 二叉树的下一个节点   P65</h2><p>题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？<br>树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。</p><p><strong>Case1:  p有右子树， 答案next就是右子树最左节点<br>Case2:  p 无右子树,  且是父节点的左儿子，next就是父节点<br>Case3:  p 无右子树,  且是父节点的右儿子，那么沿着右分支往上一直找父节点，当前节点cur = parent; 当前节点的父节点parent = parent -&gt; m_pParent; 直到父节点parent是null（这时cur是根节点），或者还有父节点但是已经不是沿右分支了（parent -&gt; m_pRight ！= cur），那么这第一个左分支的父节点（parent）就是next。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode *<span class="title">getNextNode</span><span class="params">(BinaryTreeNode *p)</span> </span>&#123;<span class="comment">//不用传根，p带的就是树的信息</span></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode *nextNode = <span class="literal">NULL</span>;   <span class="comment">// 可以覆盖p是最后一个节点情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p -&gt; m_pRight != <span class="literal">NULL</span>) &#123;         <span class="comment">// case1</span></span><br><span class="line">BinaryTreeNode *right = p -&gt; m_pRight;</span><br><span class="line"><span class="keyword">while</span> (right -&gt; m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">right = right -&gt; m_pLeft;</span><br><span class="line"></span><br><span class="line">nextNode = right;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (p -&gt; m_pParent != <span class="literal">NULL</span>) &#123;   <span class="comment">// case2，3 可以一起处理</span></span><br><span class="line">BinaryTreeNode *parent = p -&gt; m_pParent;</span><br><span class="line">BinaryTreeNode *cur    = p;</span><br><span class="line">            <span class="comment">// case2 不会进入这个循环，因为不满足第二个条件</span></span><br><span class="line"><span class="keyword">while</span> (parent != <span class="literal">NULL</span> &amp;&amp; parent -&gt; m_pRight== cur) &#123;<span class="comment">//沿右分支找父亲</span></span><br><span class="line">cur = parent;</span><br><span class="line">parent = parent -&gt; m_pParent;</span><br><span class="line"></span><br><span class="line">    &#125;                   <span class="comment">// 循环结束，case3就转换到和case2的情况了</span></span><br><span class="line">    nextNode = parent;  <span class="comment">// 下一个节点就是父节点</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> nextNode;     <span class="comment">// 如果p是最后一个节点，上面if else都不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer8-二叉树的下一个节点-P65&quot;&gt;&lt;a href=&quot;#剑指offer8-二叉树的下一个节点-P65&quot; class=&quot;headerlink&quot; title=&quot;剑指offer8. 二叉树的下一个节点   P65&quot;&gt;&lt;/a&gt;剑指offer8. 二叉树的下一个
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer7. 重建二叉树 P62</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer7/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer7/</id>
    <published>2019-10-31T06:14:31.000Z</published>
    <updated>2019-10-31T06:50:36.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer7-重建二叉树-p62"><a href="#剑指offer7-重建二叉树-p62" class="headerlink" title="剑指offer7. 重建二叉树   p62"></a>剑指offer7. 重建二叉树   p62</h2><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出 图2.6所示的二叉树并输出它的头结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>            key;</span><br><span class="line">BinaryTreeNode *left;</span><br><span class="line">BinaryTreeNode *right;</span><br><span class="line">BinaryTreeNode(<span class="keyword">int</span> val) &#123;  key = val;   left = right =<span class="literal">NULL</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// pre,in 分别是先序和中序列，length是序列长 </span></span><br><span class="line"><span class="function">BinaryTreeNode *<span class="title">constructBinaryTree</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pre.size() == <span class="number">0</span> || in.size() == <span class="number">0</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">BinaryTreeNode *head = <span class="keyword">new</span> BinaryTreeNode(pre[<span class="number">0</span>]); <span class="comment">//初始化根节点 </span></span><br><span class="line"><span class="comment">// 下面四个数组分别存储左，右子树的先根，中根序列</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftpre, leftin, rightpre, rightin;</span><br><span class="line"><span class="keyword">int</span> root;                <span class="comment">// 根节点索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (in[i] == pre[<span class="number">0</span>]) &#123;  <span class="comment">// 在中根序列中找到当前树根节点root的索引 </span></span><br><span class="line">root = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root; ++i) &#123; <span class="comment">// 以root为界左边是左子树的先序，中序</span></span><br><span class="line">leftpre.push_back(pre[i + <span class="number">1</span>]);</span><br><span class="line">leftin.push_back(in[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = root + <span class="number">1</span>; i &lt;length; ++i) &#123;<span class="comment">//以root为界右边是右子树的先序，中序</span></span><br><span class="line">rightpre.push_back(pre[i]);</span><br><span class="line">rightin.push_back(in[i]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下面完成父子节点的链接 ，并递归构建左右子树</span></span><br><span class="line">head -&gt; left  =  constructBinaryTree(leftpre, leftin, leftpre.size());</span><br><span class="line">head -&gt; right =  constructBinaryTree(rightpre, rightin, rightpre.size());</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer7-重建二叉树-p62&quot;&gt;&lt;a href=&quot;#剑指offer7-重建二叉树-p62&quot; class=&quot;headerlink&quot; title=&quot;剑指offer7. 重建二叉树   p62&quot;&gt;&lt;/a&gt;剑指offer7. 重建二叉树   p62&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer6. 插入并从尾到头打印链表 P58</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer6/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer6/</id>
    <published>2019-10-31T06:14:27.000Z</published>
    <updated>2019-10-31T06:50:19.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer6-插入并从尾到头打印链表P58"><a href="#剑指offer6-插入并从尾到头打印链表P58" class="headerlink" title="剑指offer6 .  插入并从尾到头打印链表P58"></a>剑指offer6 .  插入并从尾到头打印链表P58</h2><p>题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>      key;</span><br><span class="line">ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToTail</span><span class="params">(ListNode **pHead, <span class="keyword">int</span> value)</span> </span>&#123; <span class="comment">// 调用时实参指针pHead应该取引用</span></span><br><span class="line">ListNode *temp = <span class="keyword">new</span> ListNode;</span><br><span class="line">temp -&gt; key = value;</span><br><span class="line">temp -&gt; next =<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (*pHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line">*pHead = temp;</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line">ListNode* p = *pHead;</span><br><span class="line"><span class="keyword">while</span> (p -&gt; next != <span class="literal">NULL</span>) p = p -&gt; next;</span><br><span class="line">p -&gt; next = temp; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListReversingly</span><span class="params">(ListNode *pHead)</span> </span>&#123;  <span class="comment">//用栈实现 反向便利 </span></span><br><span class="line"><span class="built_in">std</span>:: <span class="built_in">stack</span>&lt;ListNode* &gt; nodes;</span><br><span class="line">ListNode *p = pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">nodes.push(p);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span> (!nodes.empty()) &#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; nodes.top() -&gt; key &lt;&lt; <span class="built_in">std</span>:: <span class="built_in">endl</span>;</span><br><span class="line">nodes.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListReversingRecursively</span><span class="params">(ListNode *pHead)</span> </span>&#123;  <span class="comment">//递归实现 </span></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">printListReversingRecursively(pHead -&gt; next);</span><br><span class="line"><span class="built_in">std</span>:: <span class="built_in">cout</span>&lt;&lt; pHead -&gt; key &lt;&lt; <span class="built_in">std</span>:: <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer6-插入并从尾到头打印链表P58&quot;&gt;&lt;a href=&quot;#剑指offer6-插入并从尾到头打印链表P58&quot; class=&quot;headerlink&quot; title=&quot;剑指offer6 .  插入并从尾到头打印链表P58&quot;&gt;&lt;/a&gt;剑指offer6 .  插入
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer5. 替换空格   P51</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer5/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer5/</id>
    <published>2019-10-31T06:14:21.000Z</published>
    <updated>2019-10-31T06:50:02.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-5-替换空格-P51"><a href="#剑指offer-5-替换空格-P51" class="headerlink" title="剑指offer 5. 替换空格   P51"></a>剑指offer 5. 替换空格   P51</h2><p><strong>1.    第一种做法可以用sting = “”,遍历原始数组，遇到非空格直接加，遇到空格加上%20，最后string就是答案。 这种做法比较简洁易懂，但是空间复杂度是O(N)</strong></p><p><strong>2.    第二种做法就是书上的用两个指针倒着工作。在原地操作，空间开销小</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceBlank</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">string</span> == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>, old_tail = <span class="number">0</span>;  <span class="comment">// 记录空格数；原数组索引指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">string</span>[old_tail] != <span class="string">'\0'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">string</span>[old_tail] == <span class="string">' '</span>)</span><br><span class="line">        ++count;</span><br><span class="line">    old_tail++;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">// 新数组结尾</span></span><br><span class="line"><span class="keyword">int</span> new_tail = old_tail + count * <span class="number">2</span>;        <span class="comment">//不是*3，因为原来的空格还可以放一个</span></span><br><span class="line"><span class="keyword">if</span> (new_tail &gt; length)  <span class="keyword">return</span>;           <span class="comment">//不能=， 因为’\0’</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (old_tail &gt;= <span class="number">0</span>) &#123;                 <span class="comment">// 两个指针一起倒着走</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">string</span>[old_tail] != <span class="string">' '</span>) <span class="built_in">string</span>[new_tail--] = <span class="built_in">string</span>[old_tail];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">string</span>[new_tail--] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">string</span>[new_tail--] = <span class="string">'2'</span>;</span><br><span class="line">    <span class="built_in">string</span>[new_tail--] = <span class="string">'%'</span>;</span><br><span class="line">&#125;</span><br><span class="line">old_tail--;                       <span class="comment">//不能在if里面减 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展： 有两个从小到大排序数组a，b。 a尾部有足够的空间容纳b，试着把b合并到a中，并且保持依然有序。</strong> </p><p>思想：跟这题很像，可以确定a的新结尾len（a）+len(b) – 1；然后倒着遍历两数组，把较大的放入新结尾，更新工作指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-5-替换空格-P51&quot;&gt;&lt;a href=&quot;#剑指offer-5-替换空格-P51&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 5. 替换空格   P51&quot;&gt;&lt;/a&gt;剑指offer 5. 替换空格   P51&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer4.二维数组中查找  P44</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer4/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer4/</id>
    <published>2019-10-31T06:11:24.000Z</published>
    <updated>2019-10-31T06:49:36.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer4-二维数组中查找-P44"><a href="#剑指offer4-二维数组中查找-P44" class="headerlink" title="剑指offer4. 二维数组中查找  P44"></a>剑指offer4. 二维数组中查找  P44</h2><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按<br>照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个<br>整数，判断数组中是否含有该整数。</p><p>c++传二维数组，要么像下面这样传一维指针之后计算（此时实参不能new或者malloc出，因为地址可能不连续） 要么必须指明所有维数大小或者省略第一维的，但是不能省略第二维或者更高维的大小，这是由编译器原理限制的。<br>编译器是这样处理数组的：</p><p>对于数组 int p[m][n];如果要取p[i][j]的值(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; 0&lt;=j &amp;&amp; j &lt; n)，编译器是这样寻址的，它的地址为：<br> p + i*n + j; （p是数组首地址）所以不指定n的话，没办法计算。 </p><p>建议用vector数组替代二维数组，使用灵活，且不涉及指针这种乱七八糟的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  行是增的，列是减的    注意： 本题用不了横纵向的二分查找！！！*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumbers</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span> *martix, <span class="keyword">int</span> t, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((martix == <span class="literal">NULL</span>) || (rows == <span class="number">0</span> &amp;&amp; columns == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = columns - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span>) &#123;   <span class="comment">// 注意两个边界不一样 </span></span><br><span class="line"><span class="keyword">int</span> temp = martix[x * columns + y];</span><br><span class="line">    <span class="keyword">if</span> (temp == t) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; temp)</span><br><span class="line">        ++x;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        --y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer4-二维数组中查找-P44&quot;&gt;&lt;a href=&quot;#剑指offer4-二维数组中查找-P44&quot; class=&quot;headerlink&quot; title=&quot;剑指offer4. 二维数组中查找  P44&quot;&gt;&lt;/a&gt;剑指offer4. 二维数组中查找  P44&lt;/
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 3. 数组中重复的(所有)数字</title>
    <link href="http://yoursite.com/2019/10/31/%E5%89%91%E6%8C%87offer3/"/>
    <id>http://yoursite.com/2019/10/31/剑指offer3/</id>
    <published>2019-10-31T04:04:12.000Z</published>
    <updated>2019-10-31T06:13:56.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-数组中重复的-所有-数字-p39"><a href="#3-数组中重复的-所有-数字-p39" class="headerlink" title="3 . 数组中重复的(所有)数字  p39"></a>3 . 数组中重复的(所有)数字  p39</h2><p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。<br><strong>（原题只是找出一个，下面实现比原题多一步，打印所有的）</strong></p><p><strong>1.    允许修改数组</strong></p><p>因为每个数字都只能对应一个索引，从索引i=0开始一步一步找到所有i对应的数，那么一定会慢慢逼近到有个值是i，但是不在索引i（i已经有一个值=i了）上。<br>尽管有for，while两重循环，但是基本上每一次比较之后要么前进，要么交换（交换后保证一个元素处在自己的索引位置, 遍历到它的时候就跳过，这也相当于前进了），所以时间复杂度还是O（n），空间复杂度是O（1）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void duplication (int numbers[], int length, set&lt;int &gt; &amp;ans) &#123;</span><br><span class="line">    if (length &lt; 2 || numbers == NULL)   return ;</span><br><span class="line">for (int i = 0; i &lt; length; ++i)          // 数组中出现值超过索引界限</span><br><span class="line">if (numbers[i] &gt;= length || numbers[i] &lt; 0) return; </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; length; ++i) &#123;</span><br><span class="line">        while (numbers[i] != i) &#123;           // 一定会满足</span><br><span class="line">            if (numbers[i] == numbers[numbers[i]]) &#123;</span><br><span class="line">                ans.insert(numbers[i]); </span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int temp = numbers[i];</span><br><span class="line">                numbers[i] = numbers[temp];</span><br><span class="line">                numbers[temp] = temp; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">   int a[] = &#123;1,2,3,4,1,1,2,3,3,3&#125;;</span><br><span class="line">   set&lt;int&gt; ans; // 把所有数字存入，用set会过滤掉重复数字</span><br><span class="line">   duplication(a, sizeof(a) / sizeof(a[0]), ans);</span><br><span class="line">   if (ans.size() == 0) cout &lt;&lt; 0 &lt;&lt;endl;  // 不存在</span><br><span class="line">   set &lt;int&gt; :: iterator it;</span><br><span class="line">   for (it = ans.begin(); it != ans.end(); ++it) </span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; endl; </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 不允许修改数组  P41</strong><br>找出数组中重复的数字用O(1)空间，nlogn时间，<strong>不能找出来所有重复数字</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int countNumbersBetweenStartAndEnd(const int *nums, int length,int start,int end) &#123;</span><br><span class="line">if (nums == NULL || length &lt; 1) return 0;</span><br><span class="line">int count = 0;</span><br><span class="line">for (int i = 0; i &lt; length; ++i) &#123;</span><br><span class="line">if (nums[i] &gt;= start &amp;&amp; nums[i] &lt;= end) ++count;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findRepeatNumber(const int *nums, int length) &#123; </span><br><span class="line">if (nums == NULL || length &lt; 2) return -1;</span><br><span class="line">    int start = 1;                  //这是边界范围，不是索引 </span><br><span class="line">int end = length - 1;</span><br><span class="line">while (start &lt;= end) &#123;</span><br><span class="line">int mid = ((end - start) &gt;&gt; 1) + start;</span><br><span class="line">//默认先在左边范围统计</span><br><span class="line">int count = countNumbersBetweenStartAndEnd(nums, length, start, mid);</span><br><span class="line">if (start == end) &#123;                         // 循环出口</span><br><span class="line">if (count &gt;= 2) return start;</span><br><span class="line">else return -1;                       // 没有找到</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (count &gt; mid - start + 1) end = mid;  // 确实在左边重复</span><br><span class="line">else start = mid + 1;                 // 左边没有重复右“循环”</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-数组中重复的-所有-数字-p39&quot;&gt;&lt;a href=&quot;#3-数组中重复的-所有-数字-p39&quot; class=&quot;headerlink&quot; title=&quot;3 . 数组中重复的(所有)数字  p39&quot;&gt;&lt;/a&gt;3 . 数组中重复的(所有)数字  p39&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>README</title>
    <link href="http://yoursite.com/2019/10/30/README/"/>
    <id>http://yoursite.com/2019/10/30/README/</id>
    <published>2019-10-30T08:11:01.000Z</published>
    <updated>2019-10-31T07:41:46.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人博客-Github-Page"><a href="#个人博客-Github-Page" class="headerlink" title="个人博客 Github Page"></a>个人博客 Github Page</h1><h4 id="剑指offer题解正在上传中，大部分都带有思路整理，代码也有详细注释"><a href="#剑指offer题解正在上传中，大部分都带有思路整理，代码也有详细注释" class="headerlink" title="剑指offer题解正在上传中，大部分都带有思路整理，代码也有详细注释"></a>剑指offer题解正在上传中，大部分都带有思路整理，代码也有详细注释</h4><h4 id="题解格式特别整理了一下，个人觉得很适合阅读"><a href="#题解格式特别整理了一下，个人觉得很适合阅读" class="headerlink" title="题解格式特别整理了一下，个人觉得很适合阅读"></a>题解格式特别整理了一下，个人觉得很适合阅读</h4><h4 id="Leetcode题解暂时只做了Array的80道左右，但是以前做的很多都忘了，现在在慢慢整理"><a href="#Leetcode题解暂时只做了Array的80道左右，但是以前做的很多都忘了，现在在慢慢整理" class="headerlink" title="Leetcode题解暂时只做了Array的80道左右，但是以前做的很多都忘了，现在在慢慢整理~"></a>Leetcode题解暂时只做了Array的80道左右，但是以前做的很多都忘了，现在在慢慢整理~</h4><hr><p><em>如果您觉得此份文档对您有些许帮助的话，请您去我的GitHub首页star一下！ [比心~]</em><br><a href="http://github.com/nobugsinlinux" target="_blank" rel="noopener" title="点这里~">http://github.com/nobugsinlinux</a></p><hr><blockquote><p><strong>不患无位，患所以立。     Have a nice day !</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;个人博客-Github-Page&quot;&gt;&lt;a href=&quot;#个人博客-Github-Page&quot; class=&quot;headerlink&quot; title=&quot;个人博客 Github Page&quot;&gt;&lt;/a&gt;个人博客 Github Page&lt;/h1&gt;&lt;h4 id=&quot;剑指offer题解
      
    
    </summary>
    
    
      <category term="README" scheme="http://yoursite.com/categories/README/"/>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
